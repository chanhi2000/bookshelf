import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as u,d as s,f as a,b as d,t as k,n as m,g as h,w as t,r as p,o as y,e as o}from"./app-BVguHYKu.js";const g={},f={id:"frontmatter-title-관련",tabindex:"-1"},v={class:"header-anchor",href:"#frontmatter-title-관련"},b={class:"table-of-contents"};function w(i,n){const l=p("VPCard"),e=p("router-link"),c=p("SiteInfo");return y(),u("div",null,[s("h1",f,[s("a",v,[s("span",null,k(i.$frontmatter.title)+" 관련",1)])]),a(l,m(h({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",b,[s("ul",null,[s("li",null,[a(e,{to:"#union-types"},{default:t(()=>n[0]||(n[0]=[o("Union types")])),_:1,__:[0]})]),s("li",null,[a(e,{to:"#union-types-with-errors"},{default:t(()=>n[1]||(n[1]=[o("Union types with errors")])),_:1,__:[1]})]),s("li",null,[a(e,{to:"#discussion-about-name"},{default:t(()=>n[2]||(n[2]=[o("Discussion about name")])),_:1,__:[2]})]),s("li",null,[a(e,{to:"#conclusion"},{default:t(()=>n[3]||(n[3]=[o("Conclusion")])),_:1,__:[3]})])])]),n[4]||(n[4]=s("hr",null,null,-1)),a(c,{name:"The problem of union types for type systems",desc:"Why union types are not such a good idea for static type systems.",url:"https://kt.academy/article/union-types-into",logo:"https://kt.academy/logo.png",preview:"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-cover.jpg&w=576&q=75"}),n[5]||(n[5]=d(`<p>KotlinConf 2024 shocked me with a new announcement. Union types are coming to Kotlin! However, in a limited form. At first, I couldn&#39;t understand why, but after some talks and discussions, I realized that it is a very smart move. Now let me show you the big picture.</p><hr><h2 id="union-types" tabindex="-1"><a class="header-anchor" href="#union-types"><span>Union types</span></a></h2><p>One feature I have always admired in other programming languages is union types, such as Int | String. I haven’t had any specific plans for using it, but it seems to offer an additional level of expressiveness. I often wondered why Kotlin didn&#39;t include this feature. Now I understand why!</p><p>Let&#39;s start our story with an example of where union types shine. Imagine that a variable is either String or Int. Currently, the result is Any, but it could instead be a more specific String | Int that, after is-checking for one type, could be smart cast to another.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">val</span> intOrString<span class="token operator">:</span> Int | String <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token string-literal singleline"><span class="token string">&quot;One&quot;</span></span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>intOrString <span class="token keyword">is</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        intOrString <span class="token comment">// smart-casted to Int</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        intOrString <span class="token comment">// smart-casted to String</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Union types could be passed around as a substitute for the current <code>Either</code> or <code>Result</code> classes.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> UserId<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span>isFile<span class="token operator">:</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> Either<span class="token operator">&lt;</span>FileConfig<span class="token punctuation">,</span> DatabaseConfig<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token comment">// to</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> UserId<span class="token punctuation">)</span><span class="token operator">:</span> User | ApiException <span class="token operator">=</span> <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span>isFile<span class="token operator">:</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> FileConfig | DatabaseConfig <span class="token operator">=</span> <span class="token comment">/* ... */</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As cool as it might look, now let&#39;s consider how much complexity it introduces to our type system. Consider the following example. What type should be the result of List and List? <code>List</code>, <code>List&lt;Dog | Cat&gt;</code> or <code>List | List</code>? The first option seems most intuitive, and the last one most precise.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">abstract</span> <span class="token keyword">class</span> Animal</span>
<span class="line"><span class="token keyword">class</span> Dog<span class="token operator">:</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">class</span> Cat<span class="token operator">:</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">produceAnimals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That is just the beginning of troubles. Type <code>Dog | Cat</code> would need to be a subtype of Animal, as well as all other types common to all interfaces in the union.</p><p>This is especially problematic once we consider generic classes. The following code would not compile because the inferred type of animals would be <code>MutableList&lt;Cat | Dog&gt;</code>. Currently, it would compile because it is MutableList.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">abstract</span> <span class="token keyword">class</span> Animal</span>
<span class="line"><span class="token keyword">class</span> Dog<span class="token operator">:</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">class</span> Cat<span class="token operator">:</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">class</span> Snake<span class="token operator">:</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">val</span> animals <span class="token operator">=</span> <span class="token function">mutableListOf</span><span class="token punctuation">(</span><span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">animals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">Snake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The problem with generics is far deeper. It is actually proved that inference is NP-hard in the presence of union types. The following slide offers a hint why.</p><figure><img src="https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-NP-hard.png&amp;w=576&amp;q=75" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>In general, subtyping with generics is not decidable. This means that there is no algorithm that can determine, in a finite amount of time, whether a given type-related question can be resolved. Union types make things even harder, especially for inference.</p><figure><img src="https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-undecidable.png&amp;w=576&amp;q=75" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>That seems like an absolute blocker for union types, but as researcher Ross Tate discovered, there is a way to have a cake and eat it too. As it turns out, there is one particular use case where we use union type substitutions, and that case does not cause any of the problems mentioned above. It is using union types to represent either a result or a failure.</p><hr><h2 id="union-types-with-errors" tabindex="-1"><a class="header-anchor" href="#union-types-with-errors"><span>Union types with errors</span></a></h2><p>The Lead Kotlin Designer announced union types with errors. That will most likely mean special classes that specify throwable errors.</p><p>Union types are supertypes of both types, so <code>String | Error</code> is a supertype of both <code>String</code> and <code>Error</code>, so it accepts both <code>String</code> and <code>Error</code>. Just like Int? accepts both Int and null (Int? is like <code>Int | null</code>).</p><p><img src="https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-error-type.png&amp;w=576&amp;q=75" alt="" loading="lazy"><!-- TODO: mermaid로 작성 --></p><p>This feature should particularly help when a variable needs to represent either a value or a placeholder for a lack of value, like <code>T | NotFound</code>. It is useful when null cannot represent a lack of value.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">private</span> error <span class="token keyword">object</span> NotFound</span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Sequence<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token function">last</span><span class="token punctuation">(</span>predicate<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">var</span> result<span class="token operator">:</span> T | NotFound <span class="token operator">=</span> NotFound</span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span>element <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">predicate</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span> result <span class="token operator">=</span> element</span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">is</span> NotFound<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">NoSuchElementException</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Not found&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    result</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Union types with errors are also a replacement for types like <code>Either</code> or <code>Result</code>, just like nullable types were a replacement for <code>Optional</code>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> UserId<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span>isFile<span class="token operator">:</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> Either<span class="token operator">&lt;</span>FileConfig<span class="token punctuation">,</span> DatabaseConfig<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token comment">// to</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">fetchUser</span><span class="token punctuation">(</span>userId<span class="token operator">:</span> UserId<span class="token punctuation">)</span><span class="token operator">:</span> User | ApiException <span class="token operator">=</span> <span class="token comment">/* ... */</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">loadConfig</span><span class="token punctuation">(</span>isFile<span class="token operator">:</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> FileConfig | DatabaseConfig <span class="token operator">=</span> <span class="token comment">/* ... */</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>What is the advantage of using union types with errors instead of Either or Result? As a built-in construct, it can be much more efficient and convenient.</p><p>Either or Result must be represented with an object, that stores a value. Union types do not need that, they allow raw value passing. That also means we do not need to pack values, we can just use them where needed.</p><p>Union types with errors also support a number of operators, similar to those supported for nullable types.</p><ul><li><code>!.</code> call will call a function or a property only if value is not an error, so <code>a!.b</code> translates to <code>if(a is Error) a else a.b</code></li><li><code>!:</code> provides a default value in case of an error, so <code>a !: b</code> translates to <code>if(a is Error) b else a</code></li><li><code>!!</code> just throws the throwable error if this value is an error, or returns the other value otherwise. So a!! translates to <code>if(a is Error) a.throw() else a</code></li></ul><p>With such support, we will be able to conveniently transform values in functional style. Just like we do now with nullability, but errors additionally store information about what went wrong.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token comment">// Implicit exceptions</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">getStudents</span><span class="token punctuation">(</span>semester<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token operator">&lt;</span>ExposedStudent<span class="token operator">&gt;</span> <span class="token operator">=</span></span>
<span class="line">  <span class="token function">produceGetStudentsRequest</span><span class="token punctuation">(</span>semester<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">let</span> <span class="token punctuation">{</span> studentRepository<span class="token punctuation">.</span><span class="token function">getStudents</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span> logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span><span class="token expression">it<span class="token punctuation">.</span>size</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> students in </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">semester</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> stduentFactory<span class="token punctuation">.</span><span class="token function">produceExposed</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// With Result</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Union types will be introduced step-by-step, first inside Kotlin stdlib to optimize algorithms.</p><hr><h2 id="discussion-about-name" tabindex="-1"><a class="header-anchor" href="#discussion-about-name"><span>Discussion about name</span></a></h2><p>I wondered, why &quot;union types with errors&quot;, and not &quot;exceptions&quot;, &quot;throwables&quot; or something else. I asked about it Ross Tate, and as it turns out, the name is not final. The Kotlin team is still discussing it. I was even asked to start a discussion about it. So here it is:</p><hr><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>Union types with errors are a very smart move. They offer a lot of expressiveness without introducing the complexity of full union types. They are a perfect fit for representing either a result or a failure.</p>`,40))])}const T=r(g,[["render",w]]),I=JSON.parse('{"path":"/kt.academy/union-types-into.html","title":"The problem of union types for type systems","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"The problem of union types for type systems","description":"Article(s) > The problem of union types for type systems","icon":"iconfont icon-kotlin","category":["Kotlin","Article(s)"],"tag":["blog","kt.academy","kotlin","kt"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"The problem of union types for type systems\\",\\"image\\":[\\"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-NP-hard.png&w=576&q=75\\",\\"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-undecidable.png&w=576&q=75\\",\\"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-error-type.png&w=576&q=75\\"],\\"datePublished\\":\\"2024-06-10T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Marcin Moskała\\",\\"url\\":\\"https://kt.academy/user/marcinmoskala\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/union-types-into.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"The problem of union types for type systems"}],["meta",{"property":"og:description","content":"Article(s) > The problem of union types for type systems"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-cover.jpg&w=576&q=75"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-cover.jpg&w=576&q=75"}],["meta",{"name":"twitter:image:alt","content":"The problem of union types for type systems"}],["meta",{"property":"article:author","content":"Marcin Moskała"}],["meta",{"property":"article:tag","content":"kt"}],["meta",{"property":"article:tag","content":"kotlin"}],["meta",{"property":"article:tag","content":"kt.academy"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-06-10T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > The problem of union types for type systems"},{"property":"og:description","content":"The problem of union types for type systems"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/union-types-into.html"}]],"prev":"/programming/java/articles/README.md","date":"2024-06-10T00:00:00.000Z","isOriginal":false,"author":[{"name":"Marcin Moskała","url":"https://kt.academy/user/marcinmoskala"}],"cover":"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Funion-types-intro-cover.jpg&w=576&q=75"},"git":{},"readingTime":{"minutes":4.34,"words":1302},"filePathRelative":"kt.academy/union-types-into.md","copyright":{"author":"Marcin Moskała"}}');export{T as comp,I as data};
