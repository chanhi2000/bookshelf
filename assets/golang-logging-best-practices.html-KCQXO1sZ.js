import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as d,d as e,f as s,b as h,a as m,t as f,n as r,g,w as t,r as i,o as v,e as o}from"./app-BItykJLQ.js";const k={},b={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},y={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},w={class:"table-of-contents"};function x(p,n){const l=i("VPCard"),a=i("router-link"),c=i("SiteInfo");return v(),d("div",null,[e("h1",b,[e("a",y,[e("span",null,f(p.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),s(l,r(g({title:"Go > Article(s)",desc:"Article(s)",link:"/programming/go/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e("nav",w,[e("ul",null,[e("li",null,[s(a,{to:"#enter-golang"},{default:t(()=>[...n[0]||(n[0]=[o("Enter Golang",-1)])]),_:1})]),e("li",null,[s(a,{to:"#the-dual-role-of-logging-in-go"},{default:t(()=>[...n[1]||(n[1]=[o("The Dual Role of Logging in Go",-1)])]),_:1})]),e("li",null,[s(a,{to:"#decoding-logging-levels-in-golang"},{default:t(()=>[...n[2]||(n[2]=[o("Decoding Logging Levels in Golang",-1)])]),_:1}),e("ul",null,[e("li",null,[s(a,{to:"#the-essence-of-logging-levels"},{default:t(()=>[...n[3]||(n[3]=[o("The Essence of Logging Levels",-1)])]),_:1})]),e("li",null,[s(a,{to:"#go-s-built-in-logging-nuances"},{default:t(()=>[...n[4]||(n[4]=[o("Go‚Äôs Built-in Logging Nuances",-1)])]),_:1})]),e("li",null,[s(a,{to:"#understanding-the-landscape-of-logging-levels"},{default:t(()=>[...n[5]||(n[5]=[o("Understanding the Landscape of Logging Levels",-1)])]),_:1})])])]),e("li",null,[s(a,{to:"#getting-started-with-go-s-built-in-log-package"},{default:t(()=>[...n[6]||(n[6]=[o("Getting Started with Go‚Äôs Built-in log Package",-1)])]),_:1}),e("ul",null,[e("li",null,[s(a,{to:"#a-dive-into-basic-logging-with-go-simple-examples"},{default:t(()=>[...n[7]||(n[7]=[o("A Dive into Basic Logging with Go: Simple Examples",-1)])]),_:1})])])]),e("li",null,[s(a,{to:"#structuring-log-messages-for-clarity"},{default:t(()=>[...n[8]||(n[8]=[o("Structuring Log Messages for Clarity",-1)])]),_:1}),e("ul",null,[e("li",null,[s(a,{to:"#essential-elements-in-structured-logging-package"},{default:t(()=>[...n[9]||(n[9]=[o("Essential Elements in Structured Logging Package",-1)])]),_:1})]),e("li",null,[s(a,{to:"#harnessing-log-setprefix-and-log-setflags-for-enhanced-log-structure"},{default:t(()=>[...n[10]||(n[10]=[o("Harnessing log.SetPrefix() and log.SetFlags() for Enhanced Log Structure",-1)])]),_:1})])])]),e("li",null,[s(a,{to:"#tips-for-effective-logging-in-go"},{default:t(()=>[...n[11]||(n[11]=[o("Tips for Effective Logging in Go",-1)])]),_:1}),e("ul",null,[e("li",null,[s(a,{to:"#steering-clear-of-log-verbosity"},{default:t(()=>[...n[12]||(n[12]=[o("Steering Clear of Log Verbosity",-1)])]),_:1})]),e("li",null,[s(a,{to:"#logging-with-a-security-lens"},{default:t(()=>[...n[13]||(n[13]=[o("Logging with a Security Lens",-1)])]),_:1})]),e("li",null,[s(a,{to:"#updating-logging-tactics"},{default:t(()=>[...n[14]||(n[14]=[o("Updating Logging Tactics",-1)])]),_:1})])])]),e("li",null,[s(a,{to:"#conclusion"},{default:t(()=>[...n[15]||(n[15]=[o("Conclusion",-1)])]),_:1})])])]),n[16]||(n[16]=e("hr",null,null,-1)),s(c,{name:"Golang logging best practices",desc:"In the vast world of software development, where complexity reigns and the unexpected is the norm, logging emerges as a beacon of clarity. It is through the systematic and thoughtful recording of events, errors, and operations that developers can gain insights into the intricate workings of their applications.",url:"https://gosolve.io/golang-logging-best-practices",logo:"https://gosolve.io/wp-content/uploads/2022/03/cropped-ikona1-192x192.png",preview:"https://gosolve.io/wp-content/uploads/2023/09/Facebook_BLOG_FOTOCOPY-10-1024x1024.png"}),n[17]||(n[17]=h(`<h2 id="enter-golang" tabindex="-1"><a class="header-anchor" href="#enter-golang"><span>Enter Golang</span></a></h2><p>With its growing community and focus on simplicity and efficiency, Go (or Golang as it‚Äôs colloquially known) has surged in popularity since its inception. Originating from Google, Go was designed to handle large-scale applications, which naturally brings the need for effective logging to the forefront. As distributed systems and microservices architectures become more prevalent, logging becomes an even more critical tool in the Go developer‚Äôs arsenal.</p><hr><h2 id="the-dual-role-of-logging-in-go" tabindex="-1"><a class="header-anchor" href="#the-dual-role-of-logging-in-go"><span>The Dual Role of Logging in Go</span></a></h2><p>For Golang, logging plays a dual role. On one hand, it aids developers in diagnosing and understanding the nuances of their code during development and testing. This aspect of logging helps catch errors early, refine performance, and enhance code quality. On the other hand, when applications are deployed in production environments‚Äîwhere real-world usage patterns come into play‚Äîlogging becomes the eyes and ears of developers. It assists in proactive monitoring, swift troubleshooting, and even in forensic investigations after security incidents.</p><hr><h2 id="decoding-logging-levels-in-golang" tabindex="-1"><a class="header-anchor" href="#decoding-logging-levels-in-golang"><span>Decoding Logging Levels in Golang</span></a></h2><h3 id="the-essence-of-logging-levels" tabindex="-1"><a class="header-anchor" href="#the-essence-of-logging-levels"><span>The Essence of Logging Levels</span></a></h3><p>Imagine navigating a dense forest with a map that lacks clear markings. Logging without proper levels is much the same ‚Äî a chaotic jumble that obscures rather than illuminates. Log levels offer a structured hierarchy to messages, enabling developers to filter and focus on the information most pertinent to a specific context. From a minor diagnostic message to a catastrophic system failure, log levels ensure that every event is categorized according to its significance.</p><h3 id="go-s-built-in-logging-nuances" tabindex="-1"><a class="header-anchor" href="#go-s-built-in-logging-nuances"><span>Go‚Äôs Built-in Logging Nuances</span></a></h3><p>It‚Äôs essential to clarify that, by default, Go‚Äôs standard log package doesn‚Äôt provide differentiated log levels like some other logging libraries or frameworks in different languages. Every log is essentially an ‚Äúinfo‚Äù log, with no inherent distinction between a debug message or an error. However, this doesn‚Äôt mean Go developers are left in the dark. The power of Go lies in its expansive ecosystem and the flexibility it provides. There are several third-party logging packages, like logrus, zerolog, and zap, which introduce structured logging, ensuring that Go applications can enjoy the same granular control over logs as any other language.</p><h3 id="understanding-the-landscape-of-logging-levels" tabindex="-1"><a class="header-anchor" href="#understanding-the-landscape-of-logging-levels"><span>Understanding the Landscape of Logging Levels</span></a></h3><p>While different logging packages might have subtle variations, there‚Äôs a general consensus on the primary log levels:</p><p><strong>Debug:</strong> These logs provide detailed insights for developers, tracing the internal flow and variables of the application. They are invaluable during the development phase or when diagnosing specific issues but can be noisy in a production environment.</p><p><strong>Info:</strong> Informational logs capture the standard operations of the system. They confirm that things are working as expected and are especially useful to get a sense of the system‚Äôs pulse during regular operations.</p><p><strong>Warning (or Warn):</strong> As the name suggests, these logs signify that something unusual occurred, but not necessarily an error. For instance, an API taking longer than expected or a temporary resource shortage falls under this level.</p><p><strong>Error:</strong> This level is reserved for serious issues that hinder or halt operations but don‚Äôt crash the application entirely. For instance, a failed database query or an external API being unavailable would typically be logged at this level.</p><p><strong>Fatal:</strong> The most severe of logs, a fatal log signifies a critical error that will stop the program from running further. Post a fatal log, action is typically taken to restart the application or trigger alerts for immediate attention.</p><hr><h2 id="getting-started-with-go-s-built-in-log-package" tabindex="-1"><a class="header-anchor" href="#getting-started-with-go-s-built-in-log-package"><span>Getting Started with Go‚Äôs Built-in log Package</span></a></h2><p>Here‚Äôs a rundown of what the built-in log package brings to the table:</p><ol><li><strong>Standard Logger:</strong> By default, Go provides a standard logger that writes log entries to standard output, such as the terminal. The default logger offers easy initialization and basic logging functionalities.</li><li><strong>Log Flags:</strong> Log flags dictate the prefixed information for every log entry. For instance, including the file name and line number where the log was triggered can be controlled using flags.</li><li><strong>Formatting and Prefixing:</strong> The log package equips developers with tools to format log messages, employing a prefix string or other contextual information. This aids in quickly identifying the origin or context of specific log data.</li><li><strong>Output Destination:</strong> Beyond the standard output, logs can be directed to different destinations, such as log files. This offers flexibility in managing logs, separating concerns, and ensuring seamless integration with monitoring systems.</li></ol><h3 id="a-dive-into-basic-logging-with-go-simple-examples" tabindex="-1"><a class="header-anchor" href="#a-dive-into-basic-logging-with-go-simple-examples"><span>A Dive into Basic Logging with Go: Simple Examples</span></a></h3><p>To harness the power of Go‚Äôs log package, let‚Äôs initiate our journey with the ‚Äúpackage main import‚Äù pattern, a staple in any Go application:</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code class="language-go"><span class="line"><span class="token keyword">package</span> main</span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token string">&quot;log&quot;</span></span>
<span class="line">    <span class="token string">&quot;os&quot;</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Basic logging</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;This is a basic log message.&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// Adjusting log flags to include file name and line number</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">SetFlags</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>LstdFlags <span class="token operator">|</span> log<span class="token punctuation">.</span>Lshortfile<span class="token punctuation">)</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;This log message displays the file and line number.&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// Redirecting logs to a file</span></span>
<span class="line">    file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">&quot;app.log&quot;</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_APPEND<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span></span>
<span class="line">        log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">&quot;Failed to open log file: %v&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">SetOutput</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;This log message goes directly to the log file.&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// Error logging</span></span>
<span class="line">    errorOccurred <span class="token operator">:=</span> <span class="token boolean">true</span></span>
<span class="line">    <span class="token keyword">if</span> errorOccurred <span class="token punctuation">{</span></span>
<span class="line">        log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;An error occurred! Time to investigate.&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the snippet above:</p><ul><li>We commenced by introducing the built-in log package via the package main import pattern.</li><li>Our initial log entry is plain and straightforward.</li><li>We then manipulated log flags to enrich our log entry with the file path and line number.</li><li>To emphasize flexibility, we redirected our logs to a log file.</li><li>Finally, we incorporated a simple error message, simulating a typical error-handling scenario.</li></ul><hr><h2 id="structuring-log-messages-for-clarity" tabindex="-1"><a class="header-anchor" href="#structuring-log-messages-for-clarity"><span>Structuring Log Messages for Clarity</span></a></h2><p>In the vast ecosystem of Golang logging best practices, the art of crafting clear and insightful log messages cannot be overstressed. Traditional logging often results in unstructured data, making logs difficult to analyze, especially when they grow in volume. Here‚Äôs where structured logging, a contemporary logging approach, comes into play. It organizes log data into easily interpretable formats, primarily key-value pairs, paving the way for better analysis and monitoring.</p><p>Structured logging transcends simple text messages by embedding contextual information directly within log entries. By adopting this approach, developers can minimize the time spent deciphering logs and swiftly diagnose issues or monitor performance.</p><h3 id="essential-elements-in-structured-logging-package" tabindex="-1"><a class="header-anchor" href="#essential-elements-in-structured-logging-package"><span>Essential Elements in Structured Logging Package</span></a></h3><p>A well-structured log message should integrate the following components:</p><ol><li><strong>Timestamps:</strong> A marker of when the log entry was generated. Timestamps provide a chronological context, making tracing events or pinpointing anomalies easier.</li><li><strong>Severity Levels:</strong> Logging levels (or log levels) indicate the importance or urgency of a log entry. Common levels include debug, info, warn, and error. By filtering logs based on severity levels, one can focus on logs of a particular importance.</li><li><strong>Module/Package Information:</strong> Specifying the module or package from where the log originates aids in tracing the log‚Äôs source, offering clarity during debugging or when analyzing logs.</li></ol><h3 id="harnessing-log-setprefix-and-log-setflags-for-enhanced-log-structure" tabindex="-1"><a class="header-anchor" href="#harnessing-log-setprefix-and-log-setflags-for-enhanced-log-structure"><span>Harnessing <code>log.SetPrefix()</code> and <code>log.SetFlags()</code> for Enhanced Log Structure</span></a></h3><p>Go‚Äôs built-in log package provides tools that can be utilized to achieve a semblance of structured logging. While it doesn‚Äôt inherently support full-fledged structured logging in formats like JSON, the package offers functions like <code>log.SetPrefix()</code> and <code>log.SetFlags()</code> to imbue structure into log outputs.</p><p>Here‚Äôs a simple example to showcase this:</p><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code class="language-go"><span class="line"><span class="token keyword">package</span> main</span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">(</span></span>
<span class="line">    <span class="token string">&quot;log&quot;</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// Using log.SetPrefix() to specify the module</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">SetPrefix</span><span class="token punctuation">(</span><span class="token string">&quot;MODULE:Auth &quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">// Utilizing log.SetFlags() to include timestamps and file details</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">SetFlags</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span>Ldate <span class="token operator">|</span> log<span class="token punctuation">.</span>Ltime <span class="token operator">|</span> log<span class="token punctuation">.</span>Lshortfile<span class="token punctuation">)</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;User login attempt.&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Error: Invalid password.&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example:</p><ul><li>We employed <code>log.SetPrefix()</code> to denote the module, in this case, ‚ÄúAuth‚Äù, helping identify the section of our application generating the log message.</li><li>With <code>log.SetFlags()</code>, we integrated both timestamps and file details, enriching our log entries with vital contextual information.</li></ul><p>While this approach does infuse structure into the logs, for comprehensive structured logging (especially when you think of outputs like JSON logs), turning to third-party logging packages or structured logging libraries might be more apt. These packages often have built-in support for structured logging, ensuring log messages are clear, consistent, and packed with relevant information.</p><hr><h2 id="tips-for-effective-logging-in-go" tabindex="-1"><a class="header-anchor" href="#tips-for-effective-logging-in-go"><span>Tips for Effective Logging in Go</span></a></h2><h3 id="steering-clear-of-log-verbosity" tabindex="-1"><a class="header-anchor" href="#steering-clear-of-log-verbosity"><span>Steering Clear of Log Verbosity</span></a></h3><p>As developers wade through the waters of Golang logging, one challenge that often surfaces is managing log verbosity. While it‚Äôs tempting to log every minute detail, it‚Äôs essential to remember that not all log messages serve a useful purpose. An excess of log data can, paradoxically, obscure the very issues you‚Äôre attempting to highlight.</p><p>For most production environments, the debug message level might introduce too much noise. Instead, consider employing the debug level during the development or troubleshooting phases. Additionally, tools in various logging packages allow dynamic adjustment of log levels. This feature can be especially handy, enabling developers to increase verbosity when needed and dial it back down post-analysis.</p><h3 id="logging-with-a-security-lens" tabindex="-1"><a class="header-anchor" href="#logging-with-a-security-lens"><span>Logging with a Security Lens</span></a></h3><p>Golang logging isn‚Äôt just about capturing information; it‚Äôs about doing so judiciously. Every log message penned should pass through a security filter. Ask yourself: Does this log entry expose sensitive data?</p><p>Never incorporate personal user data such as passwords, credit card numbers, or user IDs into your log entries. Not only does this pose a substantial security risk, but it can also contravene regulations like the General Data Protection Regulation (GDPR).</p><p>If you must log such information, always obfuscate or anonymize the data. Various logging libraries and third-party packages offer functions that aid in this endeavor, ensuring that sensitive data remains shielded.</p><h3 id="updating-logging-tactics" tabindex="-1"><a class="header-anchor" href="#updating-logging-tactics"><span>Updating Logging Tactics</span></a></h3><p>Just as software applications undergo iterative improvements, so should logging strategies. As applications evolve, the essence of what needs logging and the format log messages take might shift.</p><p>Regularly revisiting and updating logging strategies is paramount. Maybe the initial log files were adequately serving their purpose, but with added modules or functionalities, new log flags or structured logging implementations might be more apt.</p><p>Engage in periodic log reviews. Analyze logs to gauge if they‚Äôre still capturing the crux of application events and if they align with the current objectives. Ensure that the logging package designed for an application‚Äôs earlier version still meets the needs of its latest incarnation.</p><hr><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>The importance of structured logging, ensuring log messages are clear, coherent, and contextually rich, cannot be overemphasized. When equipped with timestamps, severity levels, and module/package info, these log entries transform into invaluable assets. By judiciously using tools from the built-in log package and occasionally roping in third-party logging packages, Go developers can craft logs that are not only informative but also diagnostic.</p><p>Moreover, it‚Äôs imperative to note that the journey of logging doesn‚Äôt culminate once the initial strategies are set and log messages flow through. As our applications mutate, scale, and confront new challenges, so should our approach to logging.</p>`,58)),m(" TODO: add ARTICLE CARD "),s(l,r(g({title:"Golang logging best practices",desc:"In the vast world of software development, where complexity reigns and the unexpected is the norm, logging emerges as a beacon of clarity. It is through the systematic and thoughtful recording of events, errors, and operations that developers can gain insights into the intricate workings of their applications.",link:"https://chanhi2000.github.io/bookshelf/gosolve.io/golang-logging-best-practices.html",logo:"https://gosolve.io/wp-content/uploads/2022/03/cropped-ikona1-192x192.png",background:"rgba(56,119,242,0.2)"})),null,16)])}const T=u(k,[["render",x]]),S=JSON.parse('{"path":"/gosolve.io/golang-logging-best-practices.html","title":"Golang logging best practices","lang":"en-US","frontmatter":{"lang":"en-US","title":"Golang logging best practices","description":"Article(s) > Golang logging best practices","icon":"fa-brands fa-golang","category":["Go","Article(s)"],"tag":["blog","gosolve.io","go","golang"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Golang logging best practices\\",\\"image\\":[\\"https://gosolve.io/wp-content/uploads/2023/09/Facebook_BLOG_FOTOCOPY-10-1024x1024.png\\"],\\"datePublished\\":\\"2023-06-21T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yanick\\",\\"url\\":\\"https://gosolve.io/author/jgadek/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/gosolve.io/golang-logging-best-practices.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Golang logging best practices"}],["meta",{"property":"og:description","content":"Article(s) > Golang logging best practices"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://gosolve.io/wp-content/uploads/2023/09/Facebook_BLOG_FOTOCOPY-10-1024x1024.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://gosolve.io/wp-content/uploads/2023/09/Facebook_BLOG_FOTOCOPY-10-1024x1024.png"}],["meta",{"name":"twitter:image:alt","content":"Golang logging best practices"}],["meta",{"property":"article:author","content":"Yanick"}],["meta",{"property":"article:tag","content":"golang"}],["meta",{"property":"article:tag","content":"go"}],["meta",{"property":"article:tag","content":"gosolve.io"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2023-06-21T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Golang logging best practices"},{"property":"og:description","content":"Golang logging best practices"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/gosolve.io/golang-logging-best-practices.html"}]],"prev":"/programming/go/articles/README.md","date":"2023-06-21T00:00:00.000Z","isOriginal":false,"author":[{"name":"Yanick","url":"https://gosolve.io/author/jgadek/"}],"cover":"https://gosolve.io/wp-content/uploads/2023/09/Facebook_BLOG_FOTOCOPY-10-1024x1024.png"},"git":{},"readingTime":{"minutes":6.8,"words":2040},"filePathRelative":"gosolve.io/golang-logging-best-practices.md","copyright":{"author":"Yanick"}}');export{T as comp,S as data};
