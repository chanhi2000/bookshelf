import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as w,d as n,f as e,b as p,a as A,t as I,n as m,g,w as a,e as i,r as s,o as k}from"./app-BVguHYKu.js";const P={},y={id:"frontmatter-title-관련",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-관련"},x={class:"table-of-contents"},T={href:"https://tauri.app/",target:"_blank",rel:"noopener noreferrer"},z={href:"https://joss.readthedocs.io/en/latest/review_criteria.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://reddit.com/r/singularity/comments/1203xqi/ai_wont_replace_you_but_people_who_are_using_ai/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/jhk0530/showmaker?tab=readme-ov-file#installation",target:"_blank",rel:"noopener noreferrer"};function C(u,t){const d=s("VPCard"),o=s("router-link"),f=s("SiteInfo"),l=s("RouteLink"),r=s("VPIcon");return k(),w("div",null,[n("h1",y,[n("a",b,[n("span",null,I(u.$frontmatter.title)+" 관련",1)])]),e(d,m(g({title:" > Article(s)",desc:"Article(s)",link:"/ai/llm/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",x,[n("ul",null,[n("li",null,[e(o,{to:"#준비-육하원칙으로-가볍게-설계하기"},{default:a(()=>t[0]||(t[0]=[i("준비: 육하원칙으로 가볍게 설계하기")])),_:1,__:[0]}),n("ul",null,[n("li",null,[e(o,{to:"#누가"},{default:a(()=>t[1]||(t[1]=[i("누가")])),_:1,__:[1]})]),n("li",null,[e(o,{to:"#언제"},{default:a(()=>t[2]||(t[2]=[i("언제")])),_:1,__:[2]})]),n("li",null,[e(o,{to:"#어디서"},{default:a(()=>t[3]||(t[3]=[i("어디서")])),_:1,__:[3]})]),n("li",null,[e(o,{to:"#왜"},{default:a(()=>t[4]||(t[4]=[i("왜")])),_:1,__:[4]})]),n("li",null,[e(o,{to:"#무엇을"},{default:a(()=>t[5]||(t[5]=[i("무엇을")])),_:1,__:[5]})]),n("li",null,[e(o,{to:"#어떻게"},{default:a(()=>t[6]||(t[6]=[i("어떻게")])),_:1,__:[6]})])])]),n("li",null,[e(o,{to:"#바이브-코딩-ai와-함께한-개발-과정"},{default:a(()=>t[7]||(t[7]=[i("바이브 코딩: AI와 함께한 개발 과정")])),_:1,__:[7]}),n("ul",null,[n("li",null,[e(o,{to:"#ai만으로는-부족할-때-search가-필요하다"},{default:a(()=>t[8]||(t[8]=[i("AI만으로는 부족할 때, Search가 필요하다")])),_:1,__:[8]})]),n("li",null,[e(o,{to:"#ui-추가와-반복적인-수정"},{default:a(()=>t[9]||(t[9]=[i("UI 추가와 반복적인 수정")])),_:1,__:[9]})]),n("li",null,[e(o,{to:"#빌드와-배포-누구나-실행할-수-있게-만들기"},{default:a(()=>t[10]||(t[10]=[i("빌드와 배포: 누구나 실행할 수 있게 만들기")])),_:1,__:[10]})]),n("li",null,[e(o,{to:"#바이브-코드-리뷰"},{default:a(()=>t[11]||(t[11]=[i("바이브 코드 리뷰")])),_:1,__:[11]})]),n("li",null,[e(o,{to:"#오픈소스-리뷰-기준-참고하기"},{default:a(()=>t[12]||(t[12]=[i("오픈소스 리뷰 기준 참고하기")])),_:1,__:[12]})])])]),n("li",null,[e(o,{to:"#바이브-코딩의-한계-어디까지-믿을-수-있을까"},{default:a(()=>t[13]||(t[13]=[i("바이브 코딩의 한계: 어디까지 믿을 수 있을까")])),_:1,__:[13]})]),n("li",null,[e(o,{to:"#프로젝트-회고와-정리"},{default:a(()=>t[14]||(t[14]=[i("프로젝트 회고와 정리")])),_:1,__:[14]}),n("ul",null,[n("li",null,[e(o,{to:"#_1-사이드-프로젝트는-아이디어가-전부다"},{default:a(()=>t[15]||(t[15]=[i("1. 사이드 프로젝트는 아이디어가 전부다")])),_:1,__:[15]})]),n("li",null,[e(o,{to:"#_2-바이브-코딩의-장점과-한계"},{default:a(()=>t[16]||(t[16]=[i("2. 바이브 코딩의 장점과 한계")])),_:1,__:[16]})])])]),n("li",null,[e(o,{to:"#부록-쇼메이커-사용법"},{default:a(()=>t[17]||(t[17]=[i("부록: 쇼메이커 사용법")])),_:1,__:[17]}),n("ul",null,[n("li",null,[e(o,{to:"#_1-ai로-슬라이드-초안-만들기"},{default:a(()=>t[18]||(t[18]=[i("1. AI로 슬라이드 초안 만들기")])),_:1,__:[18]})]),n("li",null,[e(o,{to:"#_2-쇼메이커-실행하기"},{default:a(()=>t[19]||(t[19]=[i("2. 쇼메이커 실행하기")])),_:1,__:[19]})]),n("li",null,[e(o,{to:"#_3-파일-업로드-및-변환"},{default:a(()=>t[20]||(t[20]=[i("3. 파일 업로드 및 변환")])),_:1,__:[20]})])])])])]),t[49]||(t[49]=n("hr",null,null,-1)),e(f,{name:"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다",desc:"발표 자료를 만들 때 가장 번거로운 일 중 하나는 PPT 제작입니다. 자료를 조사하고 내용을 채우고, 디자인까지 맞추는 과정은 손이 많이 가지만, 정작 발표의 본질과는 거리가 있습니다. 애써 만들어도 티가 잘 나지 않는데, 엉성하면 금세 드러나는 계륵 같은 작업이죠. 이에 저는 AI에 추가 지식과 컨텍스트를 직접 제공하고, 결과물만 변환한다는 방향을 세운 후 'AI PPT 도구 사이드 프로젝트'를 시작했습니다. 이번 글에서는 제가 이 도구를 어떻게 기획하고, AI와 함께 ‘바이브 코딩’ 방식으로 구현했는지 그 과정을 공유하고자 합니다.",url:"https://yozm.wishket.com/magazine/detail/3356/",logo:"https://yozm.wishket.com/favicon.ico",preview:"https://yozm.wishket.com/media/news/3356/tum.png"}),t[50]||(t[50]=n("p",null,"발표 자료를 만들 때 가장 번거로운 일 중 하나는 PPT 제작입니다. 자료를 조사하고 내용을 채우고, 디자인까지 맞추는 과정은 손이 많이 가지만, 정작 발표의 본질과는 거리가 있습니다. 애써 만들어도 티가 잘 나지 않는데, 엉성하면 금세 드러나는 계륵 같은 작업이죠.",-1)),n("p",null,[t[24]||(t[24]=i("다행히 최근에는 이 과정을 줄여주는 ")),e(l,{to:"/yozm.wishket.com/2494.html"},{default:a(()=>t[21]||(t[21]=[n("strong",null,"감마(Gamma)",-1)])),_:1,__:[21]}),t[25]||(t[25]=i(", ")),e(l,{to:"/yozm.wishket.com/3301.html"},{default:a(()=>t[22]||(t[22]=[n("strong",null,"젠스파크(Genspark)",-1)])),_:1,__:[22]}),t[26]||(t[26]=i(", ")),e(l,{to:"/yozm.wishket.com/3315.html"},{default:a(()=>t[23]||(t[23]=[n("strong",null,"냅킨 AI(Napkin AI)",-1)])),_:1,__:[23]}),t[27]||(t[27]=i(" 등의 다양한 AI 서비스가 등장했고, 요즘IT에도 소개된 적이 있죠. 이들은 AI의 방대한 패턴 학습과 자동화를 기반으로 사용자의 생산성을 크게 높여줍니다. 특히 반복적이고 형식화된 작업인 PPT 제작에는 아주 탁월한 성능을 보입니다."))]),t[51]||(t[51]=n("p",null,"그런데 이 서비스들을 막상 써보면 아쉬움이 없지는 않습니다. 무료로 쓰기에는 제약이 많고, 세부적인 커스터마이즈가 어렵습니다. 유료로 쓰자니 또 새로운 AI 월세를 낼 생각에 아찔해지기도 합니다. 그래서 “PPT 구성에 AI를 직접 활용하면 비용 없이도 비슷한 결과를 만들 수 있지 않을까?”라는 생각이 들었죠.",-1)),t[52]||(t[52]=n("figure",null,[n("img",{src:"https://wishket.com/media/news/3356/1.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1)),n("p",null,[t[29]||(t[29]=i("저는 AI에 추가 지식과 컨텍스트를 직접 제공하고, 결과물만 변환한다는 방향을 세운 후 사이드 프로젝트를 시작했습니다. AI가 만들어낸 마크다운 텍스트를 ")),e(l,{to:"/yozm.wishket.com/1883.html"},{default:a(()=>t[28]||(t[28]=[n("strong",null,"Quarto",-1)])),_:1,__:[28]}),t[30]||(t[30]=i("로 변환해, PPT로 만들어주는 도구로 말이죠. 이름하여 ‘Showmaker’입니다."))]),t[53]||(t[53]=p('<p>물론 이 방법에도 문제가 있었습니다. Quarto 같은 툴은 무료라는 장점이 있지만, 처음 접하는 사람에겐 꽤 불편합니다. 우리가 흔히 쓰는 프로그램처럼 실행하는 방식이 아니라, 검은 화면(터미널)이나 개발용 프로그램(IDE)에서 명령어를 입력해야 하기 때문이죠. 기술에 익숙하지 않다면 시작부터 막힐 수 있습니다.</p><p>이쯤에서 ‘아무리 좋은 도구라도 쓰는 방법이 어렵다면 활용도는 떨어질 수밖에 없다’는 생각이 들었습니다. 그렇다면 답은 하나였습니다. Quarto를 기반으로, 클릭 몇 번만으로 사용할 수 있는 GUI 프로그램을 직접 만드는 것이었죠. AI가 텍스트를 생성하고, Quarto가 이를 PPT로 변환하며, 사용자는 일반 프로그램처럼 버튼만 누르면 결과를 얻을 수 있는 구조였죠. 이러면 비용 부담 없이 누구나 손쉽게 AI로 PPT를 만들 수 있을 거라 생각했습니다.</p><p>이번 글에서는 제가 이 도구를 어떻게 기획하고, AI와 함께 ‘바이브 코딩’ 방식으로 구현했는지 그 과정을 공유하고자 합니다.</p><hr><h2 id="준비-육하원칙으로-가볍게-설계하기" tabindex="-1"><a class="header-anchor" href="#준비-육하원칙으로-가볍게-설계하기"><span>준비: 육하원칙으로 가볍게 설계하기</span></a></h2><p>제가 그동안 경험한 바에 따르면, 성공적인 바이브 코딩의 흐름은 다음과 같은 단계로 구성됩니다.</p><figure><img src="https://wishket.com/media/news/3356/4.png" alt="바이브 코딩의 흐름" tabindex="0" loading="lazy"><figcaption>바이브 코딩의 흐름</figcaption></figure><p>먼저 어떤 것을 만들지 기획(Plan)해 보겠습니다. 사이드 프로젝트를 시작할 때는 보통 거창한 기획서를 쓰진 않습니다. 대신 일반적인 육하원칙과는 조금 다르지만, 구조를 참고하여 아주 간단하게 정리해 둡니다.</p><h3 id="누가" tabindex="-1"><a class="header-anchor" href="#누가"><span>누가</span></a></h3><p>나와 AI. 글쓰기는 ChatGPT, 코딩은 코파일럿, 이미지 생성은 제미나이처럼 각자의 특기를 살려 역할을 분담했습니다. 만약 프로젝트에 여러 사람이 참여한다면, 각 사람이 어느 범위만큼의 작업을 할지 R&amp;R을 명확하게 구분할 필요가 있습니다.</p><h3 id="언제" tabindex="-1"><a class="header-anchor" href="#언제"><span>언제</span></a></h3><p>‘언제 시작할까?’보다는 ‘언제 끝낼까?’를 정했습니다. 사이드 프로젝트는 아이디어가 자꾸 커지기 때문에, 처음 목표로 했던 최소기능(MVP)을 달성할 때까지만 작업하겠다고 선을 그었습니다. 종료 기간은 이처럼 기능 단위으로 설정해도 되고, 연휴 같은 시간 단위로 정할 수도 있습니다.</p><h3 id="어디서" tabindex="-1"><a class="header-anchor" href="#어디서"><span>어디서</span></a></h3><p>코딩 작업인 만큼 장소는 크게 중요하지 않았습니다. 대신 결과물을 어디서 만들고, 어디에 배포할지를 고민했습니다. 저는 VS code를 사용하고, 깃허브의 Release를 활용해 누구나 무료로 내려받을 수 있도록 했습니다.</p><h3 id="왜" tabindex="-1"><a class="header-anchor" href="#왜"><span>왜</span></a></h3><p>동기는 단순했습니다. “비용을 들이지 않고, AI로 슬라이드를 만들 수 있지 않을까?” 짧지만 프로젝트 기획에서 가장 중요한 부분이라고 생각합니다.</p><h3 id="무엇을" tabindex="-1"><a class="header-anchor" href="#무엇을"><span>무엇을</span></a></h3><p>앞선 왜와 이어지는 항목입니다. AI가 만든 마크다운 텍스트를 Quarto로 변환해 PPT를 만드는 GUI 프로그램을 만들 것이고, 추가로 어떤 것을 할지 뿐만 아니라, 어떤 것을 하지 않을지 정하는 것도 중요합니다.</p><h3 id="어떻게" tabindex="-1"><a class="header-anchor" href="#어떻게"><span>어떻게</span></a></h3>',19)),n("p",null,[t[32]||(t[32]=i("Quarto를 GUI 프로그램으로 만들기 위해서 저는 자바스크립트(Javascript)와 러스트(Rust)를 사용하는 ")),n("a",T,[e(r,{icon:"iconfont icon-tauri"}),t[31]||(t[31]=i("타우리 (Tauri)"))]),t[33]||(t[33]=i("라는 프레임워크를 선택했습니다. 비슷한 역할을 하는 일렉트론(Electron)보다 가볍고 빨라, 이번 프로젝트와 잘 맞는다고 생각했습니다."))]),t[54]||(t[54]=p('<p>이렇게 육하원칙으로 정리해 두니, 프로젝트의 방향을 잡는 데 큰 도움이 됐습니다. 아이디어가 중간에 새로 떠올라도, 처음 정한 기준 덕분에 길을 잃지 않았습니다.</p><figure><img src="https://wishket.com/media/news/3356/5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>물론 이런 기획 작업도 AI에 맡길 수 있습니다. 하지만 저는 아이디어를 구체화하는 부분은 사람이 직접 하는 게 낫다고 생각합니다. 프로그램의 방향을 결정하는 건 결국 사람의 상상력과 필요에서 나오니까요. 대신 정리한 내용을 문서로 작성해 두고, 이를 AI에게 피드백용으로 제공하는 방식은 효과적이었습니다. 예를 들어, 저는 spec.md 같은 파일에 이번 프로젝트의 목적, 목표, 제약사항을 간단히 적어 두었습니다.</p><p>이런 문서를 AI에게 추가 컨텍스트로 제공하면, 같은 질문을 하더라도 훨씬 목적에 맞는 답변을 얻을 수 있습니다. 필수 단계는 아니지만, 겸사겸사 정리해 두면 프로젝트 진행이 한결 매끄러워지죠.</p><p>이제 기획 이후의 단계는 실질적인 바이브 코딩 단계로, 프롬프트를 넣고 원하는 결과가 나올 때까지 수정하는 과정의 반복입니다.</p><hr><h2 id="바이브-코딩-ai와-함께한-개발-과정" tabindex="-1"><a class="header-anchor" href="#바이브-코딩-ai와-함께한-개발-과정"><span>바이브 코딩: AI와 함께한 개발 과정</span></a></h2><p>본격적인 개발은 깃허브 코파일럿과 함께 시작했습니다. 저는 주로 GPT-4.1 모델과 Ask 모드를 썼습니다. Agent 모드는 AI가 코드를 알아서 수정, 생성해 주는 방식인데요. AI가 잘못된 결정을 진행해 버리면 되돌리기 어렵기 때문입니다. 실제로 다른 프로젝트에서 Agent 모드를 사용하다가, 엉뚱한 수정 때문에 AI가 스스로 전체 코드를 날려버린 적도 종종 있는데요. 가능하면 사용자가 직접 결정을 내리는 Ask 모드로 진행하는 걸 추천합니다.</p><figure><img src="https://wishket.com/media/news/3356/6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>개발 과정은 단순히 설명하면, <strong>AI에 프롬프트 전달 - AI가 코드 생성 - (검토 및 코드 수정) - 프로그램 실행 - 오류 수정의 반복</strong>으로 사실 전통적인 코딩 방식과 크게 다르지 않습니다. 유의미한 차이가 있다면, 에러 로그를 구글에서 검색하는 대신 AI에게 물어본다는 점 정도입니다.</p><figure><img src="https://wishket.com/media/news/3356/7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="ai만으로는-부족할-때-search가-필요하다" tabindex="-1"><a class="header-anchor" href="#ai만으로는-부족할-때-search가-필요하다"><span>AI만으로는 부족할 때, Search가 필요하다</span></a></h3><p>위에서 본 바이브 코딩 흐름에서 제가 특히 강조하고 싶은 부분은 ‘Search’입니다. 즉, AI만 믿고 문제를 해결하려 하기보다는, 상황에 따라 직접 문제를 검색해서 답을 찾는 게 훨씬 빠르고 확실했습니다. 예를 들어, AI가 제시하는 방법을 따라가다 보면, 최신 버전과 맞지 않는 코드를 알려주는 경우가 있습니다.</p><figure><img src="https://wishket.com/media/news/3356/8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>실제로 Tauri에서 저장 기능을 구현할 때도, AI가 업데이트 이전 버전의 코드 사용 방식을 제안해서 문제가 생겼습니다. 이런 상황에서는 최신 공식 문서를 직접 찾아보고, 거기서 얻은 내용을 다시 AI에게 알려주는 방식이 훨씬 효과적이었습니다. AI의 한계를 이해하고 사람의 검색과 판단을 적절히 섞으면, 바이브 코딩의 생산성을 더 향상시킬 수 있죠.</p><figure><img src="https://wishket.com/media/news/3356/9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="ui-추가와-반복적인-수정" tabindex="-1"><a class="header-anchor" href="#ui-추가와-반복적인-수정"><span>UI 추가와 반복적인 수정</span></a></h3><p>저장 기능 문제를 해결하는 것 외에도, 프로그램에 실제 사용자가 쓸 수 있는 UI를 구현하는 과정도 바이브 코딩으로 해결할 수 있었습니다. 마크다운 파일을 업로드할 수 있는 창, 변환을 실행하는 버튼 같은 기본 기능이었지만, AI가 작성한 코드는 처음부터 매끄럽지는 않고, 버튼 위치가 틀어지거나 레이아웃이 깨지는 일이 종종 발생합니다. 그래서 결국은 다시 AI 코드 제안 - 실행 - 깨짐 확인 - 수정의 과정을 여러 번 반복해야 했죠. 이 과정이 번거로웠지만, 사이드 프로젝트에서는 빠르게 실행 화면을 보는 게 큰 동기부여가 되기도 합니다.</p><p>여러 차례 수정을 거친 끝에, 드디어 실행되는 프로그램 화면을 볼 수 있었습니다. 하지만 이 단계의 프로그램은 여전히 개발 환경 안에서만 돌아갔는데요. VS Code에서 tauri dev라는 명령어를 실행해야 했고, 개발 중인 PC에서는 구동됐지만, 다른 사람이 파일을 받아 더블클릭만으로 실행할 수 있는 수준은 아니었습니다.</p><figure><img src="https://wishket.com/media/news/3356/10-side.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이제 VS Code의 실행과 관계없이, 독립적으로 실행할 수 있는 프로그램으로 만드는 ‘빌드’ 작업이 필요합니다.</p><h3 id="빌드와-배포-누구나-실행할-수-있게-만들기" tabindex="-1"><a class="header-anchor" href="#빌드와-배포-누구나-실행할-수-있게-만들기"><span>빌드와 배포: 누구나 실행할 수 있게 만들기</span></a></h3><p>이 프로그램은 저의 맥OS PC뿐만 아니라, 많은 사용자를 가지고 있는 윈도우 환경에서도 실행할 수 있도록 빌드해야 합니다. 이를 위해 AI에 윈도우에서의 빌드 방법을 물어보고, 윈도우 PC에서 이후 단계를 진행했습니다. 그 결과 맥OS에서는 프로그램을 설치할 수 있는 dmg, 윈도우에서는 msi 파일을 생성할 수 있었습니다.</p><figure><img src="https://wishket.com/media/news/3356/12.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이 ‘exe’ 설치 파일들을 AI의 가이드를 참고해 깃허브 릴리즈 페이지에 업로드하면, 프로젝트의 1차 목표는 달성됩니다.</p><h3 id="바이브-코드-리뷰" tabindex="-1"><a class="header-anchor" href="#바이브-코드-리뷰"><span>바이브 코드 리뷰</span></a></h3>',26)),n("p",null,[t[35]||(t[35]=i("기본 기능이 동작하는 프로그램을 만든 뒤에는, 유지보수를 염두에 두고 AI로 코드 리뷰를 진행해 보려 합니다. 코드 품질을 조금 더 높이려는 시도인데요. 이는 VS Code에서 단순히 ‘코드를 리뷰해 줘’라는 프롬프트를 사용하는 것보다 깃허브에 풀 리퀘스트를 작성하고, ")),e(l,{to:"/yozm.wishket.com/3304.html"},{default:a(()=>t[34]||(t[34]=[n("strong",null,"제미나이 코드 어시스트",-1)])),_:1,__:[34]}),t[36]||(t[36]=i(" 같은 별도 서비스를 활용하는 것도 좋습니다."))]),t[55]||(t[55]=n("figure",null,[n("img",{src:"https://wishket.com/media/news/3356/14.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1)),t[56]||(t[56]=n("p",null,"AI가 제안하는 코드 리뷰는 대체로 참고할 만한 개선점을 담고 있지만, 모든 제안이 꼭 필요한 수정은 아닙니다. 따라서 비판적인 시각을 유지하며, 사람이 다시 한번 검토하는 과정이 필요합니다.",-1)),t[57]||(t[57]=n("h3",{id:"오픈소스-리뷰-기준-참고하기",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#오픈소스-리뷰-기준-참고하기"},[n("span",null,"오픈소스 리뷰 기준 참고하기")])],-1)),t[58]||(t[58]=n("p",null,"코드 단위의 품질을 넘어, 프로그램 단위의 품질 향상을 위해 또 하나 참고한 기준은 ‘오픈소스 소프트웨어 저널(Journal of Open Source Software, JOSS)’의 리뷰 기준입니다. 이는 연구 목적의 소프트웨어를 평가하는 기준이지만, 사이드 프로젝트에도 상당히 유용합니다.",-1)),n("p",null,[t[38]||(t[38]=i("JOSS의 ")),n("a",z,[e(r,{icon:"fas fa-globe"}),t[37]||(t[37]=i("리뷰 기준 문서"))]),t[39]||(t[39]=i("에는 ‘좋은 오픈 소스 소프트웨어’를 목적으로 하는 몇가지 조건이 제시되어 있는데요. 연구 목적이 아니더라도 ‘다른 사람이 쉽게 사용할 수 있는 소프트웨어’를 만드는 데 참고할 만한 내용이 많아, 원문을 읽어보는 걸 권장합니다."))]),t[59]||(t[59]=p('<ul><li>소프트웨어의 필요성 명시</li><li>자동화된 절차를 통한 설치 안내</li><li>문제 해결을 위한 사용법 예제</li><li>핵심 기능에 대한 충분한 설명</li><li>커뮤니티 가이드라인 명시</li></ul><p>당연히 이 기준을 AI에 전달하면, 프로젝트에 필요한 작업을 제안받는 ‘바이브-QA’ 방식으로도 활용할 수 있습니다.</p><figure><img src="https://wishket.com/media/news/3356/15.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="바이브-코딩의-한계-어디까지-믿을-수-있을까" tabindex="-1"><a class="header-anchor" href="#바이브-코딩의-한계-어디까지-믿을-수-있을까"><span>바이브 코딩의 한계: 어디까지 믿을 수 있을까</span></a></h2><p>지금까지 바이브 코딩의 과정과 장점을 살펴봤으니, 이번엔 회고를 통해 바이브 코딩의 한계점을 짚어보겠습니다.</p><p>먼저 첫 번째 한계는 예시 이미지에서도 볼 수 있듯, 글 작성은 ChatGPT, 코드 보조는 Copilot, 이미지 생성은 제미나이를 사용하는 식으로 상황마다 다른 AI를 활용했습니다. 이는 한 가지 툴만으로는 아쉬운 점이 있었기 때문입니다. 물론 프롬프트를 매우 능숙하게 다룬다면 하나의 AI 서비스로도 충분할 수 있겠지만, 그렇지 않다면 ‘어떤 AI가 이 작업에 더 적합한가’를 판단하는 안목이 필요합니다.</p><p>두 번째 한계는, 중간에 동일한 에러를 세 번 묻는 이미지에서도 드러납니다. AI에게 모든 작업을 전적으로 맡기는 것은 꽤 위험합니다. AI는 자신 있게 틀린 답을 내놓을 때가 있으며, 여러 사례에서 언급되듯 아직은 사람을 온전히 대체할 만큼의 성능은 아닙니다. 특히 단순한 작업이 아니라면 더욱 그렇습니다.</p><p>AI의 역할은 어디까지나 ‘보조’일 때 효과적입니다. 보조란 사람이 이미 작업에 필요한 지식을 갖추고 있어, AI가 실수를 하더라도 이를 파악하고 바로잡을 수 있는 상태를 의미합니다. 만약 결과의 정확성을 검증할 수 없다면, 결국 또 다른 AI가 에이전트 방식으로 AI에게 작업을 요청하는 것과 크게 다르지 않다고 볼 수 있습니다.</p>',9)),n("figure",null,[t[43]||(t[43]=n("img",{src:"https://wishket.com/media/news/3356/16.jpg",alt:'출처: 레딧, <VPIcon icon="fa-brands fa-reddit"/>',tabindex:"0",loading:"lazy"},null,-1)),n("figcaption",null,[t[42]||(t[42]=i("출처: ")),n("a",S,[t[40]||(t[40]=i("레딧, ")),e(r,{icon:"fa-brands fa-reddit"}),t[41]||(t[41]=n("code",null,"r/singularity",-1))])])]),t[60]||(t[60]=p('<p>마지막 한계는 바이브 코딩이 아직 기획 단계에서는 뛰어난 성과를 내지 못한다는 점입니다. 예를 들어, ‘어떤 사이드 프로젝트를 해볼까?’, ‘어떤 프로그램을 만들어볼 수 있을까?’와 같은 프롬프트에 대해서는 창의적인 아이디어보다는 투두 리스트처럼 완성과 성공을 목적으로 한 연습용 주제를 제안하는 경우가 많습니다.</p><p>앞서 기획 과정에서도 AI를 굳이 사용하지 않은 이유가 있습니다. 기대했던 pandoc이나 Quarto 같은 변환 방식 대신, 수동 복사·붙여넣기나 개요 기능을 활용한 자동 슬라이드 생성 같은 방법만 제안했기 때문입니다. 결국 AI가 내놓는 결과물은 바이브 코딩을 시도하는 사람의 상상력에 크게 의존한다고 볼 수 있습니다. 즉, 제 생각에 AI는 0에서 1을 만드는 아이디어에는 아직 약하지만, 이미 존재하는 아이디어를 10이나 100으로 확장하는 데는 강점을 보입니다.</p><p>정리하면, 바이브 코딩은 사용자의 상상력과 프롬프트 엔지니어링, 그리고 기존 역량에 비례해 ‘빠른 완성’과 ‘유연한 확장’을 가능하게 합니다. 하지만 프로젝트의 맥락과 깊은 이해가 없다면, 장기적인 유지보수에는 한계가 있어 아직 개발자를 완전히 대체하기는 어렵습니다.</p><hr><h2 id="프로젝트-회고와-정리" tabindex="-1"><a class="header-anchor" href="#프로젝트-회고와-정리"><span>프로젝트 회고와 정리</span></a></h2><p>돌이켜보면 이번 프로젝트는 거창한 목표에서 출발한 것이 아니었습니다. 단순히 ‘비용을 들이지 않고도 AI로 PPT를 만들 수 있지 않을까?’라는 작은 질문에서 시작했죠. 하지만 몇 시간의 작업 끝에 실제로 다른 사람이 사용할 수 있는 프로그램을 완성했고, 그 과정에서 많은 것을 배울 수 있었습니다.</p><h3 id="_1-사이드-프로젝트는-아이디어가-전부다" tabindex="-1"><a class="header-anchor" href="#_1-사이드-프로젝트는-아이디어가-전부다"><span>1. 사이드 프로젝트는 아이디어가 전부다</span></a></h3><p>사이드 프로젝트에서 중요한 것은 규모나 완성도가 아닙니다. 핵심은 아이디어를 빠르게 실험하고, ‘작동하는 무언가’를 만들어내는 데 있습니다. 이번처럼 직접 겪은 불편함을 해결하려는 주제라면(도그푸딩), 동기부여가 더욱 강해지고 끝까지 밀고 나갈 힘도 생깁니다.</p><h3 id="_2-바이브-코딩의-장점과-한계" tabindex="-1"><a class="header-anchor" href="#_2-바이브-코딩의-장점과-한계"><span>2. 바이브 코딩의 장점과 한계</span></a></h3><p>바이브 코딩은 무엇보다 빠른 성취감을 줍니다. AI와 함께라면 0에서 시작해도 금세 눈에 보이는 결과를 만들 수 있죠. 또 아이디어를 확장해가며 유연하게 발전시킬 수 있다는 점도 매력적이었습니다.</p><p>하지만 동시에 한계도 분명했습니다. AI가 제안하는 코드가 최신 문법과 다르거나 같은 에러를 반복하는 경우가 많았고, 결국 사람이 기본적인 원리를 알고 있어야 문제를 걸러내고 해결할 수 있었습니다. 장기적인 유지보수까지 맡기기에는 아직 무리가 있다는 점도 이번에 확실히 느꼈습니다.</p><p>이렇게 만든 ‘쇼메이커(Showmaker)’는 이미 제가 원했던 목적, 즉 AI로 만든 마크다운을 손쉽게 PPT로 변환하는 기능을 달성했습니다. 깃허브에 공개한 뒤 예상보다 많은 분들이 관심을 주셨죠. 무엇보다 처음 목표대로 개발과 비용을 크게 고려하지 않고도, 실제로 PPT로 변환해 활용하는 사례를 확인할 수 있었습니다.</p><hr><h2 id="부록-쇼메이커-사용법" tabindex="-1"><a class="header-anchor" href="#부록-쇼메이커-사용법"><span>부록: 쇼메이커 사용법</span></a></h2><p>마지막으로 완성된 쇼메이커의 사용 방법을 간단히 정리해 보겠습니다. 이번 글은 사이드 프로젝트 경험담이기도 하지만, 실제 사용 흐름을 함께 살펴보면 더 쉽게 이해할 수 있을 겁니다.</p><h3 id="_1-ai로-슬라이드-초안-만들기" tabindex="-1"><a class="header-anchor" href="#_1-ai로-슬라이드-초안-만들기"><span>1. AI로 슬라이드 초안 만들기</span></a></h3><p>AI를 활용해 마크다운 형식으로 슬라이드 내용을 구성합니다. 이때 아래와 같은 프롬프트 템플릿을 활용하면, AI가 목차와 내용을 담은 마크다운 파일(slides.md)을 생성해 줍니다.</p><figure><img src="https://wishket.com/media/news/3356/17.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-쇼메이커-실행하기" tabindex="-1"><a class="header-anchor" href="#_2-쇼메이커-실행하기"><span>2. 쇼메이커 실행하기</span></a></h3>',19)),n("p",null,[t[47]||(t[47]=i("쇼메이커 프로그램을 ")),n("a",_,[t[44]||(t[44]=i("다운로드 (")),e(r,{icon:"iconfont icon-github"}),t[45]||(t[45]=n("code",null,"jhk0530/showmaker",-1)),t[46]||(t[46]=i(")"))]),t[48]||(t[48]=i("하여 설치, 실행합니다."))]),t[61]||(t[61]=n("h3",{id:"_3-파일-업로드-및-변환",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_3-파일-업로드-및-변환"},[n("span",null,"3. 파일 업로드 및 변환")])],-1)),t[62]||(t[62]=n("p",null,"프로그램을 실행한 다음, 1단계에서 AI가 만든 마크다운 파일을 업로드하면 Quarto가 이를 PPT로 변환합니다.",-1)),t[63]||(t[63]=n("figure",null,[n("img",{src:"https://wishket.com/media/news/3356/18.png",alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1)),t[64]||(t[64]=n("p",null,"예를 들어, ‘영상처리 개념을 강의용 슬라이드로 구성해줘’라고 요청하면 아래 같은 마크다운 파일을 생성할 수 있습니다.",-1)),t[65]||(t[65]=n("figure",null,[n("img",{src:"https://wishket.com/media/news/3356/19-side.png",alt:"마크다운 파일 생성(왼), 만들어진 PPT 초안(오)",tabindex:"0",loading:"lazy"}),n("figcaption",null,"마크다운 파일 생성(왼), 만들어진 PPT 초안(오)")],-1)),t[66]||(t[66]=n("p",null,"이후 과정을 거치면, 몇 분 만에 AI가 만든 초안이 실제 PPT 파일로 완성되는 경험을 할 수 있습니다. 물론 이후 디자인을 다듬거나 이미지를 추가하는 작업은 사용자의 몫이지만, 가장 번거로운 초안 작성 과정을 훨씬 가볍게 만들 수 있다는 점이 큰 장점입니다.",-1)),t[67]||(t[67]=n("p",null,"이번 경험을 통해 완벽하진 않지만, 바이브 코딩의 충분한 가능성을 확인할 수 있었는데요. 무엇보다 혼자였다면 망설였을 프로젝트도, 끝까지 이어갈 수 있다는 자신감을 얻었습니다. 여러분도 지금 불편하다고 느끼는 점이 있거나, 해보고 싶은 프로젝트가 있다면 바이브 코딩으로 가볍게 시작해 보시는 건 어떨까요?",-1)),A(" TODO: add ARTICLE CARD "),e(d,m(g({title:"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다",desc:"발표 자료를 만들 때 가장 번거로운 일 중 하나는 PPT 제작입니다. 자료를 조사하고 내용을 채우고, 디자인까지 맞추는 과정은 손이 많이 가지만, 정작 발표의 본질과는 거리가 있습니다. 애써 만들어도 티가 잘 나지 않는데, 엉성하면 금세 드러나는 계륵 같은 작업이죠. 이에 저는 AI에 추가 지식과 컨텍스트를 직접 제공하고, 결과물만 변환한다는 방향을 세운 후 'AI PPT 도구 사이드 프로젝트'를 시작했습니다. 이번 글에서는 제가 이 도구를 어떻게 기획하고, AI와 함께 ‘바이브 코딩’ 방식으로 구현했는지 그 과정을 공유하고자 합니다.",link:"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3356.html",logo:"https://yozm.wishket.com/favicon.ico",background:"rgba(84,7,224,0.2)"})),null,16)])}const V=h(P,[["render",C]]),O=JSON.parse('{"path":"/yozm.wishket.com/3356.html","title":"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다","description":"Article(s) > 바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다","icon":"fas fa-language","category":["AI","LLM","Article(s)"],"tag":["blog","yozm.wishket.com","ai","artificial-intelligence","llm","large-language-models"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다\\",\\"image\\":[\\"https://wishket.com/media/news/3356/1.png\\",\\"https://wishket.com/media/news/3356/4.png\\",\\"https://wishket.com/media/news/3356/5.png\\",\\"https://wishket.com/media/news/3356/6.png\\",\\"https://wishket.com/media/news/3356/7.png\\",\\"https://wishket.com/media/news/3356/8.png\\",\\"https://wishket.com/media/news/3356/9.png\\",\\"https://wishket.com/media/news/3356/10-side.png\\",\\"https://wishket.com/media/news/3356/12.png\\",\\"https://wishket.com/media/news/3356/14.png\\",\\"https://wishket.com/media/news/3356/15.png\\",\\"https://reddit.com/r/singularity/comments/1203xqi/ai_wont_replace_you_but_people_who_are_using_ai/\\",\\"https://wishket.com/media/news/3356/17.png\\",\\"https://wishket.com/media/news/3356/18.png\\",\\"https://wishket.com/media/news/3356/19-side.png\\"],\\"datePublished\\":\\"2025-09-19T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"애옹킴\\",\\"url\\":\\"https://yozm.wishket.com/magazine/@jhk0530/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3356.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다"}],["meta",{"property":"og:description","content":"Article(s) > 바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yozm.wishket.com/media/news/3356/tum.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://yozm.wishket.com/media/news/3356/tum.png"}],["meta",{"name":"twitter:image:alt","content":"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다"}],["meta",{"property":"article:author","content":"애옹킴"}],["meta",{"property":"article:tag","content":"large-language-models"}],["meta",{"property":"article:tag","content":"llm"}],["meta",{"property":"article:tag","content":"artificial-intelligence"}],["meta",{"property":"article:tag","content":"ai"}],["meta",{"property":"article:tag","content":"yozm.wishket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-09-19T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > 바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다"},{"property":"og:description","content":"바이브 코딩으로 ‘AI PPT 툴’ 만들어봤습니다"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3356.html"}]],"prev":"/ai/llm/articles/README.md","date":"2025-09-19T00:00:00.000Z","isOriginal":false,"author":[{"name":"애옹킴","url":"https://yozm.wishket.com/magazine/@jhk0530/"}],"cover":"https://yozm.wishket.com/media/news/3356/tum.png"},"git":{},"readingTime":{"minutes":1.69,"words":508},"filePathRelative":"yozm.wishket.com/3356.md","copyright":{"author":"애옹킴"}}');export{V as comp,O as data};
