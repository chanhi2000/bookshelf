import{_ as v}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as f,d as n,f as a,b as p,a as b,t as g,n as d,g as u,w as t,e,r as l,o as w}from"./app-BItykJLQ.js";const y={},D={id:"frontmatter-title-관련",tabindex:"-1"},x={class:"header-anchor",href:"#frontmatter-title-관련"},I={class:"table-of-contents"},C={class:"hint-container note"},T={href:"https://leanpub.com/effectivekotlin",target:"_blank",rel:"noopener noreferrer"},O={href:"https://amazon.com/Effective-Kotlin-Best-Practices-Developers-ebook/dp/B0CHBR5XPF/",target:"_blank",rel:"noopener noreferrer"},P={class:"footnotes"},M={class:"footnotes-list"},j={id:"footnote4",class:"footnote-item"},U={id:"footnote7",class:"footnote-item"},A={href:"https://github.com/MarcinMoskala/coroutines-benchmarks/blob/master/src/jmh/java/me/champeau/jmh/DispatchersBenchmark.kt",target:"_blank",rel:"noopener noreferrer"};function E(h,s){const r=l("VPCard"),i=l("router-link"),m=l("SiteInfo"),c=l("VPIcon"),o=l("KotlinPlayground"),k=l("RouteLink");return w(),f("div",null,[n("h1",D,[n("a",x,[n("span",null,g(h.$frontmatter.title)+" 관련",1)])]),a(r,d(u({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",I,[n("ul",null,[n("li",null,[a(i,{to:"#default-dispatcher"},{default:t(()=>[...s[0]||(s[0]=[e("Default dispatcher",-1)])]),_:1})]),n("li",null,[a(i,{to:"#limiting-the-default-dispatcher"},{default:t(()=>[...s[1]||(s[1]=[e("Limiting the default dispatcher",-1)])]),_:1})]),n("li",null,[a(i,{to:"#main-dispatcher"},{default:t(()=>[...s[2]||(s[2]=[e("Main dispatcher",-1)])]),_:1})]),n("li",null,[a(i,{to:"#io-dispatcher"},{default:t(()=>[...s[3]||(s[3]=[e("IO dispatcher",-1)])]),_:1})]),n("li",null,[a(i,{to:"#dispatcher-with-a-custom-limit"},{default:t(()=>[...s[4]||(s[4]=[e("Dispatcher with a custom limit",-1)])]),_:1})]),n("li",null,[a(i,{to:"#dispatcher-with-a-fixed-pool-of-threads"},{default:t(()=>[...s[5]||(s[5]=[e("Dispatcher with a fixed pool of threads",-1)])]),_:1})]),n("li",null,[a(i,{to:"#dispatcher-limited-to-a-single-thread"},{default:t(()=>[...s[6]||(s[6]=[e("Dispatcher limited to a single thread",-1)])]),_:1})]),n("li",null,[a(i,{to:"#using-virtual-threads-from-project-loom"},{default:t(()=>[...s[7]||(s[7]=[e("Using virtual threads from Project Loom",-1)])]),_:1})]),n("li",null,[a(i,{to:"#unconfined-dispatcher"},{default:t(()=>[...s[8]||(s[8]=[e("Unconfined dispatcher",-1)])]),_:1})]),n("li",null,[a(i,{to:"#immediate-main-dispatching"},{default:t(()=>[...s[9]||(s[9]=[e("Immediate main dispatching",-1)])]),_:1})]),n("li",null,[a(i,{to:"#continuation-interceptor"},{default:t(()=>[...s[10]||(s[10]=[e("Continuation interceptor",-1)])]),_:1})]),n("li",null,[a(i,{to:"#performance-of-dispatchers-when-executing-different-tasks"},{default:t(()=>[...s[11]||(s[11]=[e("Performance of dispatchers when executing different tasks",-1)])]),_:1})]),n("li",null,[a(i,{to:"#summary"},{default:t(()=>[...s[12]||(s[12]=[e("Summary",-1)])]),_:1})])])]),s[32]||(s[32]=n("hr",null,null,-1)),a(m,{name:"Kotlin Coroutines dispatchers",desc:"Where we should use each dispatcher from the Kotlin Coroutines library.",url:"https://kt.academy/article/cc-dispatchers",logo:"https://kt.academy/logo.png",preview:"https://marcinmoskala.com/coroutines_book/promotion/207_dispatchers.jpg"}),n("div",C,[s[20]||(s[20]=n("p",{class:"hint-container-title"},"Note",-1)),n("p",null,[s[15]||(s[15]=e("This is a chapter from the book ",-1)),s[16]||(s[16]=n("a",{href:"/book/effectivekotlin",target:"_blank",rel:"noopener noreferrer"},"Effective Kotlin",-1)),s[17]||(s[17]=e(". You can find it on ",-1)),n("a",T,[a(c,{icon:"fas fa-globe"}),s[13]||(s[13]=e("LeanPub",-1))]),s[18]||(s[18]=e(" or ",-1)),n("a",O,[a(c,{icon:"fa-brands fa-amazon"}),s[14]||(s[14]=e("Amazon",-1))]),s[19]||(s[19]=e(".",-1))])]),s[33]||(s[33]=p('<p>The Kotlin Coroutines library offers an important functionality that lets us decide which thread (or pool of threads) a coroutine should be running on (starting and resuming). This is done using dispatchers.</p><p>In the English dictionary, a dispatcher is defined as &quot;a person who is responsible for sending people or vehicles to where they are needed, especially emergency vehicles&quot;. In Kotlin coroutines, <code>CoroutineContext</code> determines which thread a certain coroutine will run on.</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>Dispatchers in Kotlin Coroutines are a similar concept to RxJava Schedulers.</p></div><hr><h2 id="default-dispatcher" tabindex="-1"><a class="header-anchor" href="#default-dispatcher"><span>Default dispatcher</span></a></h2><p>If you don&#39;t set any dispatcher, the one chosen by default by asynchronous coroutine builders is <code>Dispatchers.Default</code>, which is designed to run CPU-intensive operations. It has a pool of threads whose size is equal to the number of cores in the machine your code is running on (but not less than two). At least theoretically, this is the optimal number of threads, assuming you are using them efficiently, i.e., performing CPU-intensive calculations and not blocking threads. To see this dispatcher in action, run the following code:</p>',6)),a(o,{title:"Default%20dispatcher",key:"c2fb72ba",settings:"%7B%7D",files:"eJxFTstqwzAQ/JXB9CBdFPca6C3HkEKanupSVHkTi8oroUdJCfn3yo3dwD6Y3Z2ZfWtSSYG4x7EwRm1ZyDVe2WY8wfjoS7ZML8YHwqVjIFIgncVj27byNgGcLmwGXLBawccZio1NQWczUExqQ0ddXP5nYDo9+Gr4RahenyX9LJutTVX/oxpMWSnYa+79qJjOeev5JCSuatTn57grzgm5EL+1Qx4i6X6nR6r/H/6AMiVG4nxDQiqu24UTouXsWHTNvjBbPsHzLLLGw12ta2ab69RqqdG8/wLnomaS"}),s[34]||(s[34]=p(`<p>Example result on my machine (I have 12 cores, so there are 12 threads in the pool):</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">Running on thread: DefaultDispatcher-worker-1</span>
<span class="line">Running on thread: DefaultDispatcher-worker-5</span>
<span class="line">Running on thread: DefaultDispatcher-worker-7</span>
<span class="line">Running on thread: DefaultDispatcher-worker-6</span>
<span class="line">Running on thread: DefaultDispatcher-worker-11</span>
<span class="line">Running on thread: DefaultDispatcher-worker-2</span>
<span class="line">Running on thread: DefaultDispatcher-worker-10</span>
<span class="line">Running on thread: DefaultDispatcher-worker-4</span>
<span class="line">...</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning"><p class="hint-container-title">Warning</p><p><code>runBlocking</code> sets its own dispatcher if no other one is set; so, inside its scope the <code>Dispatcher.Default</code> is not the one that is chosen automatically. If we used <code>runBlocking</code> instead of <code>coroutineScope</code> in the above example, all coroutines would be running on &quot;main&quot;.</p></div><hr><h2 id="limiting-the-default-dispatcher" tabindex="-1"><a class="header-anchor" href="#limiting-the-default-dispatcher"><span>Limiting the default dispatcher</span></a></h2><p>Let&#39;s say that you have an expensive process and you suspect that it might use all <code>Dispatchers.Default</code> threads and starve other coroutines using the same dispatcher. In such cases, we can use <code>limitedParallelism</code> on <code>Dispatchers.Default</code> to make a dispatcher that runs on the same threads but is limited to using not more than a certain number of them at the same time.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">private</span> <span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>Default</span>
<span class="line">                            <span class="token punctuation">.</span><span class="token function">limitedParallelism</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>If you&#39;ve seen <code>limitedParallelism</code> before, I should warn you that this function has completely different behavior for <code>Dispatchers.Default</code> than for <code>Dispatchers.IO</code>. We will discuss it later.</p><div class="hint-container info"><p class="hint-container-title">Info</p><p><code>limitedParallelism</code> was introduced in kotlinx-coroutines version <code>1.6</code>, so it is quite a new feature and you won&#39;t find it being used in older projects.</p></div><hr><h2 id="main-dispatcher" tabindex="-1"><a class="header-anchor" href="#main-dispatcher"><span>Main dispatcher</span></a></h2><p>Android and many other application frameworks have the concept of a main or UI thread, which is generally the most important thread as it is the only one that can be used to interact with the UI on Android. Therefore, it needs to be used very often but also with great care. When the Main thread is blocked, the whole application is frozen. To run a coroutine on the Main thread, we use <code>Dispatchers.Main</code>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">showUserName</span><span class="token punctuation">(</span>name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> </span>
<span class="line">  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    userNameTextView<span class="token punctuation">.</span>text <span class="token operator">=</span> name</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Notice that frontend libraries are typically not used in unit tests, so <code>Dispatchers.Main</code> is not defined there. To be able to use it, you need to set a dispatcher using <code>Dispatchers.setMain(dispatcher)</code> from <code>kotlinx-coroutines-test</code>.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="SomeTest.kt"><span>SomeTest.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> SomeTest <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Executors</span>
<span class="line">                              <span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                              <span class="token punctuation">.</span><span class="token function">asCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  </span>
<span class="line">  <span class="token annotation builtin">@Before</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    Dispatchers<span class="token punctuation">.</span><span class="token function">setMain</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token annotation builtin">@After</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// reset the Main dispatcher to</span></span>
<span class="line">    <span class="token comment">// the original Main dispatcher</span></span>
<span class="line">    Dispatchers<span class="token punctuation">.</span><span class="token function">resetMain</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    dispatcher<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token annotation builtin">@Test</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">testSomeUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runBlocking <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">launch</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// ...</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>On Android, we typically use the Main dispatcher as the default one. If you use libraries that are suspending instead of blocking and you don&#39;t do any complex calculations, in practice you can only use <code>Dispatchers.Main</code>. If you do some CPU-intensive operations, you should run them on <code>Dispatchers.Default</code>. These two are enough for many applications, but what if you need to block the thread because, for example, you need to perform long I/O operations (e.g., read big files) or use a library with blocking functions? You cannot block the Main thread because your application would freeze. If you block your default dispatcher, you risk blocking all the threads in the thread pool, in which case you won&#39;t be able to do any calculations. This is why we need a different dispatcher for such a situation, and this dispatcher is <code>Dispatchers.IO</code>.</p><hr><h2 id="io-dispatcher" tabindex="-1"><a class="header-anchor" href="#io-dispatcher"><span>IO dispatcher</span></a></h2><p><code>Dispatchers.IO</code> is designed to be used when we block threads with I/O operations, such as when we read/write files or call blocking functions. The code below takes around 1 second because <code>Dispatchers.IO</code> allows more than 50 active threads at the same time.</p>`,19)),a(o,{title:"IO%20dispatcher%20(1)",key:"04863ebe",settings:"%7B%7D",files:"eJx9jz9PAzEMxb/KU6fckh4DIxsLA2KgG8cQXY3OInGiOEEgBJ+9117/V22G+Mn+2X5+m3FIMRd8xuJZvm0fc6yFhdQ+siZX+oGydnId28vXPia6RXpXpR/OCKs/WijYQE5rpgUHembvedzZiVZNJEt8VEFwLKbBbyfAl/MoI4kHXPRNBHDqa5cFMiVyxdy321nTm7yZo5vt08sJASyGTG5p1RMlc9e2bXOo/u3kVmzC5kuZpXgxa78N5nP8r1s7GYuz9xWRF4RE"}),s[35]||(s[35]=p('<div class="hint-container info"><p class="hint-container-title">Info</p><p><code>Dispatchers.IO</code> is only needed if you have an API that blocks threads. If you use suspending functions, you can use any dispatcher. You do not need to use <code>Dispatchers.IO</code> if you want to use a network or database library that provides suspending functions. In many projects, this means you might not need to use <code>Dispatchers.IO</code> at all.</p></div><p>How does IO dispatcher work? Imagine an unlimited pool of threads that is initially empty but more threads are created as we need them and kept active until they are not used for some time. Such a pool exists, but it wouldn&#39;t be safe to use it directly because too many active threads cause performance to degrade in a slow but unlimited manner, eventually causing out-of-memory errors. This is why all basic dispatchers have a limited number of threads they can use at the same time. <code>Dispatchers.Default</code> is limited by the number of cores in your processor. The limit of <code>Dispatchers.IO</code> is 64 (or the number of cores if there are more).</p>',2)),a(o,{title:"IO%20dispatcher%20(2)",key:"4e5ddc62",settings:"%7B%7D",files:"eJyVj7sOwjAMRX/FqhjSgVBeCxIbCwtIPCbKEAVDI4IT5QED4t9JaYGFBSmxZV8fX3mX+egt0gGOkeAiFLF8AltSAaYgjTMxKMK1NBbhXhKAQ4sisH5RFHnTAdAikqzYTHkrgqzQeT5fflSATeVQHLjXiJYNEtgIb/kqNITXyEJcMPm28zI6hxSaiuWckvpmrFMUNLEyW0UiRScw1C6ZQOe7rcxas0edUkiv16s//ABneBRRh+8h3Ztx55T6NcE5/xscD//3GpWU7Z9DGIjP"}),s[36]||(s[36]=p('<p>As we have mentioned, both <code>Dispatchers.Default</code> and <code>Dispatchers.IO</code> share the same pool of threads. This is an important optimization. Threads are reused, and redispatching is often not needed. For instance, let&#39;s say you are running on <code>Dispatchers.Default</code> and then execution reaches <code>withContext(Dispatchers.IO) { ... }</code>. Most often, you will stay on the same thread<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>, but what changes is that this thread counts towards not the <code>Dispatchers.Default</code> limit but the <code>Dispatchers.IO</code> limit. Their limits are independent, so they will never starve each other.</p>',1)),a(o,{title:"IO%20dispatcher%20(3)",key:"aa6ce7d2",settings:"%7B%7D",files:"eJyVjsEKwjAMhl8leNoEO/AoeHIXTx7Uk/NQuoyWdWlpUzYQ392NycSTCEl+Qj4+cluZzrvA0Dq2hgahXHCJDWEU64oqiil6pBqaRNBJQ1m+gysZhj0s6Fk5j/CoCMDKREpnpYlestIYoiixkclyPgMAPhhiS9lFB5S1UCkEJJ63LBckO8xnsjesD44YB/4yHk+L7B/dc4pxjFUUU8P7tY9707vQjrH9eV7dX1LwbwE="}),s[37]||(s[37]=p(`<p>To see this more clearly, imagine that you use both <code>Dispatchers.Default</code> and <code>Dispatchers.IO</code> to the maximum. As a result, your number of active threads will be the sum of their limits. If you allow 64 threads in <code>Dispatchers.IO</code> and you have 8 cores, you will have 72 active threads in the shared pool. This means we have efficient thread reuse and both dispatchers have strong independence.</p><p>The most typical case in which we use <code>Dispatchers.IO</code> is when we need to call blocking functions from libraries. The best practice is to wrap them with <code>withContext(Dispatchers.IO)</code> to make them suspending functions, which can be used without any special care: they can be treated like all other properly implemented suspending functions.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="DiscUserRepository.kt"><span>DiscUserRepository.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> <span class="token function">DiscUserRepository</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> discReader<span class="token operator">:</span> DiscReader</span>
<span class="line"><span class="token punctuation">)</span> <span class="token operator">:</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> UserData <span class="token operator">=</span></span>
<span class="line">    <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">UserData</span><span class="token punctuation">(</span>discReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;userName&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>To better understand why <code>Dispatchers.IO</code> must have a limit, imagine that you have a periodic task that needs to start a large number of coroutines, each of which needs to block a thread. Your task might be sending a newsletter using a blocking API, like SendGrid. If <code>Dispatchers.IO</code> had no limit, this process would start as many threads as there are emails to send: if you have 100,000 emails to send, it will try to start 100,000 threads, which would require 100 GB of RAM, so it would crash your application. This is why we need to set a limit for <code>Dispatchers.IO</code>.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="NewsletterService.kt"><span>NewsletterService.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> NewsletterService <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> sendGrid <span class="token operator">=</span> <span class="token function">SendGrid</span><span class="token punctuation">(</span>API_KEY<span class="token punctuation">)</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">sendNewsletter</span><span class="token punctuation">(</span></span>
<span class="line">    newsletter<span class="token operator">:</span> Newsletter<span class="token punctuation">,</span></span>
<span class="line">    emails<span class="token operator">:</span> List<span class="token operator">&lt;</span>Email<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    emails<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> email <span class="token operator">-&gt;</span></span>
<span class="line">      launch <span class="token punctuation">{</span></span>
<span class="line">        sendGrid<span class="token punctuation">.</span><span class="token function">api</span><span class="token punctuation">(</span><span class="token function">createNewsletter</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> newsletter<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>This limit protects our resources but also makes processes take longer. If sending each email takes on average 100 ms and we have 100,000 emails to send, with <code>Dispatchers.IO</code> limited to 64 threads it will take nearly 3 minutes to send all emails. The problem with <code>Dispatchers.IO</code> is that it has one limit for the whole application, so one service might block another. Imagine that in the same application you have another service that needs to send registration confirmation emails. If both services used <code>Dispatchers.IO</code>, then users trying to register would wait in a queue for threads until all newsletter emails have been sent. This should never happen, so we need to create dispatchers with custom independent limits.</p><hr><h2 id="dispatcher-with-a-custom-limit" tabindex="-1"><a class="header-anchor" href="#dispatcher-with-a-custom-limit"><span>Dispatcher with a custom limit</span></a></h2><p><code>Dispatchers.IO</code> has a special behavior defined for the <code>limitedParallelism</code> function that creates a new dispatcher with an independent thread limit. For example, imagine you start 100 coroutines, each of which blocks a thread for a second. If you run these coroutines on <code>Dispatchers.IO</code>, it will take 2 seconds. If you run them on <code>Dispatchers.IO</code> with <code>limitedParallelism</code> set to 100 threads, it will take 1 second. The execution time of both dispatchers can be measured at the same time because the limits of these two dispatchers are independent anyway.</p>`,9)),a(o,{title:"Dispatcher%20with%20a%20custom%20limit",key:"3e9d9eca",settings:"%7B%7D",files:"eJxtUU1LxDAQ/StD2UPXQ7a7CMqCIOhFUBRcYcF4CO1IwyaTkKSiiP/dpt9lO4QkZCZv3nvznkhtjQtwMkFJ+ma5caYKktCzC06zJPM/PqBmGoWvHB6kxieplPScOPnKW6QCPisCLSSl6z28kQxwAwPka24swi8nACUqysv2DmCdpHA3dI7I6b30VoS8ROfZw/O6LdxsYP4OwZjTHnbZ1WWs+DvH/hIKiuFPTWcO0BYtBVNSy4DFi3BCKax16nSbZR2TJcpjm5HuYwsyNr09Ho8d6212vetY12vu4RJ+rB177GFIj+ic1q3wKDugj/6fzau3ZmkwMRxaFKEROz72vk5VTrMAh9KhKJhXiDZ+7q2K0QxmcmmOZmuEKkp5spqMqTVoFRXwpMapS5OPf0im5Dw="}),s[38]||(s[38]=p(`<p>Conceptually, there is an unlimited pool of threads that is used by <code>Dispatchers.Default</code> and <code>Dispatchers.IO</code>, but they both have limited access to these threads. When we use <code>limitedParallelism</code> on <code>Dispatchers.IO</code>, we create a new dispatcher with an independent pool of threads (completely independent of <code>Dispatchers.IO</code> limit). If we use <code>limitedParallelism</code> on <code>Dispatchers.Default</code> or any other dispatcher, we create a dispatcher with an additional limit that is still limited, just like the original dispatcher.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">// Dispatcher with an unlimited pool of threads</span>
<span class="line">private val pool = ...</span>
<span class="line">Dispatchers.IO = pool limited to 64</span>
<span class="line">Dispatchers.IO.limitedParallelism(x) = pool limited to x</span>
<span class="line">Dispatchers.Default = pool limited to coresNum</span>
<span class="line">Dispatchers.Default.limitedParallelism(x) = </span>
<span class="line">    Dispatchers.Default limited to x</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">Info</p><p><code>Dispatchers.Default</code> is limited to the number of cores. <code>Dispatchers.IO</code> is limited to 64 (or the number of cores). Using <code>limitedParallelism</code> on <code>Dispatchers.Default</code> makes a dispatcher with an additional limit to <code>Dispatchers.Default</code>, whereas using it on <code>Dispatcher.IO</code> makes a dispatcher with a limit independent of <code>Dispatcher.IO</code>. However, all these dispatchers share the same infinite pool of threads.</p></div><p>Many developers find it a bit confusing that <code>limitedParallelism</code> has different behavior for <code>Dispatchers.IO</code>, which has nothing to do with the <code>Dispatchers.IO</code> limit. I think we can make this much more intuitive by just adding a simple function to name the creation of a dispatcher that has an independent thread limit:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">limitedDispatcher</span><span class="token punctuation">(</span>threadLimit<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO</span>
<span class="line">                                            <span class="token punctuation">.</span><span class="token function">limitedParallelism</span><span class="token punctuation">(</span>threadLimit<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>The best practice for classes that might intensively block threads is to define their own dispatchers that have their own independent limits. How big should this limit be? You need to decide for yourself, but remember that many threads are inefficient use of our resources. On the other hand, waiting for an available thread is not good for performance. What is most essential is that this limit is independent of <code>Dispatcher.IO</code> and other dispatchers&#39; limits, therefore one service will not block another.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="DiscUserRepository.kt"><span>DiscUserRepository.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> <span class="token function">DiscUserRepository</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> discReader<span class="token operator">:</span> DiscReader</span>
<span class="line"><span class="token punctuation">)</span> <span class="token operator">:</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO</span>
<span class="line">                              <span class="token punctuation">.</span><span class="token function">limitParallelism</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> UserData <span class="token operator">=</span></span>
<span class="line">    <span class="token function">withContext</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">UserData</span><span class="token punctuation">(</span>discReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;userName&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>Let&#39;s get back to the example with the newsletter and the registration confirmation emails. Each of these services should have its own dispatcher with a limit. This way, they will not block each other. The question is what the size of their limits should be. This is a hard question that has no simple answer. It depends on what we care about more: performance or resource usage. If we care about performance, we should set the limit to the number of threads that will be used most of the time. If we care about resource usage, we should set the limit to the number of threads that will be used at the peak time. In this case, I don&#39;t care that the newsletters take a bit longer to send; it would be perfectly fine even if it took an hour, so I could use a small limit, like 5. On the other hand, I care about the registration confirmation emails being sent as soon as possible, and I don&#39;t think this service will ever be used too intensively, so I could set a much higher limit, like 50. Even in most extreme cases, I do not want to block too many threads, because it would expose us to attacks (a big number of requests could block enough threads to cause out-of-memory errors).</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="NewsletterService.kt"><span>NewsletterService.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> NewsletterService <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">.</span><span class="token function">limitedParallelism</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> sendGrid <span class="token operator">=</span> <span class="token function">SendGrid</span><span class="token punctuation">(</span>API_KEY<span class="token punctuation">)</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">sendNewsletter</span><span class="token punctuation">(</span></span>
<span class="line">    newsletter<span class="token operator">:</span> Newsletter<span class="token punctuation">,</span></span>
<span class="line">    emails<span class="token operator">:</span> List<span class="token operator">&lt;</span>Email<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    emails<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> email <span class="token operator">-&gt;</span></span>
<span class="line">      launch <span class="token punctuation">{</span></span>
<span class="line">        sendGrid<span class="token punctuation">.</span><span class="token function">api</span><span class="token punctuation">(</span><span class="token function">createNewsletter</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> newsletter<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> AuthorizationService <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">.</span><span class="token function">limitedParallelism</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">sendAuthEmail</span><span class="token punctuation">(</span></span>
<span class="line">    user<span class="token operator">:</span> User</span>
<span class="line">  <span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    sendGrid<span class="token punctuation">.</span><span class="token function">api</span><span class="token punctuation">(</span><span class="token function">createConfirmationEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h2 id="dispatcher-with-a-fixed-pool-of-threads" tabindex="-1"><a class="header-anchor" href="#dispatcher-with-a-fixed-pool-of-threads"><span>Dispatcher with a fixed pool of threads</span></a></h2><p>Some developers like to have more control over the pools of threads they use, and Java offers a powerful API for that. For example, we can create a fixed or cached pool of threads with the <code>Executors</code> class. These pools implement the <code>ExecutorService</code> or <code>Executor</code> interfaces, which we can transform into a dispatcher using the <code>asCoroutineDispatcher</code> function.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">private</span> <span class="token keyword">val</span> NUMBER_OF_THREADS <span class="token operator">=</span> <span class="token number">20</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Executors</span>
<span class="line">                  <span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>NUMBER_OF_THREADS<span class="token punctuation">)</span></span>
<span class="line">                  <span class="token punctuation">.</span><span class="token function">asCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info"><p class="hint-container-title">Info</p><p><code>limitedParallelism</code> was introduced in <code>kotlinx-coroutines</code> version 1.6; in previous versions, we often created dispatchers with independent pools of threads using the <code>Executors</code> class.</p></div><p>The biggest problem with this approach is that a dispatcher created with <code>ExecutorService.asCoroutineDispatcher()</code> needs to be closed with the <code>close</code> function. Developers often forget about this, which leads to leaking threads. Another problem is that when you create a fixed pool of threads, you are not using them efficiently because you will keep unused threads alive without sharing them with other services.</p><hr><h2 id="dispatcher-limited-to-a-single-thread" tabindex="-1"><a class="header-anchor" href="#dispatcher-limited-to-a-single-thread"><span>Dispatcher limited to a single thread</span></a></h2><p>For all dispatchers using multiple threads, we need to consider the shared state problem. In the example below, notice that 10,000 coroutines are increasing <code>i</code> by 1. So, its value should be 10,000, but it is a smaller number. This is a result of a shared state (<code>i</code> property) modification on multiple threads at the same time.</p>`,18)),a(o,{title:"Dispatcher%20limited%20to%20a%20single%20thread%20(1)",key:"9af69bb0",settings:"%7B%7D",files:"eJwljssKwjAURH9l6CqlYCOuKrjrxpULcWVFQprSC/Em5CGI6Leb2s19zAyHuVZPFUA4QA48cMzRGx4xZcZDEYt6jwtTKr52weVEbM7aeYP3wEAw3qgktvIupaxXDbAqs55FT9GrpGcT4uZ4Ki7aFi6gN5PKNq1ZgJpmPT/L+o/RWPUq1MJcXh+Ik2VB9UL4dt2udC3B6vYDyXQ7IA=="}),s[39]||(s[39]=p(`<p>There are many ways to solve this problem (most will be described in the <em>The problem with shared states</em> chapter), but one option is to use a dispatcher with just a single thread. If we use just a single thread at a time, we do not need any other synchronization. The classic way to do this used to be to create such a dispatcher using <code>Executors</code>. The problem with this is that this dispatcher keeps an extra thread active that needs to be closed when it is not used anymore. A modern solution is to use <code>Dispatchers.Default</code> or <code>Dispatchers.IO</code> (if we block threads) with parallelism limited to 1.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO</span>
<span class="line">                  <span class="token punctuation">.</span><span class="token function">limitedParallelism</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//</span></span>
<span class="line"><span class="token comment">// previously:</span></span>
<span class="line"><span class="token comment">// val dispatcher = Executors.newSingleThreadExecutor()</span></span>
<span class="line"><span class="token comment">//     .asCoroutineDispatcher()</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),a(o,{title:"Dispatcher%20limited%20to%20a%20single%20thread%20(2)",key:"7c5cd1e0",settings:"%7B%7D",files:"eJxtjUsKg0AQRK/SZDUi+NkGsvMAgZBVzKLRFhvadpiPEELuHh3BbFKL/lCPqsdpQQcMF6habdVHb0l7GKLChKwmO8NdOax+N7s5Bla6dbMleLcKsKBAz95i6EZyK9Qcjy8aGjBK2Lh/KoQnDtRf0aEICfvJ1NlGO7KEwdTVqmwvAhCM2o3m13Y4AJzn+/nZVho9Cb5SRIq0jjWIGs6gLCElt7qCp+cXSwBO+A=="}),s[40]||(s[40]=n("p",null,"Because we can use only one thread, the biggest disadvantage of using a dispatcher limited to a single thread is that our calls will be handled sequentially if we block it.",-1)),a(o,{title:"Dispatcher%20limited%20to%20a%20single%20thread%20(3)",key:"8b89b9e8",settings:"%7B%7D",files:"eJxlUDtPwzAQ/iuniMFhcNOhDEhsXZGQCBNmsJKrctQ+W34gUMV/x05oqqo32Pf4HtL33pD1LiQ4umSIv+XggsuJGKO8V3x1lPEnJrTSoo45YE8Wn8kYiooVxxw98giHzGA1sWgf4Y0pwROskq+D8wgnxQBf2sBI0es0TBgKaL8OUe7xoLNJFXdb0pClhOOLDtoYLPZWbNuKPesanXmYiubSiItPu5gDBPSok9itCziz1hmgnwLqUUaD6MW267rZpdbv0szf/FTbVPIopjfpwOlfW366msvC8IE4GRaq6Z07wl1lq6aFzQbmxa7rHhQXaPPxB6D2imc="}),s[41]||(s[41]=p(`<hr><h2 id="using-virtual-threads-from-project-loom" tabindex="-1"><a class="header-anchor" href="#using-virtual-threads-from-project-loom"><span>Using virtual threads from Project Loom</span></a></h2><p>The JVM platform introduced a new technology known as Project Loom<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>. Its biggest innovation is the introduction of <em>virtual threads</em>, which are much lighter than regular threads. It costs much less to have blocked virtual threads than to have a regular thread blocked.</p><p>Project Loom does not have much to offer us developers who know Kotlin Coroutines because they have many more amazing features, like effortless cancellation or virtual time for testing<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>. However, Project Loom can be truly useful when we use its virtual threads instead of <code>Dispatcher.IO</code>, where we cannot avoid blocking threads<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>.</p><p>To use Project Loom, we need to use JVM in the version over 19, and we currently need to enable preview features using the <code>--enable-preview</code> flag. Then, we should be able to create an executor using <code>newVirtualThreadPerTaskExecutor</code> from <code>Executors</code> and transform it into a coroutine dispatcher.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> LoomDispatcher <span class="token operator">=</span> Executors</span>
<span class="line">                      <span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                      <span class="token punctuation">.</span><span class="token function">asCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Such a dispatcher can also be implemented as an object declaration:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">object</span> LoomDispatcher <span class="token operator">:</span> <span class="token function">ExecutorCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">val</span> executor<span class="token operator">:</span> Executor <span class="token operator">=</span> Executor <span class="token punctuation">{</span> command <span class="token operator">-&gt;</span></span>
<span class="line">    Thread<span class="token punctuation">.</span><span class="token function">startVirtualThread</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">dispatch</span><span class="token punctuation">(</span></span>
<span class="line">    context<span class="token operator">:</span> CoroutineContext<span class="token punctuation">,</span></span>
<span class="line">    block<span class="token operator">:</span> Runnable</span>
<span class="line">  <span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>block<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;Cannot be invoked on Dispatchers.LOOM&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>To use this dispatcher similarly to other dispatchers, we can define an extension property on the <code>Dispatchers</code> object. This should also help this dispatcher&#39;s discoverability.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> Dispatchers<span class="token punctuation">.</span>Loom<span class="token operator">:</span> CoroutineDispatcher</span>
<span class="line">  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> LoomDispatcher</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Now we only need to test if our new dispatcher really is an improvement. We expect it to take less memory and processor time than other dispatchers when we are blocking threads. We could set up the environment for precise measurements, or we could construct an example so extreme that anyone can observe the difference. For this book, I decided to use the latter approach. I started 100,000 coroutines, each blocked for 1 second. Making them do something else, like printing something or incrementing some value, should not change the result much. The execution of all these coroutines on <code>Dispatchers.Loom</code> took a bit more than two seconds.</p>`,11)),a(o,{title:"Dispatcher%20limited%20to%20a%20single%20thread%20(4)",key:"00650413",settings:"%7B%7D",files:"eJxNjD0LwjAYhP/K4dQsbayDUHBz1Mk6WZGQvtJA8ibkY5L+dz9KweXueO642yaVFIhHPAvDKcOV6HBlk3GAI5VKpN44OhtrTcJrYED76Es2TBftAy0MiBRI5Wor5UNKKVYMWFVYT9XRpKCyniim+uS9+1sA/RRJjXWyROF7IcXazUv42Ufm2lKuui5Ew9myQNOgRbvfDby5vwEHCkAF"}),s[42]||(s[42]=n("p",null,[e("Let's compare this new dispatcher to an alternative. Using pure "),n("code",null,"Dispatchers.IO"),e(" would not be fair as it is limited to 64 threads, and such function execution would take over 26 minutes. We should increment the thread limit to the number of coroutines. When I did that, such code execution took over 23 seconds, so ten times more. Of course, it consumed much more memory and processor time than the "),n("code",null,"Dispatchers.Loom"),e(" version. Whenever possible, we should use "),n("code",null,"Dispatchers.Loom"),e(" instead of "),n("code",null,"Dispatchers.IO"),e(".")],-1)),a(o,{title:"Dispatcher%20limited%20to%20a%20single%20thread%20(5)",key:"0e62dfe2",settings:"%7B%7D",files:"eJxtTz1PxDAM/SvWTS1DLnALqsTGwoBA4pgIQlFrVAvHiRIHgdD9d1oqCojz4M/3/OyHDYUUs8JLVCZ5M33MsSoJFnPi5M/QlPeiGExAX2rGPQW8JmYqTpyUWhLKAM9VIHiSpu3gXkjhAv7h4cMJwKtnGKgkr/2IecJdrkUxVzcz5JgZpkCKw63PnhmndaE5tfbJWtvOnPWBuz4mXKQAMib0ugK/2wDsq/Rj83PIrxnAfszoB1MYMc3kRWK2w5J8hckdDKM2XZcyibK0sN3C2Q7O7c7J5vETZWpzgg=="}),s[43]||(s[43]=n("p",null,[e("At the moment, Project Loom is still young and hard to use, but I must say it is an exciting substitution for "),n("code",null,"Dispatchers.IO"),e(". However, you will likely not need it explicitly in the future as the Kotlin Coroutines team has expressed their willingness to use virtual threads by default once Project Loom is stable. I hope this happens soon.")],-1)),s[44]||(s[44]=n("hr",null,null,-1)),s[45]||(s[45]=n("h2",{id:"unconfined-dispatcher",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#unconfined-dispatcher"},[n("span",null,"Unconfined dispatcher")])],-1)),s[46]||(s[46]=n("p",null,[e("The last dispatcher we need to discuss is "),n("code",null,"Dispatchers.Unconfined"),e(", which is different from all the other dispatchers as it does not change any threads. When it is started, it runs on the thread on which it was started. If it is resumed, it runs on the thread that resumed it.")],-1)),a(o,{title:"Unconfined%20dispatcher",key:"7bf3a796",settings:"%7B%7D",files:"eJyVkU1PwzAMhv+K1VN6yT6OCJhExz9gJ8ohS10WLXWqJEabEP+dpB/QCxKTkkhO7Pd5Y78WLRN0ypAo4bMmgA/lQTuKhlhF4+gOqkV0fyATH3fwAMTW5vy848mjagSpDtNLXbwM8aYuJk3P9GSdPht6F3sTehX1CX2QB0qk1hA2U2LvDUVLYhSQmr1HimMkSpkBJaxWMAMmfuDQIzWVIo3WqqPFynnHyTWOussPJYcm5suvufw26jaXNGjVVWzW63X5b4WcmFTOLlpDF6lni0HusVVs4/MFNUfnQXDABo7XETMQBrPp+Lvd2592Ty6CRex/PS57sJMeA3co8jhn/bSKt2+ELbYW"}),s[47]||(s[47]=p(`<p>In older projects, you can find <code>Dispatchers.Unconfined</code> used in unit tests. Imagine that you need to test a function that calls <code>launch</code>, for which synchronizing the time might not be easy. One solution is to use <code>Dispatchers.Unconfined</code> instead of all other dispatchers. If it is used in all scopes, everything runs on the same thread, and we can more easily control the order of operations. This trick is not needed anymore, as we have much better tools for testing coroutines. We will discuss this later in the book.</p><p>From the performance point of view, this dispatcher is cheapest as it never requires thread switching, therefore we might choose it if we do not care at all which thread our code runs on. However, it is not considered good to use it so recklessly in practice. What if, by accident, we miss a blocking call and we are running on the <code>Main</code> thread? This could lead to blocking the entire application. This is why we avoid using <code>Dispatchers.Unconfined</code> in production code, except for some special cases.</p><hr><h2 id="immediate-main-dispatching" tabindex="-1"><a class="header-anchor" href="#immediate-main-dispatching"><span>Immediate main dispatching</span></a></h2><p>There is a cost associated with dispatching a coroutine. When <code>withContext</code> is called, the coroutine needs to be suspended, possibly wait in a queue, and then be resumed. This is a small but unnecessary cost if we are already on this thread. Look at the function below:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">showUser</span><span class="token punctuation">(</span>user<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token operator">=</span></span>
<span class="line">  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    userNameElement<span class="token punctuation">.</span>text <span class="token operator">=</span> user<span class="token punctuation">.</span>name</span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If this function had already been called on the main dispatcher, we would have an unnecessary cost of redispatching. What is more, if there were a long queue for the Main thread because of <code>withContext</code>, the user data might be shown after some delay (this coroutine would need to wait for other coroutines to do their job first). To prevent this, there is <code>Dispatchers.Main.immediate</code>, which dispatches only if it is needed. So, if the function below is called on the Main thread, it won&#39;t be re-dispatched: it will be called immediately.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">showUser</span><span class="token punctuation">(</span>user<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token operator">=</span></span>
<span class="line">  <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main<span class="token punctuation">.</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    userNameElement<span class="token punctuation">.</span>text <span class="token operator">=</span> user<span class="token punctuation">.</span>name</span>
<span class="line">    <span class="token comment">// ...</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We prefer <code>Dispatchers.Main.immediate</code> as the <code>withContext</code> argument whenever this function might have already been called from the main dispatcher. Currently, the other dispatchers do not support immediate dispatching.</p><hr><h2 id="continuation-interceptor" tabindex="-1"><a class="header-anchor" href="#continuation-interceptor"><span>Continuation interceptor</span></a></h2><p>Dispatching works based on the mechanism of continuation interception, which is built into the Kotlin language. There is a coroutine context named <code>ContinuationInterceptor</code>, whose <code>interceptContinuation</code> method is used to modify a continuation when a coroutine is suspended<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>. It also has a <code>releaseInterceptedContinuation</code> method that is called when a continuation is ended.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="ContinuationInterceptor.kt"><span>ContinuationInterceptor.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> ContinuationInterceptor <span class="token operator">:</span></span>
<span class="line">  CoroutineContext<span class="token punctuation">.</span><span class="token function">Element</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">companion</span> <span class="token keyword">object</span> Key <span class="token operator">:</span></span>
<span class="line">    CoroutineContext<span class="token punctuation">.</span>Key<span class="token operator">&lt;</span>ContinuationInterceptor<span class="token operator">&gt;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">interceptContinuation</span><span class="token punctuation">(</span></span>
<span class="line">    continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">)</span><span class="token operator">:</span> Continuation<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">releaseInterceptedContinuation</span><span class="token punctuation">(</span></span>
<span class="line">    continuation<span class="token operator">:</span> Continuation<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">//...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>The capability to wrap a continuation gives a lot of control. Dispatchers use <code>interceptContinuation</code> to wrap a continuation with <code>DispatchedContinuation</code>, which runs on a specific pool of threads. This is how dispatchers work.</p><p>The problem is that the same context is also used by many testing libraries, such as <code>runTest</code> from <code>kotlinx-coroutines-test</code>. Each element in a context has to have a unique key, which is why we sometimes inject dispatchers into unit tests to replace them with test dispatchers. We will get back to this topic in the chapter dedicated to coroutine testing.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="DiscUserRepository.kt"><span>DiscUserRepository.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> <span class="token function">DiscUserRepository</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> discReader<span class="token operator">:</span> DiscReader<span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> dispatcher<span class="token operator">:</span> CoroutineContext <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token operator">:</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> UserData <span class="token operator">=</span></span>
<span class="line">    <span class="token function">withContext</span><span class="token punctuation">(</span>dispatcher<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">UserData</span><span class="token punctuation">(</span>discReader<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;userName&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> UserReaderTests <span class="token punctuation">{</span></span>
<span class="line">  <span class="token annotation builtin">@Test</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">\`some test\`</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> runTest <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// given</span></span>
<span class="line">    <span class="token keyword">val</span> discReader <span class="token operator">=</span> <span class="token function">FakeDiscReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">val</span> repo <span class="token operator">=</span> <span class="token function">DiscUserRepository</span><span class="token punctuation">(</span></span>
<span class="line">      discReader<span class="token punctuation">,</span></span>
<span class="line">      <span class="token comment">// one of coroutines testing practices</span></span>
<span class="line">      <span class="token keyword">this</span><span class="token punctuation">.</span>coroutineContext\\<span class="token punctuation">[</span>ContinuationInterceptor\\<span class="token punctuation">]</span><span class="token operator">!!</span></span>
<span class="line">    <span class="token punctuation">)</span></span>
<span class="line">    <span class="token comment">//...</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h2 id="performance-of-dispatchers-when-executing-different-tasks" tabindex="-1"><a class="header-anchor" href="#performance-of-dispatchers-when-executing-different-tasks"><span>Performance of dispatchers when executing different tasks</span></a></h2><p>To show how different dispatchers perform in different tasks, I made some benchmarks. In all these cases, the task is to run 100 independent coroutines with the same task. The columns represent different tasks: suspending for a second, blocking for a second, CPU-intensive operation, and memory-intensive operation (where the majority of the time is spent accessing, allocating, and freeing memory). Different rows represent the different dispatchers used for running these coroutines. The table below shows the average execution time in milliseconds.</p><table><thead><tr><th style="text-align:right;"></th><th style="text-align:center;">Suspending</th><th style="text-align:center;">Blocking</th><th style="text-align:center;">CPU</th><th style="text-align:center;">Memory</th></tr></thead><tbody><tr><td style="text-align:right;">Single thread</td><td style="text-align:center;">1,002</td><td style="text-align:center;">100,003</td><td style="text-align:center;">39,103</td><td style="text-align:center;">94,358</td></tr><tr><td style="text-align:right;">Default (8 threads)</td><td style="text-align:center;">1,002</td><td style="text-align:center;">13,003</td><td style="text-align:center;">8,473</td><td style="text-align:center;">21,461</td></tr><tr><td style="text-align:right;">IO (64 threads)</td><td style="text-align:center;">1,002</td><td style="text-align:center;">2,003</td><td style="text-align:center;">9,893</td><td style="text-align:center;">20,776</td></tr><tr><td style="text-align:right;">100 threads</td><td style="text-align:center;">1,002</td><td style="text-align:center;">1,003</td><td style="text-align:center;">10,379</td><td style="text-align:center;">21,004</td></tr></tbody></table><p>There are a few important observations you can make:</p><ul><li>When we are just suspending, it doesn&#39;t really matter how many threads we are using.</li><li>When we are blocking, the more threads we are using, the faster all these coroutines will be finished.</li><li>With CPU-intensive operations, <code>Dispatchers.Default</code> is the best option<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>.</li><li>If we are dealing with a memory-intensive problem, more threads might provide some (but not significant) improvement.</li></ul><p>Here is how the tested functions look<sup class="footnote-ref"><a href="#footnote7">[7]</a><a class="footnote-anchor" id="footnote-ref7"></a></sup>:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">cpu</span><span class="token punctuation">(</span>order<span class="token operator">:</span> Order<span class="token punctuation">)</span><span class="token operator">:</span> Coffee <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> i <span class="token operator">=</span> Int<span class="token punctuation">.</span>MAX_VALUE</span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    i <span class="token operator">-=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token keyword">else</span> <span class="token number">2</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">Coffee</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>customer <span class="token operator">=</span> order<span class="token punctuation">.</span>customer <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">memory</span><span class="token punctuation">(</span>order<span class="token operator">:</span> Order<span class="token punctuation">)</span><span class="token operator">:</span> Coffee <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">1_000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> it <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">val</span> list2 <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">1_000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> list <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">val</span> list3 <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">1_000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> list2 <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">Coffee</span><span class="token punctuation">(</span></span>
<span class="line">    order<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span></span>
<span class="line">      customer <span class="token operator">=</span> order<span class="token punctuation">.</span>customer <span class="token operator">+</span> list3<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">blocking</span><span class="token punctuation">(</span>order<span class="token operator">:</span> Order<span class="token punctuation">)</span><span class="token operator">:</span> Coffee <span class="token punctuation">{</span></span>
<span class="line">  Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">Coffee</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">suspending</span><span class="token punctuation">(</span>order<span class="token operator">:</span> Order<span class="token punctuation">)</span><span class="token operator">:</span> Coffee <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">Coffee</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>Dispatchers determine which thread or thread pool a coroutine will run (starting and resuming) on. The most important options are:</p><ul><li><code>Dispatchers.Default</code>, which we use for CPU-intensive operations;</li><li><code>Dispatchers.Main</code>, which we use to access the Main thread on Android, Swing, or JavaFX;</li><li><code>Dispatchers.Main.immediate</code>, which runs on the same thread as <code>Dispatchers.Main</code> but is not redispatched if it is not necessary;</li><li><code>Dispatchers.IO</code>, which we use when we need to do some blocking operations;</li><li><code>Dispatchers.IO</code> with limited parallelism or a custom dispatcher with a pool of threads, which we use when we might have many blocking calls;</li><li><code>Dispatchers.Default</code> or <code>Dispatchers.IO</code> with parallelism limited to 1, or a custom dispatcher with a single thread, which is used when we need to secure shared state modifications;</li><li><code>Dispatchers.Unconfined</code>, which does not change threads and is used in some special cases;</li></ul>`,28)),b(" TODO: add ARTICLE CARD "),a(r,d(u({title:"Kotlin Coroutines dispatchers",desc:"Where we should use each dispatcher from the Kotlin Coroutines library.",link:"https://chanhi2000.github.io/bookshelf/kt.academy/cc-dispatchers.html",logo:"https://kt.academy/logo.png",background:"rgba(243,139,49,0.2)"})),null,16),s[48]||(s[48]=n("hr",{class:"footnotes-sep"},null,-1)),n("section",P,[n("ol",M,[s[29]||(s[29]=p('<li id="footnote1" class="footnote-item"><p>This mechanism is not deterministic. <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>I am writing this optimistically, hoping that Project Loom is already stable when you read this. At the time of writing, in early 2023, it is not. <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>We will discuss this in the <em>Testing Kotlin Coroutines</em> chapter. <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li>',3)),n("li",j,[n("p",null,[s[22]||(s[22]=e("The solution was inspired by the article ",-1)),a(k,{to:"/kt.academy/dispatcher-loom.html"},{default:t(()=>[...s[21]||(s[21]=[n("em",null,"Running Kotlin coroutines on Project Loom's virtual threads",-1),e(" by ",-1),n("em",null,"Jan Vladimir Mostert",-1)])]),_:1}),s[23]||(s[23]=e(". ",-1)),s[24]||(s[24]=n("a",{href:"#footnote-ref4",class:"footnote-backref"},"↩︎",-1))])]),s[30]||(s[30]=n("li",{id:"footnote5",class:"footnote-item"},[n("p",null,[e("Wrapping needs to happen only once per continuation thanks to the caching mechanism. "),n("a",{href:"#footnote-ref5",class:"footnote-backref"},"↩︎")])],-1)),s[31]||(s[31]=n("li",{id:"footnote6",class:"footnote-item"},[n("p",null,[e("The main reason is that the more threads we use, the more time the processor needs to spend switching between them, thus it has less time to do meaningful operations. Also "),n("code",null,"Dispatchers.IO"),e(" should not be used for CPU-intensive operations because it is used to block operations, and some other process might block all its threads. "),n("a",{href:"#footnote-ref6",class:"footnote-backref"},"↩︎")])],-1)),n("li",U,[n("p",null,[s[26]||(s[26]=e("The whole code can be found at ",-1)),n("a",A,[a(c,{icon:"iconfont icon-github"}),s[25]||(s[25]=n("code",null,"MarcinMoskala/coroutines-benchmarks",-1))]),s[27]||(s[27]=e()),s[28]||(s[28]=n("a",{href:"#footnote-ref7",class:"footnote-backref"},"↩︎",-1))])])])])])}const L=v(y,[["render",E]]),S=JSON.parse('{"path":"/kt.academy/cc-dispatchers.html","title":"Kotlin Coroutines dispatchers","lang":"en-US","frontmatter":{"lang":"en-US","title":"Kotlin Coroutines dispatchers","description":"Article(s) > Kotlin Coroutines dispatchers","icon":"iconfont icon-kotlin","category":["Java","Kotlin","Article(s)"],"tag":["blog","kt.academy","java","kotlin"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kotlin Coroutines dispatchers\\",\\"image\\":[\\"https://marcinmoskala.com/coroutines_book/promotion/207_dispatchers.jpg\\"],\\"datePublished\\":\\"2024-07-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Marcin Moskała\\",\\"url\\":\\"https://kt.academy/user/marcinmoskala\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/cc-dispatchers.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Kotlin Coroutines dispatchers"}],["meta",{"property":"og:description","content":"Article(s) > Kotlin Coroutines dispatchers"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://marcinmoskala.com/coroutines_book/promotion/207_dispatchers.jpg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://marcinmoskala.com/coroutines_book/promotion/207_dispatchers.jpg"}],["meta",{"name":"twitter:image:alt","content":"Kotlin Coroutines dispatchers"}],["meta",{"property":"article:author","content":"Marcin Moskała"}],["meta",{"property":"article:tag","content":"kotlin"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"kt.academy"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-07-01T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Kotlin Coroutines dispatchers"},{"property":"og:description","content":"Kotlin Coroutines dispatchers"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/cc-dispatchers.html"}]],"prev":"/programming/java/articles/README.md","date":"2024-07-01T00:00:00.000Z","isOriginal":false,"author":[{"name":"Marcin Moskała","url":"https://kt.academy/user/marcinmoskala"}],"cover":"https://marcinmoskala.com/coroutines_book/promotion/207_dispatchers.jpg"},"git":{},"readingTime":{"minutes":16.24,"words":4871},"filePathRelative":"kt.academy/cc-dispatchers.md","copyright":{"author":"Marcin Moskała"}}');export{L as comp,S as data};
