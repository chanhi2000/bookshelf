import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as v,d as n,f as e,b as d,a as b,t as g,n as l,g as c,w as i,e as a,r,o as y}from"./app-BItykJLQ.js";const h={},w={id:"frontmatter-title-관련",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-관련"},A={class:"table-of-contents"},j={href:"https://tv.naver.com/v/52368749?t=2768",target:"_blank",rel:"noopener noreferrer"},T={href:"https://stackoverflow.com/questions/50374908/transform-union-type-to-intersection-type",target:"_blank",rel:"noopener noreferrer"},x={href:"https://x.com/mattpocockuk/status/1622730173446557697",target:"_blank",rel:"noopener noreferrer"},B={href:"https://typescriptlang.org/play/?#code/C4TwDgpgBAYglgG2BATgBRXAtnYcBuEA0hCAM4A8AKgDRREB8UAvPVBAB7IB2AJmVADWpAPYAzKFQBQUKAHo5UAFIBlKIFvRwDUDgQAnAHuNRALuOACccA6HVG4BXBAkAjzVBEAjAFYQAxsBnzFgCq7ABy1RABh7AF9HAEXGoQAnVwEqxwA1VwAY6qEAQccAXVahAABrAUvGoQAcFqEABhcBQ8f0LbkFuEQB3bihAA1XAT6bPAH5JAG0iAF12Lgg+AUtrKAAfKGLSiu5mts9ZBShABwnAFxqwwBnOwEcJwAjVsMAZVqhAEoXAH06oQAwewA01gDooQB9xwFCJwA1x9gBDFAQQKBQIYAsUbimoJqIfgBcLXanR4-HszjcHlkMN+5gghBQUB+siB-1R8MRUikoEgsEQyBQADkIGRkLwSORqHRGCw2JwwQJhCBxJIpAACuFUVodBndcF9BCDYYlMqVCYcqCcprcBGoSWcoHckF8noQlzuBVSuH-Tl6qBA2VYxWY+U48DQABq9wQFlJ1FB-IEjg1wCYrG5zNZVEm5rxJLJEF4AHlIe4HarwS6oe6oABvSWtKBwKrwJCoAPkymUWhCUQSKgMNpKnlSAC+2Nx0AASm5PmQ4CJuAAJCAISAoaixqiOtXR9xwmAIe7AMGh11dg2mlCVi2SEQASW4hLIUMb3EnrAAFD3IwJ7twXk0twB9JUAShYTHwIjgvCnRtQl73UFPQJTYlQUBUl+Y19v95NGohpyjOfrQAAqtw5QoPcYCQCGYbABGXR9kh3aLsuqCru464ULWrj1uurbtqgFDWra9qZkG45Ql2DAMbOeIqNgYAIBAQ4jmOSEoYy6oxnSCayEmKb4um6CYDgeCENm1J5iyBZFiW7Tlkx0CcaO-K0eGu6oVG6F0ixWBsRxw6aXw2nIYWUAAGRQFBMFwQhlmTmpUDViI1ibvGPwiVUXoFsWwKTGWtnxhWUhiMUuFNlAYhmTwLm6Xx-ZuluLpKnQbxkFYwBAgeLysHGZbnkCHleRp3EToWTBCXFIhIlurhNmS8nJlULqXnVshwBIW5VqyLrNMyHTMGNUAAOSpRNtl2UNI2zVAACE6XOMNpAdCmZIHq4ECsgAgigsEgOeXUonFCXdJZq1OOtIAdPczpIVlpK5eePyhW2q4+QAkLI2W5Xdo3qkDH2eBW-3vJ8VQA0gqlSM13CteUFR0vFXFXUhW51fcQITfcE00J4DiGlYCBE7IrhAt1UC8HjvCEz8EDU+dYhAgADB9FMwgA5qT1jg+W71AA",target:"_blank",rel:"noopener noreferrer"},F={href:"https://m.hanbit.co.kr/store/books/book_view.html?p_code=E2375873090",target:"_blank",rel:"noopener noreferrer"},O={class:"hint-container info"};function V(u,s){const p=r("VPCard"),t=r("router-link"),k=r("SiteInfo"),o=r("VPIcon");return y(),v("div",null,[n("h1",w,[n("a",f,[n("span",null,g(u.$frontmatter.title)+" 관련",1)])]),e(p,l(c({title:"TypeScript > Article(s)",desc:"Article(s)",link:"/programming/ts/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",A,[n("ul",null,[n("li",null,[e(t,{to:"#평탄한-객체와-중첩된-객체-분리하기"},{default:i(()=>[...s[0]||(s[0]=[a("평탄한 객체와 중첩된 객체 분리하기",-1)])]),_:1})]),n("li",null,[e(t,{to:"#중첩된-객체-한-단계-들어올리기"},{default:i(()=>[...s[1]||(s[1]=[a("중첩된 객체 한 단계 들어올리기",-1)])]),_:1}),n("ul",null,[n("li",null,[e(t,{to:"#합집합을-교집합으로"},{default:i(()=>[...s[2]||(s[2]=[a("합집합을 교집합으로",-1)])]),_:1})])])]),n("li",null,[e(t,{to:"#지연-평가를-활용하여-재귀적으로-수행하기"},{default:i(()=>[...s[3]||(s[3]=[a("지연 평가를 활용하여 재귀적으로 수행하기",-1)])]),_:1})]),n("li",null,[e(t,{to:"#마치며"},{default:i(()=>[...s[4]||(s[4]=[a("마치며",-1)])]),_:1})])])]),s[25]||(s[25]=n("hr",null,null,-1)),e(k,{name:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제",url:"https://d2.naver.com/helloworld/5088940",logo:"/assets/image/d2.naver.com/favicon.ico",preview:"/assets/image/d2.naver.com/5088940/banner.jpg"}),n("p",null,[s[6]||(s[6]=a("'infer, never만 보면 두려워지는 당신을 위한 타입 추론' 관련 영상은 ",-1)),n("a",j,[e(o,{icon:"fas fa-globe"}),s[5]||(s[5]=a("링크",-1))]),s[7]||(s[7]=a("에서 보실 수 있습니다.",-1))]),s[26]||(s[26]=d(`<p>앞에서 배운 내용을 토대로 어려운 타입 문제를 하나 풀어 보겠습니다.</p><p>자, 여기 예쁜 재귀 함수가 있습니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">function</span> <span class="token function">flattenObject</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> result<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token builtin">Array</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">flattenObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">      result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> result</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>함수 구현부는 신경쓰지 마시고, 동작만 한 번 볼까요?</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token function">flattenObject</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="line">  y<span class="token operator">:</span> <span class="token string">&#39;babo&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  z<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&#39;hi&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line">  a<span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    b<span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">      c<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    d<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span> </span>
<span class="line"><span class="token comment">//</span></span>
<span class="line"><span class="token comment">// { x: 0, y: &#39;babo&#39;, z: [&#39;hi&#39;], c: null, d: undefined }</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>네, 그렇습니다. 이 함수는 중첩된 객체를 평탄하게 펴는 함수입니다. 이 함수에 타입을 달아봅시다. 단, 아래의 전제 조건이 붙습니다.</p><ol><li>모든 속성의 이름은 유일성을 만족한다(=겹치지 않는다).</li><li>배열은 펼치지 않는다.</li><li><code>null</code>이나 <code>undefined</code> 값은 그대로 유지되어야 한다.</li></ol><hr><h2 id="평탄한-객체와-중첩된-객체-분리하기" tabindex="-1"><a class="header-anchor" href="#평탄한-객체와-중첩된-객체-분리하기"><span>평탄한 객체와 중첩된 객체 분리하기</span></a></h2><p>제일 먼저 생각나는 접근은 &#39;중첩되는 속성&#39;과 &#39;중첩되지 않는 속성&#39;을 쪼개서 처리한 뒤, 조립하는 것입니다.</p><p>먼저, 중첩되지 않은 속성부터 추출해 봅시다. T에 <code>undefined</code>나 <code>never</code>, <code>unknown</code> 같은 이상한 타입을 고려하지 않기 위해 <code>extends object</code>로 방어합니다. 그 뒤 지우고 싶은 값인 경우에 <code>never</code>로 처리해 버리면 되지 않을까요?</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">SimpleFlattendObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> FilterValueType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name">FilterValueType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span>  </span>
<span class="line">  <span class="token operator">?</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token keyword">null</span></span> <span class="token operator">|</span> <span class="token builtin">unknown</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token operator">?</span> <span class="token constant">T</span></span>
<span class="line">    <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line">  <span class="token operator">:</span> <span class="token constant">T</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>한 번 테스트해 볼까요?</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> test<span class="token operator">:</span> SimpleFlattendObject<span class="token operator">&lt;</span><span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span></span>
<span class="line">  y<span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    z<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">  x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token comment">// Property &#39;y&#39; is missing in type &#39;{ x: number; }&#39; but required in type \`FlattenKeys&lt;{ ... }&gt;\`</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>의도한 대로 동작하지 않습니다. 객체 리터럴에서 자동 완성을 확인해 보니, <code>y</code>가 <code>never</code>로 간주됩니다. <code>y</code>가 <code>test</code> 객체에 없어야 되는 건 맞지만, 값이 <code>never</code> 타입이라고 해서 키까지 자동으로 지우진 않습니다. 따라서, 값이 아닌 <strong>속성 키</strong>를 원천적으로 지워야 합니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">SimpleFlattendObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> FilterPrimitiveKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name">FilterPrimitiveKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span>  </span>
<span class="line">  <span class="token comment">// 모든 배열을 허용하기 위해 가장 큰 타입인 unknown 할당</span></span>
<span class="line">  <span class="token operator">?</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token comment">// 조건을 만족했을 때 키를 반환. 일종의 early return</span></span>
<span class="line">    <span class="token operator">?</span> <span class="token constant">K</span></span>
<span class="line">    <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span></span>
<span class="line">      <span class="token operator">?</span> <span class="token builtin">never</span></span>
<span class="line">      <span class="token operator">:</span> <span class="token constant">K</span></span>
<span class="line">  <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>테스트를 해 볼까요?</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> SimpleFlattendObject<span class="token operator">&lt;</span><span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span></span>
<span class="line">  y<span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    z<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  a<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span></span>
<span class="line">  b<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token comment">//</span></span>
<span class="line"><span class="token comment">// {</span></span>
<span class="line"><span class="token comment">//   x: number,</span></span>
<span class="line"><span class="token comment">//   a: null,</span></span>
<span class="line"><span class="token comment">//   b: [1]</span></span>
<span class="line"><span class="token comment">// }</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이제 잘 되네요! 이제 중첩된 객체만 잘 처리하면 되겠군요. 중첩되지 않은 값을 처리한 코드를 완전히 반전시키면 되겠네요.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">NestedObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> FilterNestedKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name">FilterNestedKeys<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span>  </span>
<span class="line">  <span class="token operator">?</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token operator">?</span> <span class="token builtin">never</span> <span class="token comment">// 아까랑 정반대!</span></span>
<span class="line">    <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">object</span></span>
<span class="line">      <span class="token operator">?</span> <span class="token constant">K</span></span>
<span class="line">      <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line">  <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>테스트해 볼까요?</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token comment">// 예시</span></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> NestedObject<span class="token operator">&lt;</span><span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span></span>
<span class="line">  y<span class="token operator">:</span> <span class="token punctuation">{</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span></span>
<span class="line">  a<span class="token operator">:</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token punctuation">{</span> c<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="line">  d<span class="token operator">:</span> <span class="token keyword">undefined</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token comment">//</span></span>
<span class="line"><span class="token comment">// {</span></span>
<span class="line"><span class="token comment">//   y: { z: number }</span></span>
<span class="line"><span class="token comment">//   a: { b: { c: [] }}</span></span>
<span class="line"><span class="token comment">// }</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>좋습니다.</p><hr><h2 id="중첩된-객체-한-단계-들어올리기" tabindex="-1"><a class="header-anchor" href="#중첩된-객체-한-단계-들어올리기"><span>중첩된 객체 한 단계 들어올리기</span></a></h2><p>이제 y 안에 들어있는 z, a 안에 들어있는 b를 한 단계 올리고 싶습니다. 일단 재귀적인 건 생각하지 말고, 한 단계만 올려봅시다.</p><p>우선 저 안에 있는 값의 &#39;키&#39;는 더 이상 중요하지 않습니다. 그러니 값의 타입만 모조리 추출합시다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">Values<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> Values<span class="token operator">&lt;</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token comment">// string | number  </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>아까 만들었던 <code>NestedObject</code>를 여기에 넣어봅시다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">UnwrappedObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> Values<span class="token operator">&lt;</span>NestedObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>테스트해 봅시다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> UnwrappedObject<span class="token operator">&lt;</span><span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span></span>
<span class="line">  y<span class="token operator">:</span> <span class="token punctuation">{</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span></span>
<span class="line">  a<span class="token operator">:</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token punctuation">{</span> c<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="line">  d<span class="token operator">:</span> <span class="token keyword">undefined</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token comment">//</span></span>
<span class="line"><span class="token comment">// {</span></span>
<span class="line"><span class="token comment">//   z: number</span></span>
<span class="line"><span class="token comment">// } | {</span></span>
<span class="line"><span class="token comment">//   b: { c: [] }</span></span>
<span class="line"><span class="token comment">// }</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>의도한 것과 비슷해졌습니다. <code>|</code>를 <code>&amp;</code>로 바꾸기만 하면 원하는 타입이 될 것 같네요. 그런데 <code>|</code>를 어떻게 <code>&amp;</code>로 바꾸죠?</p><h3 id="합집합을-교집합으로" tabindex="-1"><a class="header-anchor" href="#합집합을-교집합으로"><span>합집합을 교집합으로</span></a></h3>`,34)),n("p",null,[s[9]||(s[9]=a("Stack Overflow에 있던 한 재야의 고수는 아래와 같은 핵을 제시했습니다(출처: ",-1)),n("a",T,[e(o,{icon:"fa-brands fa-stack-overflow"}),s[8]||(s[8]=a("Transform union type to intersection type",-1))]),s[10]||(s[10]=a(").",-1))]),s[27]||(s[27]=d(`<div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">ToIntersection<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>  </span>
<span class="line">    <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span></span>
<span class="line">        <span class="token operator">?</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span></span>
<span class="line">        <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line">    <span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span></span>
<span class="line">        <span class="token operator">?</span> <span class="token constant">S</span></span>
<span class="line">        <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>생긴 게 상당히 당황스럽지만, 차근차근 하나씩 분석해 봅시다. 먼저 첫 번째 괄호를 임시로 <code>F&lt;T&gt;</code>라고 합시다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token constant">F</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token operator">:</span> <span class="token builtin">never</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>이 타입 표현식은 <code>T</code>를 <code>(_: T) =&gt; void</code>라는 함수 타입으로 바꿉니다. 이때 분배 법칙을 적용하기 위해서 <code>T extends any</code>를 써 준 것입니다. 즉, 아래와 같은 일이 벌어집니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> <span class="token constant">F</span><span class="token operator">&lt;</span><span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span><span class="token operator">&gt;</span>  </span>
<span class="line"><span class="token comment">// F = ((x: A) =&gt; void) | ((x: B) =&gt; void)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>이제 나머지 바깥의 조건부 타입을 해석하면 됩니다. 어떤 함수의 나열이 있고, 그 함수를 모두 포괄하는 함수와 인자를 <code>infer</code>로 추론하네요!</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">ToIntersection<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">S</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token operator">?</span> <span class="token constant">S</span> <span class="token operator">:</span> <span class="token builtin">never</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>그런데 함수의 인자 타입은 반공변성 때문에 방향이 거꾸로라고 했죠? 따라서 인자의 타입은 더 작아져야 합니다. <code>A</code>의 서브타입이면서 동시에 <code>B</code>의 서브타입인, 가장 넓은 타입이 필요합니다. 집합론에 따르면 이를 만족하는 타입은 <code>A &amp; B</code>입니다.</p><p>옆길로 좀 샜지만 이걸 <code>UnwrappedObject</code>에 적용해 봅시다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">UnwrappedObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> ToIntersection<span class="token operator">&lt;</span>Values<span class="token operator">&lt;</span>NestedObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> UnwrappedObject<span class="token operator">&lt;</span><span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span></span>
<span class="line">  y<span class="token operator">:</span> <span class="token punctuation">{</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span></span>
<span class="line">  a<span class="token operator">:</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token punctuation">{</span> c<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="line">  d<span class="token operator">:</span> <span class="token keyword">undefined</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token operator">&gt;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">/*</span>
<span class="line">{</span>
<span class="line">  z: number</span>
<span class="line">} &amp; {</span>
<span class="line">  b: { c: [] }</span>
<span class="line">}</span>
<span class="line">*/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>의도한 대로 동작하네요! 그러면 아까 단순하게 풀어헤친 걸 같이 합쳐주면, 중첩된 객체 한 단계 들어올리기는 끝납니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">FlattendObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> SimpleFlattendObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span> UnwrappedObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="지연-평가를-활용하여-재귀적으로-수행하기" tabindex="-1"><a class="header-anchor" href="#지연-평가를-활용하여-재귀적으로-수행하기"><span>지연 평가를 활용하여 재귀적으로 수행하기</span></a></h2><p>이제 마지막 난관이 남았습니다. 바로 추가적인 중첩에 대해서 재귀적으로 수행하는 것입니다.</p><p>다중 중첩된 객체는 <code>NestedObject</code>의 값 안에 들어있습니다. 우리가 만든 제네릭인 <code>FlattendObject</code>는 한 단계에 대해서 이를 수행했으니 이걸 집어넣으면 되지 않을까요? <code>Values</code>로 풀어헤친 다음, 교집합으로 변환하기 전에 재귀적으로 수행하면 되겠군요!</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">UnwrappedObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> ToIntersection<span class="token operator">&lt;</span>FlattendObject<span class="token operator">&lt;</span>Values<span class="token operator">&lt;</span>NestedObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span><span class="token operator">&gt;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>안타깝게도 이렇게 하면, <code>FlattendObject</code>의 정의에 <code>FlattendObject</code>가 사용되어 무한 루프가 됩니다. 그러나 조건부 타입의 <strong>지연 평가</strong> 성질을 이용하면 이를 타개할 수 있습니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">RecursionHelper<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> FlattendObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">:</span> <span class="token builtin">never</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name">UnwrappedObject<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span> <span class="token operator">=</span> ToIntersection<span class="token operator">&lt;</span>RecursionHelper<span class="token operator">&lt;</span>Values<span class="token operator">&lt;</span>NestedObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span><span class="token operator">&gt;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>사실 <code>T</code>가 객체가 아닌지 검사를 안 해도 되는데, 이미 <code>Values</code>가 객체만 반환하기 때문입니다. 그런데 tsc는 보수적으로 타입을 추론한다고 했죠? 즉, <code>Values</code>가 무조건 객체라는 것을 보증하지 못합니다. 그러므로 <code>extends object</code>로 명시적으로 방어를 한 것입니다.</p>`,20)),n("p",null,[s[14]||(s[14]=a("자, 이제 테스트를 해봅시다. 그런데 타입 추론의 깊이가 너무 깊다 보니, IDE가 제대로 타입을 보여주지 않습니다. 하지만 ",-1)),n("a",x,[s[11]||(s[11]=a("Matt Pocock (",-1)),e(o,{icon:"fa-brands fa-x-twitter"}),s[12]||(s[12]=n("code",null,"mattpocockuk",-1)),s[13]||(s[13]=a(")",-1))]),s[15]||(s[15]=a("이 고안한 ",-1)),s[16]||(s[16]=n("code",null,"Roll",-1)),s[17]||(s[17]=a("이라는 핵을 쓰면, 못생긴 타입을 펼쳐서 보여준다고 합니다. 아마 tsc의 힌터 내부 구현을 고려한 것 같습니다.",-1))]),s[28]||(s[28]=d(`<div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name">Roll<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">X</span></span> <span class="token operator">=</span> Roll<span class="token operator">&lt;</span>FlattendObject<span class="token operator">&lt;</span><span class="token punctuation">{</span>  </span>
<span class="line">  a<span class="token operator">:</span> <span class="token string">&#39;a&#39;</span></span>
<span class="line">  b<span class="token operator">:</span> <span class="token keyword">null</span></span>
<span class="line">  c<span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">    d<span class="token operator">:</span> <span class="token string">&#39;d&#39;</span><span class="token punctuation">,</span></span>
<span class="line">    e<span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">      f<span class="token operator">:</span> <span class="token number">0</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">    g<span class="token operator">:</span> <span class="token keyword">null</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token operator">&gt;&gt;</span></span>
<span class="line"><span class="token comment">/*</span>
<span class="line">  type X = {</span>
<span class="line">    a: &quot;a&quot;;</span>
<span class="line">    b: null;</span>
<span class="line">    d: &quot;d&quot;;</span>
<span class="line">    g: null;</span>
<span class="line">    f: 0;</span>
<span class="line">  }</span>
<span class="line">*/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이제 이 핵을 함수에 추가하면 됩니다. <code>result</code>는 중간 과정을 위해서 쓰이는 구현에 관련된 값이므로 굳이 정밀하게 추론할 필요는 없습니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">flattenObject</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> object<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> result<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> FlattendObject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,3)),n("p",null,[s[19]||(s[19]=a("전체 코드는 ",-1)),n("a",B,[e(o,{icon:"iconfont icon-typescript"}),s[18]||(s[18]=a("TypeScript: TS Playground",-1))]),s[20]||(s[20]=a("에서 확인할 수 있습니다.",-1))]),s[29]||(s[29]=n("hr",null,null,-1)),s[30]||(s[30]=n("h2",{id:"마치며",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#마치며"},[n("span",null,"마치며")])],-1)),s[31]||(s[31]=n("p",null,"굳이 이렇게까지 정밀한 타입 추론을 사용해야만 하는가 하는 의문을 느낄 수 있습니다. 저도 어느 정도는 동의합니다. 고급 타입 추론은 진입 장벽이 높기 때문에, 모든 팀원이 TS에 통달하지 않았다면 오히려 협업을 방해할 수도 있겠습니다. 실무에서 푸는 대부분의 문제는 이렇게 복잡하지도 않고요. 하지만 꼭 대다수의 실무에 직접적인 도움을 주지 않는다고 해서 쓸모없는 지식은 아닙니다. 웹 개발자가 시스템 개발을 하지 않지만 메모리 구조에 대한 이해가 필요하듯이요.",-1)),n("p",null,[s[22]||(s[22]=a("오픈소스 라이브러리를 개발하는 개발자로서 타입에 대한 전문성은 필수불가결합니다. 실제로 저는 라이브러리 개발 도중, 위에서 풀어본 문제를 능가하는 난이도의 타입을 다룬 적도 있습니다. 이 모든 것은 지적인 현학성을 추구하기 위함도, ",-1)),n("a",F,[e(o,{icon:"fas fa-globe"}),s[21]||(s[21]=a("아무도 읽지 못하는 무기를 개발하기 위함",-1))]),s[23]||(s[23]=a("도 아닙니다. 그저 라이브러리의 사용성을 증대시키고 더 나은 도구를 만들기 위함입니다.",-1))]),n("div",O,[s[24]||(s[24]=n("p",{class:"hint-container-title"},[n("strong",null,"infer, never만 보면 두려워지는 당신을 위한 타입 추론"),a(" 시리즈")],-1)),e(p,l(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론",link:"/d2.naver.com/9283310.md",logo:"/assets/image/d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16),e(p,l(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 고급 타입 추론 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 고급 타입 추론",link:"/d2.naver.com/3713986.md",logo:"/assets/image/d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16),e(p,l(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제",link:"/d2.naver.com/5088940.md",logo:"/assets/image/d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16)]),b(" TODO: add ARTICLE CARD "),e(p,l(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제",link:"https://chanhi2000.github.io/bookshelf/d2.naver.com/5088940.html",logo:"https://d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16)])}const E=m(h,[["render",V]]),U=JSON.parse('{"path":"/d2.naver.com/5088940.html","title":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제","description":"Article(s) > infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제","icon":"iconfont icon-typescript","category":["Node.js","TypeScript","Article(s)"],"tag":["blog","d2.naver.com","node","nodejs","node-js","ts","typescript"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제\\",\\"image\\":[\\"https://chanhi2000.github.io/bookshelf/assets/image/d2.naver.com/5088940/banner.png\\"],\\"datePublished\\":\\"2024-07-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"권세규\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/d2.naver.com/5088940.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제"}],["meta",{"property":"og:description","content":"Article(s) > infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://chanhi2000.github.io/bookshelf/assets/image/d2.naver.com/5088940/banner.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://chanhi2000.github.io/bookshelf/assets/image/d2.naver.com/5088940/banner.png"}],["meta",{"name":"twitter:image:alt","content":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제"}],["meta",{"property":"article:author","content":"권세규"}],["meta",{"property":"article:tag","content":"typescript"}],["meta",{"property":"article:tag","content":"ts"}],["meta",{"property":"article:tag","content":"node-js"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:tag","content":"d2.naver.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-07-04T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제"},{"property":"og:description","content":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/d2.naver.com/5088940.html"}]],"prev":"/programming/ts/articles/README.md","date":"2024-07-04T00:00:00.000Z","isOriginal":false,"author":"권세규","cover":"/assets/image/d2.naver.com/5088940/banner.png"},"git":{},"readingTime":{"minutes":2.87,"words":862},"filePathRelative":"d2.naver.com/5088940.md","copyright":{"author":"권세규"}}');export{E as comp,U as data};
