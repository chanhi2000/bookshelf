import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,d as n,f as o,b as r,t as g,n as c,g as d,w as i,e as t,r as u,o as b}from"./app-BVguHYKu.js";const f={},y={id:"frontmatter-title-관련",tabindex:"-1"},k={class:"header-anchor",href:"#frontmatter-title-관련"},v={class:"table-of-contents"},w={href:"https://github.com/opencontainers/runtime-spec",target:"_blank",rel:"noopener noreferrer"},I={href:"https://github.com/opencontainers/distribution-spec",target:"_blank",rel:"noopener noreferrer"},D={href:"https://github.com/opencontainers/image-spec",target:"_blank",rel:"noopener noreferrer"},C={class:"hint-container details"};function T(p,e){const l=u("VPCard"),a=u("router-link"),s=u("VPIcon");return b(),h("div",null,[n("h1",y,[n("a",k,[n("span",null,g(p.$frontmatter.title)+" 관련",1)])]),o(l,c(d({title:"Podman > Article(s)",desc:"Article(s)",link:"/devops/podman/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),o(l,c(d({title:"Docker > Article(s)",desc:"Article(s)",link:"/devops/docker/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",v,[n("ul",null,[n("li",null,[o(a,{to:"#why-not-use-docker-though"},{default:i(()=>e[0]||(e[0]=[t("Why Not Use Docker, Though?")])),_:1,__:[0]})]),n("li",null,[o(a,{to:"#container-engines"},{default:i(()=>e[1]||(e[1]=[t("Container Engines")])),_:1,__:[1]})]),n("li",null,[o(a,{to:"#building-images"},{default:i(()=>e[2]||(e[2]=[t("Building Images")])),_:1,__:[2]})]),n("li",null,[o(a,{to:"#container-runtime"},{default:i(()=>e[3]||(e[3]=[t("Container Runtime")])),_:1,__:[3]})]),n("li",null,[o(a,{to:"#image-inspection-and-distribution"},{default:i(()=>e[4]||(e[4]=[t("Image Inspection and Distribution")])),_:1,__:[4]})]),n("li",null,[o(a,{to:"#conclusion"},{default:i(()=>e[5]||(e[5]=[t("Conclusion")])),_:1,__:[5]})]),n("li",null,[o(a,{to:"#resources"},{default:i(()=>e[6]||(e[6]=[t("Resources")])),_:1,__:[6]})])])]),e[18]||(e[18]=n("hr",null,null,-1)),o(l,c(d({title:"You Don't Have to Use Docker Anymore",desc:"Docker is not the only containerization tool out there and there might just be better alternatives…",link:"https://towardsdatascience.com/its-time-to-say-goodbye-to-docker-5cfec8eff833",logo:"https://cdn-images-1.medium.com/fit/c/128/128/1*VzTUkfeGymHP4Bvav-T-lA.png",background:"rgba(53,88,118,0.2)"})),null,16),e[19]||(e[19]=r('<p>In the ancient times of containers (really more like 4 years ago) <em>Docker</em> was the only player in the container game. That&#39;s not the case anymore though and Docker is not <em>the only</em>, but rather <em>just another</em> container engine on the landscape. Docker allows us to build, run, pull, push or inspect container images, but for each of these tasks there are other alternative tools, which might just do better job at it than Docker. So, let&#39;s explore the landscape and (just <em>maybe</em>) uninstall and forget about Docker altogether…</p><hr><h2 id="why-not-use-docker-though" tabindex="-1"><a class="header-anchor" href="#why-not-use-docker-though"><span>Why Not Use Docker, Though?</span></a></h2><p>If you&#39;ve been a docker user for long time, I think it will take some persuading for you to even consider to switch to different tooling. So, here goes:</p><p>First of all, Docker is a monolithic tool. It&#39;s a tool that tries to do everything, which generally is not the best approach. Most of the time it&#39;s better to choose a specialized tool that does just one thing, but does it really well.</p>',5)),n("p",null,[e[10]||(e[10]=t("If you are scared of switching to different set of tools, because you would have to learn to work with different CLI, different API or in general different concepts, then that won't be a problem. Choosing any of the tools shown in this article can be completely seamless as they all (including Docker) adhere to same specification under OCI, which is short for ")),e[11]||(e[11]=n("a",{href:"https://opencontainers.org",target:"_blank",rel:"noopener noreferrer"},"Open Container Initiative",-1)),e[12]||(e[12]=t(". This initiative contains specifications for ")),n("a",w,[o(s,{icon:"iconfont icon-github"}),e[7]||(e[7]=n("code",null,"opencontainers/runtime-spec",-1))]),e[13]||(e[13]=t(", ")),n("a",I,[o(s,{icon:"iconfont icon-github"}),e[8]||(e[8]=n("code",null,"opencontainers/distribution-spec",-1))]),e[14]||(e[14]=t(" and ")),n("a",D,[o(s,{icon:"iconfont icon-github"}),e[9]||(e[9]=n("code",null,"opencontainers/image-spec",-1))]),e[15]||(e[15]=t(", which covers all the features needed for working with containers."))]),e[20]||(e[20]=r('<p>Thanks to the OCI you can choose a set of tools that best suit your needs and at the same time you can still enjoy using the same APIs and same CLI commands as with Docker.</p><p>So, if you&#39;re open to trying out new tools, then let&#39;s compare the advantages, disadvantages and features of Docker and it&#39;s competitors to see whether it actually makes sense to even consider ditching Docker for some new shiny tool.</p><hr><h2 id="container-engines" tabindex="-1"><a class="header-anchor" href="#container-engines"><span>Container Engines</span></a></h2><p>When comparing Docker with any other tool we need to break it down by its components and first thing we should talk about are <em>container engines</em>. <s>Container engine is a tool that provides user interface for working with images and containers so that you don&#39;t have to mess with things like <code>SECCOMP</code> rules or SELinux policies.</s> Its job is also to pull images from remote repositories and expand them to your disk. It also <em>seemingly</em> runs the containers, but in reality its job is to create container manifest and directory with image layers. It then passes them to <em>container runtime</em> like <code>runc</code> or <code>crun</code> (which we will talk about little later).</p><p>There are many container engines available, but the most prominent competitor to Docker is <em>Podman</em>, developed by <em>Red Hat</em>. Unlike Docker, Podman doesn&#39;t need daemon to run and also doesn&#39;t need root privileges which has been long-standing concern with Docker. Based on the name, Podman can not only run containers, but also <em>pods</em>. In case you are not familiar with concept of pods, then pod is the smallest compute unit for Kubernetes. It consists of one or more containers — the main one and so-called <em>sidecars</em> — that perform supporting tasks. This makes it easier for Podman users to later migrate their workloads to Kubernetes. So, as a simple demonstration, this is how you would run 2 containers in a single pod:</p>',6)),n("details",C,[n("summary",null,[o(s,{icon:"fas fa-terminal"}),e[16]||(e[16]=t("podman.sh"))]),e[17]||(e[17]=r(`<div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">podman</span> pod create <span class="token parameter variable">--name</span> mypod</span>
<span class="line"><span class="token function">podman</span> pod list</span>
<span class="line"><span class="token comment">#</span></span>
<span class="line"><span class="token comment"># POD ID         NAME    STATUS    CREATED         # OF CONTAINERS   INFRA ID</span></span>
<span class="line"><span class="token comment"># 211eaecd307b   mypod   Running   2 minutes ago   1                 a901868616a5</span></span>
<span class="line"></span>
<span class="line"><span class="token function">podman</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--pod</span> mypod nginx  <span class="token comment"># First container</span></span>
<span class="line"><span class="token function">podman</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--pod</span> mypod nginx  <span class="token comment"># Second container</span></span>
<span class="line"><span class="token function">podman</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">--pod</span></span>
<span class="line"><span class="token comment"># </span></span>
<span class="line"><span class="token comment"># CONTAINER ID  IMAGE                           COMMAND               CREATED        STATUS            PORTS  NAMES               POD           POD NAME</span></span>
<span class="line"><span class="token comment"># 3b27d9eaa35c  docker.io/library/nginx:latest  nginx -g daemon o...  2 seconds ago  Up 1 second ago          brave_ritchie       211eaecd307b  mypod</span></span>
<span class="line"><span class="token comment"># d638ac011412  docker.io/library/nginx:latest  nginx -g daemon o...  5 minutes ago  Up 5 minutes ago         cool_albattani      211eaecd307b  mypod</span></span>
<span class="line"><span class="token comment"># a901868616a5  k8s.gcr.io/pause:3.2          </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1))]),e[21]||(e[21]=r(`<p>Finally, Podman provides the exact same CLI commands as Docker so you can just do <code>alias docker=podman</code> and pretend that nothing changed.</p><p>There are other container engines besides Docker and Podman, but I would consider all of them a dead-end tech or not a suitable option for local development and usage. But to have a complete picture, let&#39;s at least mention what&#39;s out there:</p><ul><li><a href="https://linuxcontainers.org/lxd/introduction" target="_blank" rel="noopener noreferrer">LXD</a> — LXD is container manager (daemon) for LXC (Linux Containers). This tool offers ability to run <em>system</em> containers that provide container environment that is more similar to VMs. It sits in very narrow space and doesn&#39;t have many users, so unless you have very specific use case, then you&#39;re probably better off using Docker or Podman.</li><li><a href="https://cri-o.io" target="_blank" rel="noopener noreferrer">CRI-O</a> — When you google what is cri-o, you might find it described as container engine. It really is container runtime, though. Apart from the fact that it isn&#39;t actually an engine, it also is not suitable for <em>“normal”</em> use. And by that I mean that it was specifically built to be used as Kubernetes runtime (CRI) and not for an end-user usage.</li><li><a href="https://coreos.com/rkt" target="_blank" rel="noopener noreferrer">rkt</a> — rkt (<em>“rocket”</em>) is container engine developed by <em>CoreOS</em>. This project is mentioned here really just for completeness, because the project ended and its development was halted — and therefore it should not be used.</li></ul><hr><h2 id="building-images" tabindex="-1"><a class="header-anchor" href="#building-images"><span>Building Images</span></a></h2><p>With container engines there was really only one alternative to Docker. When it comes to building images though, we have many more options to choose from.</p><p>First, let me introduce <a href="https://buildah.io" target="_blank" rel="noopener noreferrer">Buildah</a>. Buildah is another tool developed by Red Hat and it plays very nicely with Podman. If you already installed Podman, you might have even noticed the <code>podman build</code> subcommand, which is really just Buildah in disguise, as its binary is included in Podman.</p><p>As for its features, it follows same route as Podman — it&#39;s daemonless and rootless and produces OCI compliant images, so it&#39;s guaranteed that your images will run the same way as the ones built with Docker. It&#39;s also able to build images from <code>Dockerfile</code> or (more suitably named) <code>Containerfile</code> which is the same thing with different name. Apart from that, Buildah also provides finer control over image layers, allowing you to commit many changes into single layer. One unexpected but (in my opinion) nice difference from Docker is that images built by Buildah are user specific, so you will be able to list only images you built yourself.</p><p>Now, considering that Buildah is already included in Podman CLI, you might be asking why even use the separate <code>buildah</code> CLI? Well, the <code>buildah</code> CLI is superset of commands included in <code>podman build</code>, so you might not need to ever touch the <code>buildah</code> CLI, but by using it you might also discover some extra useful features (For specifics about differences between <code>podman build</code> and <code>buildah</code> see following <a href="https://podman.io/blogs/2018/10/31/podman-buildah-relationship.html" target="_blank" rel="noopener noreferrer">article</a>).</p><p>With that said, let&#39;s see a little demonstration:</p><details class="hint-container details"><summary>buildah.sh</summary><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">~ $ buildah bud <span class="token parameter variable">-f</span> Dockerfile <span class="token builtin class-name">.</span></span>
<span class="line"></span>
<span class="line">~ $ buildah from alpine:latest  <span class="token comment"># Create starting container - equivalent to &quot;FROM alpine:latest&quot;</span></span>
<span class="line">Getting image <span class="token builtin class-name">source</span> signatures</span>
<span class="line">Copying blob df20fa9351a1 <span class="token keyword">done</span>  </span>
<span class="line">Copying config a24bb40132 <span class="token keyword">done</span>  </span>
<span class="line">Writing manifest to image destination</span>
<span class="line">Storing signatures</span>
<span class="line">alpine-working-container  <span class="token comment"># Name of the temporary container</span></span>
<span class="line">~ $ buildah run alpine-working-container -- apk <span class="token function">add</span> <span class="token parameter variable">--update</span> --no-cache python3  <span class="token comment"># equivalent to &quot;RUN apk add --update --no-cache python3&quot;</span></span>
<span class="line">fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/main/x86_64/APKINDEX.tar.gz</span>
<span class="line">fetch http://dl-cdn.alpinelinux.org/alpine/v3.12/community/x86_64/APKINDEX.tar.gz</span>
<span class="line"><span class="token punctuation">..</span>.</span>
<span class="line"></span>
<span class="line">~ $ buildah commit alpine-working-container my-final-image  <span class="token comment"># Create final image</span></span>
<span class="line">Getting image <span class="token builtin class-name">source</span> signatures</span>
<span class="line">Copying blob 50644c29ef5a skipped: already exists  </span>
<span class="line">Copying blob 362b9ae56246 <span class="token keyword">done</span>  </span>
<span class="line">Copying config 1ff90ec2e2 <span class="token keyword">done</span>  </span>
<span class="line">Writing manifest to image destination</span>
<span class="line">Storing signatures</span>
<span class="line">1ff90ec2e26e7c0a6b45b2c62901956d0eda138fa6093d8cbb29a88f6b95124c</span>
<span class="line"></span>
<span class="line">~ <span class="token comment"># buildah images</span></span>
<span class="line">REPOSITORY               TAG     IMAGE ID      CREATED         SIZE</span>
<span class="line">localhost/my-final-image latest  1ff90ec2e26e  <span class="token number">22</span> seconds ago  <span class="token number">51.4</span> MB</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>From the above script you can see that you can build images simply using <code>buildah bud</code>, where <code>bud</code> stands for <em>build using Dockerfile</em>, but you can also use more scripted approach using Buildahs <code>from</code>, <code>run</code> and <code>copy</code>, which are equivalent commands to the commands in Dockerfile ( <code>FROM image</code>, <code>RUN ...</code>, <code>COPY ...</code>).</p><p>Next up is Google&#39;s <a href="https://github.com/GoogleContainerTools/kaniko" target="_blank" rel="noopener noreferrer">Kaniko</a>. Kaniko also builds container images from Dockerfile and similarly to Buildah, it also doesn&#39;t need a daemon. The major difference from Buildah is that Kaniko is more focused on building images in Kubernetes.</p><p>Kaniko is meant to be run as an image, using <code>gcr.io/kaniko-project/executor</code>, which makes sense for Kubernetes, but isn&#39;t very convenient for local builds and kind of defeats the purpose as you would need to use Docker to run Kaniko image to build your images. That being said, if you are looking for tool for building images in your Kubernetes cluster (e.g. in CI/CD pipeline), then Kaniko might be a good option, considering that it&#39;s daemonless and (<a href="https://github.com/GoogleContainerTools/kaniko#security" target="_blank" rel="noopener noreferrer">maybe</a>) more secure.</p><p>From my personal experience though — I used both Kaniko and Buildah to build images in Kubernetes/OpenShift clusters and I think both will do the job just fine, but with Kaniko I&#39;ve seen some random build crashes and fails when pushing images to registry.</p><p>The third contender here is <a href="https://github.com/moby/buildkit" target="_blank" rel="noopener noreferrer">buildkit</a>, which could be also called <em>the next-generation</em> <code>docker build</code>. It&#39;s part of <em>Moby</em> project (as is Docker) and can be enabled with Docker as an experimental feature using <code>DOCKER_BUILDKIT=1 docker build ...</code>. Well, but what exactly will this bring to you? It introduces bunch of improvements and cool features including parallel build steps, skipping unused stages, better incremental builds and rootless builds. On the other hand however, it still requires daemon to run ( <code>buildkitd</code>). So, if you don&#39;t want to get rid of Docker, but want some new features and nice improvements, then using buildkit might be the way to go.</p><p>As in the previous section, here we also have a few <em>“honorable mentions”</em> which fill some very specific use cases and wouldn&#39;t be one of my top choices:</p><ul><li><a href="https://github.com/openshift/source-to-image" target="_blank" rel="noopener noreferrer">Source-To-Image (S2I)</a> is a toolkit for building images directly from source code without Dockerfile. This tool works well for simple, expected scenarios and workflows but quickly becomes annoying and clumsy if you need little too much customization or if your project doesn&#39;t have the expected layout. You might consider using S2I if you are not very confident with Docker yet or if you build your images on OpenShift cluster, as builds with S2I are a built-in feature.</li><li><a href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener noreferrer">Jib</a> is another tool by Google, specifically for building Java images. It includes <a href="https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin#quickstart" target="_blank" rel="noopener noreferrer">Maven</a> and <a href="https://github.com/GoogleContainerTools/jib/tree/master/jib-gradle-plugin#quickstart" target="_blank" rel="noopener noreferrer">Gradle</a> plugins, which can make it easy for you to build images without messing with Dockerfiles.</li><li>Last but not least is <a href="https://github.com/bazelbuild/bazel" target="_blank" rel="noopener noreferrer">Bazel</a>, which is anoooother tool by Google. This one is not <em>just</em> for building container images, but rather a complete build system. If you just want to build an image, then diving into Bazel might be a bit of an overkill, but definitely a good learning experience, so if you&#39;re up for it, then <a href="https://github.com/bazelbuild/rules_docker" target="_blank" rel="noopener noreferrer">rules_docker</a> section is a good starting point for you.</li></ul><hr><h2 id="container-runtime" tabindex="-1"><a class="header-anchor" href="#container-runtime"><span>Container Runtime</span></a></h2><p>Last big piece of a puzzle is <em>container runtime</em> which is responsible for, well, running containers. Container runtime is one part of the whole container lifecycle/stack, which you will most likely not going to mess with, unless you have some very specific requirement for speed, security, etc. So, if you&#39;re tired of me already, then you might want skip this one section. If on the other hand, you just want to know what are the options, then here goes:</p><p><a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener noreferrer">runc</a> is the most popular container runtime created based on OCI container runtime specification. It&#39;s used by Docker (through <em>containerd</em>), Podman and CRI-O, so pretty much everything expect for LXD (which uses LXC). There&#39;s not much else I can add. It&#39;s default for (almost) everything, so even if you ditch Docker after reading this article, you will most likely still use runc.</p><p>One alternative to runc is similarly (and confusingly) named <a href="https://github.com/containers/crun" target="_blank" rel="noopener noreferrer">crun</a>. This is tool developed by Red Hat and fully written in C (runc is written in Go). This makes it much faster and more memory efficient than runc. Considering that it&#39;s also OCI compliant runtime, you should be able switch to it easily enough, if you want to check for yourself. Even though it&#39;s not very popular right now, it will be in tech preview as an alternative OCI runtime as of the RHEL 8.3 release and considering that it&#39;s Red Hat product we might eventually see as default for Podman or CRI-O.</p><p>Speaking of CRI-O. Earlier I said that CRI-O isn&#39;t really a container engine, but rather container runtime. That&#39;s because CRI-O doesn&#39;t include features like pushing images, which is what you would expect from container engine. CRI-O as a runtime uses runc internally to run containers. This runtime is not the one you should try using on your machine, as it&#39;s built to be used as runtime on Kubernetes nodes and you can see it described as <em>“all the runtime Kubernetes needs and nothing more”</em>. So, unless you are setting up Kubernetes cluster (or OpenShift cluster — CRI-O is default there already), then you probably should not touch this one.</p><p>Last one for this section is <a href="https://containerd.io" target="_blank" rel="noopener noreferrer">containerd</a>, which is a CNCF graduating project. It&#39;s a daemon that acts as an API facade for various container runtimes and OS. In the background it relies on runc and it&#39;s the default runtime for Docker engine. It&#39;s also used by Google Kubernetes Engine (GKE) and IBM Kubernetes Service (IKS). It&#39;s an implementation of Kubernetes Container Runtime Interface (same as CRI-O), therefore it&#39;s a good candidate for runtime of your Kubernetes cluster.</p><hr><h2 id="image-inspection-and-distribution" tabindex="-1"><a class="header-anchor" href="#image-inspection-and-distribution"><span>Image Inspection and Distribution</span></a></h2><p>Last part of container stack is image inspection and distribution. This effectively replaces <code>docker inspect</code> and also (optionally) adds ability to copy/mirror images between remote registries.</p><p>The only tool which I will mention here that can do these tasks is <a href="https://github.com/containers/skopeo" target="_blank" rel="noopener noreferrer">Skopeo</a>. It&#39;s made by Red Hat and it&#39;s an accompanying tool for Buildah, Podman and CRI-O. Apart from the basic <code>skopeo inspect</code> which we all know from Docker, Skopeo is also able to copy images using <code>skopeo copy</code> which allows you to mirror images between remote registries without first pulling them to local registry. This feature can also act as pull/push if you use local registry.</p><p>As a little bonus, I want to also mention <a href="https://github.com/wagoodman/dive" target="_blank" rel="noopener noreferrer">Dive</a>, which is a tool for inspecting, exploring and analyzing images. It&#39;s little more user friendly, provides more readable output and can dig (or <em>dive</em>, I guess) a bit deeper into your image and analyze and measure its efficiency. It&#39;s also suitable for use in CI pipelines, where it can measure whether your image is <em>“efficient enough”</em> or in other words — whether it wastes too much space or not.</p><hr><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>This article wasn&#39;t meant to persuade you to completely ditch Docker, rather its goal was to show you the whole landscape and all the options for building, running, managing and distributing containers and their images. Each of these tools including Docker, has its pros and cons and it&#39;s important to evaluate what set of tools suits your workflow and use case the best and I hope this article will help you with that.</p><hr><h2 id="resources" tabindex="-1"><a class="header-anchor" href="#resources"><span>Resources</span></a></h2><ul><li><a href="https://youtu.be/FKoVztEQHss" target="_blank" rel="noopener noreferrer">Let&#39;s Try Every CRI Runtime Available for Kubernetes. No, Really!</a></li><li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/11/How-Container-Runtime-Matters-in-Kubernetes_-OSS-Kunal-Kushwaha.pdf" target="_blank" rel="noopener noreferrer">How Container Runtimes matter in Kubernetes?</a></li><li><a href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction" target="_blank" rel="noopener noreferrer">A Practical Introduction to Container Terminology</a></li><li><a href="https://events19.linuxfoundation.org/wp-content/uploads/2017/11/Comparing-Next-Generation-Container-Image-Building-Tools-OSS-Akihiro-Suda.pdf" target="_blank" rel="noopener noreferrer">Comparing Next-Generation Container Image Building Tools</a></li><li><a href="https://www.capitalone.com/tech/cloud/container-runtime" target="_blank" rel="noopener noreferrer">A Comprehensive Container Runtime Comparison</a></li><li><a href="https://blog.alexellis.io/building-containers-without-docker" target="_blank" rel="noopener noreferrer">Building containers without Docker</a></li></ul>`,36))])}const R=m(f,[["render",T]]),_=JSON.parse(`{"path":"/towardsdatascience.com/you-dont-have-to-use-docker-anymore.html","title":"You Don't Have to Use Docker Anymore","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"You Don't Have to Use Docker Anymore","description":"Article(s) > You Don't Have to Use Docker Anymore","icon":"iconfont icon-podman","category":["Podman","Article(s)"],"tag":["blog","towardsdatascience.com","opinion","martin-heinz","docker","devops","podman"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"You Don't Have to Use Docker Anymore\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-10-15T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/towardsdatascience.com/you-dont-have-to-use-docker-anymore.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"You Don't Have to Use Docker Anymore"}],["meta",{"property":"og:description","content":"Article(s) > You Don't Have to Use Docker Anymore"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"podman"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"martin-heinz"}],["meta",{"property":"article:tag","content":"opinion"}],["meta",{"property":"article:tag","content":"towardsdatascience.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2020-10-15T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > You Don't Have to Use Docker Anymore"},{"property":"og:description","content":"You Don't Have to Use Docker Anymore"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/towardsdatascience.com/you-dont-have-to-use-docker-anymore.html"}]],"prev":"/devops/podman/articles/README.md","date":"2020-10-15T00:00:00.000Z","isOriginal":false},"git":{},"readingTime":{"minutes":9.77,"words":2930},"filePathRelative":"towardsdatascience.com/you-dont-have-to-use-docker-anymore.md"}`);export{R as comp,_ as data};
