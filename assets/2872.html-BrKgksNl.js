import{_ as g}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as m,d as t,f as o,b as p,a as u,t as y,n as d,g as c,w as i,e as a,r,o as w}from"./app-BVguHYKu.js";const k={},b={id:"frontmatter-title-관련",tabindex:"-1"},z={class:"header-anchor",href:"#frontmatter-title-관련"},_={class:"table-of-contents"},x={href:"https://codspeed.io/blog/state-of-python-3-13-performance-free-threading",target:"_blank",rel:"noopener noreferrer"},I={class:"hint-container info"};function P(h,e){const s=r("VPCard"),n=r("router-link"),l=r("SiteInfo"),f=r("VPIcon");return w(),m("div",null,[t("h1",b,[t("a",z,[t("span",null,y(h.$frontmatter.title)+" 관련",1)])]),o(s,d(c({title:"Python > Article(s)",desc:"Article(s)",link:"/programming/py/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",_,[t("ul",null,[t("li",null,[o(n,{to:"#free-threaded-파이썬-소개"},{default:i(()=>e[0]||(e[0]=[a("Free-threaded 파이썬 소개")])),_:1,__:[0]}),t("ul",null,[t("li",null,[o(n,{to:"#기존의-멀티프로세싱-우회-방안"},{default:i(()=>e[1]||(e[1]=[a("기존의 멀티프로세싱 우회 방안")])),_:1,__:[1]})])])]),t("li",null,[o(n,{to:"#실제-활용-사례-pagerank-구현"},{default:i(()=>e[2]||(e[2]=[a("실제 활용 사례: PageRank 구현")])),_:1,__:[2]})]),t("li",null,[o(n,{to:"#다양한-동시성-모델을-통한-구현"},{default:i(()=>e[3]||(e[3]=[a("다양한 동시성 모델을 통한 구현")])),_:1,__:[3]}),t("ul",null,[t("li",null,[o(n,{to:"#기본-구현-단일-스레드"},{default:i(()=>e[4]||(e[4]=[a("기본 구현 (단일 스레드)")])),_:1,__:[4]})]),t("li",null,[o(n,{to:"#멀티스레드-구현"},{default:i(()=>e[5]||(e[5]=[a("멀티스레드 구현")])),_:1,__:[5]})]),t("li",null,[o(n,{to:"#멀티프로세스-구현"},{default:i(()=>e[6]||(e[6]=[a("멀티프로세스 구현")])),_:1,__:[6]})])])]),t("li",null,[o(n,{to:"#성능-측정"},{default:i(()=>e[7]||(e[7]=[a("성능 측정")])),_:1,__:[7]}),t("ul",null,[t("li",null,[o(n,{to:"#테스트-데이터-생성"},{default:i(()=>e[8]||(e[8]=[a("테스트 데이터 생성")])),_:1,__:[8]})]),t("li",null,[o(n,{to:"#벤치마크-케이스-정의"},{default:i(()=>e[9]||(e[9]=[a("벤치마크 케이스 정의")])),_:1,__:[9]})])])]),t("li",null,[o(n,{to:"#깃허브-액션-워크플로우-설정"},{default:i(()=>e[10]||(e[10]=[a("깃허브 액션 워크플로우 설정")])),_:1,__:[10]})]),t("li",null,[o(n,{to:"#성능-측정-결과는"},{default:i(()=>e[11]||(e[11]=[a("성능 측정 결과는?")])),_:1,__:[11]}),t("ul",null,[t("li",null,[o(n,{to:"#분석-결과"},{default:i(()=>e[12]||(e[12]=[a("분석 결과")])),_:1,__:[12]})]),t("li",null,[o(n,{to:"#참고-사항"},{default:i(()=>e[13]||(e[13]=[a("참고 사항")])),_:1,__:[13]})])])])])]),e[18]||(e[18]=t("hr",null,null,-1)),o(l,{name:"파이썬 3.13 성능 향상 완전 정복: Free-Threading",desc:"지난 10월에 출시된 파이썬 3.13은 최근 릴리스 중에서도 성능 향상에 가장 큰 중점을 둔 버전입니다. 릴리스 노트를 살펴보면 성능에 큰 영향을 미칠 수 있는 주요 변경 사항들이 눈에 띕니다. 이 글에서는 free-threaded 모드를 중점적으로 살펴보고, 이러한 변화가 파이썬 애플리케이션의 성능에 미치는 영향을 측정해 볼 예정입니다.",url:"https://yozm.wishket.com/magazine/detail/2872/",logo:"https://yozm.wishket.com/favicon.ico",preview:"https://yozm.wishket.com/media/news/2872/cover.webp"}),t("p",null,[e[15]||(e[15]=a("본문은 요즘IT와 번역가 David가 함께 아서 파스텔(Arthur Pastel)의 글 <")),t("a",x,[o(f,{icon:"fas fa-globe"}),e[14]||(e[14]=a("State of Python 3.13 Performance: Free-Threading"))]),e[16]||(e[16]=a(">을 번역한 글입니다. 필자는 파리에서 활동하는 Python 개발자이자, 오픈소스 애호가로 MongoDB를 위한 ODMantic을 개발했습니다. 현재는 CI 파이프라인에서 성능 문제를 예방하는 솔루션 ‘CodSpeed’의 창업자로 활동하고 있습니다. 이 글에서는 파이썬 3.13에서의 주요 성능 변화와 ‘Free-threading’ 기능을 소개합니다."))]),e[19]||(e[19]=p('<p>지난 10월에 출시된 파이썬 3.13은 최근 릴리스 중에서도 성능 향상에 가장 큰 중점을 둔 버전입니다. 릴리스 노트를 살펴보면 성능에 큰 영향을 미칠 수 있는 주요 변경 사항들이 눈에 띕니다.</p><ul><li>파이썬이 이제 전역 인터프리터 잠금(GIL<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>)을 비활성화한 <strong>free-threaded 모드</strong>로 실행 가능합니다.</li><li>완전히 새로운 <strong>just-in-time</strong>(JIT<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>) 컴파일러가 추가되었습니다.</li><li>파이썬이 이제 기본적으로 <code>mimalloc</code><sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup> 할당자를 포함하고 있습니다.</li></ul><blockquote><p><strong>malloc</strong>: 프로그램 실행 중에 필요한 메모리를 동적으로 할당받는 C 언어의 기본 메모리 할당 함수</p></blockquote><p>이 글에서는 free-threaded 모드를 중점적으로 살펴보고, 이러한 변화가 파이썬 애플리케이션의 성능에 미치는 영향을 측정해 볼 예정입니다.</p><hr><h2 id="free-threaded-파이썬-소개" tabindex="-1"><a class="header-anchor" href="#free-threaded-파이썬-소개"><span>Free-threaded 파이썬 소개</span></a></h2><p>Free-threading은 파이썬 3.13에서 도입된 실험적 기능으로, 파이썬이 전역 인터프리터 잠금(GIL) 없이 실행될 수 있도록 하는 기능입니다. GIL은 여러 스레드가 동시에 파이썬 바이트코드를 실행하는 것을 막는 상호 배제(mutex) 장치입니다. 이러한 설계는 파이썬의 메모리 관리를 단순화하고, C API 사용을 쉽게 만들어주었지만, 현대의 멀티코어 프로세서를 효과적으로 활용하는 데 있어 가장 큰 장애물 중 하나로 작용해 왔습니다.</p><h3 id="기존의-멀티프로세싱-우회-방안" tabindex="-1"><a class="header-anchor" href="#기존의-멀티프로세싱-우회-방안"><span>기존의 멀티프로세싱 우회 방안</span></a></h3><p>전통적으로는 <code>multiprocessing</code> 모듈을 사용하여 이 문제를 해결해 왔습니다. 이 모듈은 스레드 대신 별도의 파이썬 프로세스를 생성하는 방식을 사용합니다. 이러한 접근 방식이 동작은 하지만, 다음과 같은 중요한 제약 사항들이 있습니다.</p><ol><li><strong>메모리 오버헤드</strong>: 각 프로세스는 자체 파이썬 인터프리터 인스턴스와 메모리 공간을 필요로 합니다. 데이터를 많이 다루는 애플리케이션의 경우 이는 빠르게 병목 현상으로 이어질 수 있습니다.</li><li><strong>통신 비용</strong>: 프로세스들은 메모리를 직접 공유할 수 없습니다. 프로세스 간에 데이터를 주고받을 때마다 직렬화와 역직렬화 과정이 필요하며, 이는 추가적인 오버헤드와 복잡성을 야기합니다.</li><li><strong>시작 시각</strong>: 새로운 프로세스를 생성하는 것은 스레드를 생성하는 것보다 현저히 느립니다. 따라서 작업자(worker)를 자주 생성해야 하는 작업에는 실용적이지 않습니다.</li></ol><hr><h2 id="실제-활용-사례-pagerank-구현" tabindex="-1"><a class="header-anchor" href="#실제-활용-사례-pagerank-구현"><span>실제 활용 사례: PageRank 구현</span></a></h2><p>이러한 제약 사항을 실제로 확인하기 위해 PageRank 알고리즘의 구현 사례를 살펴보겠습니다. PageRank는 초기 구글의 검색 엔진을 지원했던 알고리즘으로, 다음과 같은 특성으로 인해 이상적인 예시가 됩니다.</p><ol><li>계산 집약적인 작업(행렬 연산)을 수행합니다.</li><li>대규모 데이터셋(웹 그래프)을 처리합니다.</li><li>병렬화를 통해 상당한 성능 개선을 기대할 수 있습니다.</li></ol><p>파이썬 3.12 이전 버전에서 단순한 멀티스레드 구현을 시도할 경우, 행렬 연산 과정에서 GIL로 인한 병목 현상이 발생하게 됩니다. 한편 멀티프로세싱 방식을 사용할 경우에는 다음과 같은 문제에 직면하게 됩니다.</p><ul><li>각 프로세스에 그래프를 복사하는 데 따른 메모리 오버헤드</li><li>프로세스 간 부분 결과를 전송하는 데 드는 비용</li><li>공유 상태 관리의 복잡성</li></ul><p>다음으로 다양한 동시성 모델을 통한 구현 방법을 살펴보도록 하겠습니다.</p><hr><h2 id="다양한-동시성-모델을-통한-구현" tabindex="-1"><a class="header-anchor" href="#다양한-동시성-모델을-통한-구현"><span>다양한 동시성 모델을 통한 구현</span></a></h2><h3 id="기본-구현-단일-스레드" tabindex="-1"><a class="header-anchor" href="#기본-구현-단일-스레드"><span>기본 구현 (단일 스레드)</span></a></h3><figure><img src="https://yozm.wishket.com/media/news/2872/1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이 알고리즘에서 계산 비용이 가장 많이 드는 부분은 색칠된 두 곳입니다. 첫 번째는 진입 노드들로부터의 점수 기여분을 계산하는 부분이고, 두 번째는 댐핑 팩터를 적용하여 새로운 점수를 최종 결과에 반영하는 부분입니다. 이 중에서 첫 번째 부분을 병렬화하는 것이 가장 효과적이면서도 구현하기 쉬운 방법이 될 것입니다. 범위를 분할하여 여러 스레드가 <code>new_scores</code> 배열을 효율적으로 계산할 수 있기 때문입니다.</p><h3 id="멀티스레드-구현" tabindex="-1"><a class="header-anchor" href="#멀티스레드-구현"><span>멀티스레드 구현</span></a></h3><p>멀티스레드 구현에서는 먼저 행렬을 여러 개의 청크<sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup>로 나누는 것부터 시작합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2872/2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>그런 다음 각 스레드는 행렬의 서로 다른 청크에 대해 작업을 수행하며, 새로운 점수를 갱신합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2872/3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>여기서 주목할 점은 <code>new_scores</code> 배열의 갱신이 잠금 된 상태에서 이루어진다는 것입니다. 이는 경쟁 상태를 방지하기 위한 것입니다. 잠금 상태가 오래 유지되면 병목 현상이 될 수 있지만, 실제로는 알고리즘의 첫 번째 부분을 병렬화하는 것만으로도 상당한 성능 향상을 얻을 수 있습니다.</p><p>마지막으로 각 스레드에 청크를 할당하여 처리합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2872/4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="멀티프로세스-구현" tabindex="-1"><a class="header-anchor" href="#멀티프로세스-구현"><span>멀티프로세스 구현</span></a></h3><p>멀티프로세스 구현은 기본적으로 멀티스레드 구현과 매우 유사합니다. 주요 차이점들을 살펴보겠습니다.</p><ul><li>프로세스들은 메모리를 직접 공유할 수 없기 때문에, 각 워커는 공유 <code>new_scores</code> 배열을 갱신하는 대신 <code>local_scores</code> 배열을 반환합니다. 그 후 메인 프로세스에서 로컬 점수들을 취합합니다.</li></ul><figure><img src="https://yozm.wishket.com/media/news/2872/5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이 방식은 멀티스레드 버전보다 빠를 수 있지만, 프로세스 간 통신에 따른 오버헤드가 발생합니다. 특히 대규모 데이터셋의 경우 이 오버헤드가 상당히 커질 수 있습니다.</p><ul><li><code>ThreadPoolExecutor</code> 대신 <code>multiprocessing.Pool</code>을 사용합니다. API는 매우 비슷하지만, <code>multiprocessing.Pool</code>은 스레드 대신 프로세스 풀을 생성합니다.</li></ul><figure><img src="https://yozm.wishket.com/media/news/2872/6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="성능-측정" tabindex="-1"><a class="header-anchor" href="#성능-측정"><span>성능 측정</span></a></h2><p>실제 성능 변화를 측정하기 위해 성능 테스트를 구축해 보겠습니다. 우선 테스트용 데이터를 생성하는 것부터 시작합니다.</p><h3 id="테스트-데이터-생성" tabindex="-1"><a class="header-anchor" href="#테스트-데이터-생성"><span>테스트 데이터 생성</span></a></h3><figure><img src="https://yozm.wishket.com/media/news/2872/7.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>여기서는 실행마다 동일한 결과를 보장하기 위해 고정된 시드값을 사용합니다. 이는 서로 다른 구현 방식의 성능을 비교할 때 매우 중요합니다. 페이지 간의 가짜 연결을 생성하여 현실적인 그래프를 만들고 있지만, 행렬의 크기가 동일하다면 빈 행렬을 사용하더라도 수학적 연산은 정확히 동일할 것입니다.</p><h3 id="벤치마크-케이스-정의" tabindex="-1"><a class="header-anchor" href="#벤치마크-케이스-정의"><span>벤치마크 케이스 정의</span></a></h3><p>다음으로, <code>pytest-codspeed</code>라는 <code>pytest</code> 플러그인을 사용하여 다양한 매개변수와 여러 파이썬 버전/빌드에 대한 성능을 측정해 보겠습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2872/8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>여기서는 3가지 구현 방식을 3가지 다른 그래프 크기로 테스트합니다. <code>pytest-codspeed</code>가 제공하는 <code>benchmark</code>를 사용하여, 주어진 인자로 <code>pagerank</code> 함수의 실행 시간을 측정합니다.</p><hr><h2 id="깃허브-액션-워크플로우-설정" tabindex="-1"><a class="header-anchor" href="#깃허브-액션-워크플로우-설정"><span>깃허브 액션 워크플로우 설정</span></a></h2><p>CodSpeed의 인프라에서 다양한 파이썬 빌드의 성능을 측정하기 위한 깃허브 액션 워크플로우를 작성합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2872/9.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이 설정에서는 파이썬 3.12, 3.13, 그리고 free threading 지원이 포함된 3.13에 대해 GIL을 활성화한 경우와 비활성화한 경우 모두에서 벤치마크를 실행합니다. 이를 통해 GIL이 활성화된 상태에서도 free-threading의 영향을 확인할 수 있습니다.</p><hr><h2 id="성능-측정-결과는" tabindex="-1"><a class="header-anchor" href="#성능-측정-결과는"><span>성능 측정 결과는?</span></a></h2><figure><img src="https://yozm.wishket.com/media/news/2872/pic_1__1_.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="분석-결과" tabindex="-1"><a class="header-anchor" href="#분석-결과"><span>분석 결과</span></a></h3><ul><li>새로운 빌드 옵션을 활성화하지 않은 상태에서는 <strong>3.12</strong>와 <strong>3.13</strong> 버전이 매우 유사한 성능을 보여주었습니다. 또한 <code>multiprocessing</code> 구현의 한계도 명확히 드러났는데, 프로세스 간 통신 오버헤드로 인해 오히려 단일 스레드 구현보다 더 느린 결과를 보여주었습니다.</li><li>예상대로 <strong>GIL이 비활성화된 3.13</strong>에서 <code>threading</code> 기반 구현이 가장 빠른 성능을 보여주었습니다. GIL이 더 이상 스레드의 병렬 실행을 제한하지 않게 되었기 때문입니다.</li><li>그러나 free-threaded 빌드에서는 GIL의 <strong>활성화 여부와 관계없이</strong> 다른 모든 구현에서 상당한 성능 저하가 관찰되었습니다. 이는 주로 free-threaded 빌드에서 specializing adaptive interpreter(SAI<sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup>)를 비활성화해야 하기 때문입니다. 이로 인해 다른 구현들의 성능이 눈에 띄게 감소했습니다. 이러한 오버헤드는 3.14 릴리스에서 개선될 예정입니다. 해당 버전에서는 specializing adaptive interpreter가 스레드 안전성을 확보하여 재활성화될 것이기 때문입니다. 그 시점에서는 많은 병렬 애플리케이션에서 free-threaded 빌드로의 전환이 자연스러운 선택이 될 것이며, 성능 변화를 측정하는 것도 흥미로울 것입니다.</li></ul><p>다른 모든 그래프 크기에서도 결과는 매우 유사했으며, 동일한 결론에 도달했습니다. 이번 측정을 통해 파이썬 3.13의 새로운 free-threaded 빌드가 병렬 애플리케이션의 성능에 상당한 영향을 미칠 수 있으며, <code>multiprocessing</code>의 매우 유의미한 대안이 될 수 있음을 확인했습니다. 다만 아직은 실험적인 기능이며, 전반적인 성능 저하로 인해 프로덕션 환경에서 사용하기에는 이른 단계이지만, 올바른 방향으로 나아가는 매우 유망한 진전이라고 할 수 있습니다.</p><h3 id="참고-사항" tabindex="-1"><a class="header-anchor" href="#참고-사항"><span>참고 사항</span></a></h3><p>이번 벤치마크에는 Python 3.12에서 도입된 GIL 없이 Python 코드를 병렬로 실행하는 또 다른 방식인 subinterpreters<sup class="footnote-ref"><a href="#footnote6">[6]</a><a class="footnote-anchor" id="footnote-ref6"></a></sup>는 포함되지 않았습니다. Subinterpreters는 대부분의 경우에서 다른 접근 방식들보다 느린 것으로 확인되었는데, 이는 주로 데이터 공유와 워커 간 통신 문제가 아직 완전히 해결되지 않았기 때문입니다. 하지만 이러한 문제들이 해결된다면, <code>multiprocessing</code>의 훌륭한 대안이 될 수 있을 것입니다.</p><hr>',61)),t("div",I,[e[17]||(e[17]=t("p",{class:"hint-container-title"},"원문",-1)),o(l,{name:"State of Python 3.13 Performance: Free-Threading - CodSpeed",desc:"Python 3.13 is out and it's time to run some benchmarks to see how well it performs with the new free-threaded mode.",url:"https://codspeed.io/blog/state-of-python-3-13-performance-free-threading/",logo:"https://codspeed.io/favicon/favicon.ico",preview:"https://codspeed.io/blog/state-of-python-3-13-performance-free-threading/cover.png"})]),u(" TODO: add ARTICLE CARD "),o(s,d(c({title:"파이썬 3.13 성능 향상 완전 정복: Free-Threading",desc:"지난 10월에 출시된 파이썬 3.13은 최근 릴리스 중에서도 성능 향상에 가장 큰 중점을 둔 버전입니다. 릴리스 노트를 살펴보면 성능에 큰 영향을 미칠 수 있는 주요 변경 사항들이 눈에 띕니다. 이 글에서는 free-threaded 모드를 중점적으로 살펴보고, 이러한 변화가 파이썬 애플리케이션의 성능에 미치는 영향을 측정해 볼 예정입니다.",link:"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2872.html",logo:"https://yozm.wishket.com/favicon.ico",background:"rgba(84,7,224,0.2)"})),null,16),e[20]||(e[20]=p('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p><strong>GIL</strong>: 한 번에 하나의 스레드만 파이썬 코드를 실행할 수 있도록 하는 잠금 장치 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p><strong>JIT</strong>: 프로그램 실행 중에 자주 사용되는 코드를 실시간으로 기계어로 번역해 성능을 향상시키는 컴파일 기술 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p><strong>mimalloc</strong>: Microsoft가 개발한 고성능 메모리 할당자로, 일반 malloc보다 더 빠르고 메모리 단편화가 적은 최신 메모리 관리 라이브러리 <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p><strong>청크</strong>: 큰 데이터를 작은 조각으로 나눠서 하나씩 처리하는 방식 <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p><strong>SAI</strong>: 프로그램 실행 중에 코드를 분석하고 최적화하는 특별한 종류의 인터프리터 <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li><li id="footnote6" class="footnote-item"><p><strong>subinterpreters</strong>: 하나의 프로세스 안에서 여러 개의 완전히 독립된 파이썬 인터프리터를 실행해 GIL 없이 진정한 병렬 처리를 가능하게 하는 파이썬 3.12의 기능 중 하나. <a href="#footnote-ref6" class="footnote-backref">↩︎</a></p></li></ol></section>',2))])}const F=g(k,[["render",P]]),A=JSON.parse('{"path":"/yozm.wishket.com/2872.html","title":"파이썬 3.13 성능 향상 완전 정복: Free-Threading","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"파이썬 3.13 성능 향상 완전 정복: Free-Threading","description":"Article(s) > 파이썬 3.13 성능 향상 완전 정복: Free-Threading","icon":"fa-brands fa-python","category":["Python","Article(s)"],"tag":["blog","yozm.wishket.com","py","python"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"파이썬 3.13 성능 향상 완전 정복: Free-Threading\\",\\"image\\":[\\"https://yozm.wishket.com/media/news/2872/1.png\\",\\"https://yozm.wishket.com/media/news/2872/2.png\\",\\"https://yozm.wishket.com/media/news/2872/3.png\\",\\"https://yozm.wishket.com/media/news/2872/4.png\\",\\"https://yozm.wishket.com/media/news/2872/5.png\\",\\"https://yozm.wishket.com/media/news/2872/6.png\\",\\"https://yozm.wishket.com/media/news/2872/7.png\\",\\"https://yozm.wishket.com/media/news/2872/8.png\\",\\"https://yozm.wishket.com/media/news/2872/9.png\\",\\"https://yozm.wishket.com/media/news/2872/pic_1__1_.png\\"],\\"datePublished\\":\\"2024-12-03T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"요즘IT의 번역글\\",\\"url\\":\\"https://yozm.wishket.com/magazine/@yozm_global/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2872.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"파이썬 3.13 성능 향상 완전 정복: Free-Threading"}],["meta",{"property":"og:description","content":"Article(s) > 파이썬 3.13 성능 향상 완전 정복: Free-Threading"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yozm.wishket.com/media/news/2872/cover.webp"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://yozm.wishket.com/media/news/2872/cover.webp"}],["meta",{"name":"twitter:image:alt","content":"파이썬 3.13 성능 향상 완전 정복: Free-Threading"}],["meta",{"property":"article:author","content":"요즘IT의 번역글"}],["meta",{"property":"article:tag","content":"python"}],["meta",{"property":"article:tag","content":"py"}],["meta",{"property":"article:tag","content":"yozm.wishket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-12-03T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > 파이썬 3.13 성능 향상 완전 정복: Free-Threading"},{"property":"og:description","content":"파이썬 3.13 성능 향상 완전 정복: Free-Threading"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2872.html"}]],"prev":"/programming/py/articles/README.md","date":"2024-12-03T00:00:00.000Z","isOriginal":false,"author":[{"name":"요즘IT의 번역글","url":"https://yozm.wishket.com/magazine/@yozm_global/"}],"cover":"https://yozm.wishket.com/media/news/2872/cover.webp"},"git":{},"readingTime":{"minutes":1.51,"words":452},"filePathRelative":"yozm.wishket.com/2872.md","copyright":{"author":"요즘IT의 번역글"}}');export{F as comp,A as data};
