import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,d as s,f as a,b as m,a as g,t as h,n as c,g as i,w as e,r as o,o as v,e as p}from"./app-BVguHYKu.js";const b={},_={id:"frontmatter-title-관련",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-관련"},y={class:"table-of-contents"};function w(u,n){const l=o("VPCard"),t=o("router-link"),r=o("SiteInfo");return v(),k("div",null,[s("h1",_,[s("a",f,[s("span",null,h(u.$frontmatter.title)+" 관련",1)])]),a(l,c(i({title:"JavaScript > Article(s)",desc:"Article(s)",link:"/programming/js/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",y,[s("ul",null,[s("li",null,[a(t,{to:"#이벤트-위임이란"},{default:e(()=>n[0]||(n[0]=[p("이벤트 위임이란?")])),_:1,__:[0]}),s("ul",null,[s("li",null,[a(t,{to:"#_1-상위-요소에-이벤트를-등록해-하위-요소를-처리하는-방식"},{default:e(()=>n[1]||(n[1]=[p("1. 상위 요소에 이벤트를 등록해 하위 요소를 처리하는 방식")])),_:1,__:[1]})]),s("li",null,[a(t,{to:"#_2-이벤트-버블링이란"},{default:e(()=>n[2]||(n[2]=[p("2. 이벤트 버블링이란?")])),_:1,__:[2]})])])]),s("li",null,[a(t,{to:"#이벤트-위임의-장점"},{default:e(()=>n[3]||(n[3]=[p("이벤트 위임의 장점")])),_:1,__:[3]}),s("ul",null,[s("li",null,[a(t,{to:"#_1-반복-구조에서-핸들러-수-대폭-감소"},{default:e(()=>n[4]||(n[4]=[p("1. 반복 구조에서 핸들러 수 대폭 감소")])),_:1,__:[4]})]),s("li",null,[a(t,{to:"#_2-동적으로-생성된-요소에서도-자동-적용"},{default:e(()=>n[5]||(n[5]=[p("2. 동적으로 생성된 요소에서도 자동 적용")])),_:1,__:[5]})])])]),s("li",null,[a(t,{to:"#언제-이벤트-위임을-쓰고-언제-직접-등록할까"},{default:e(()=>n[6]||(n[6]=[p("언제 이벤트 위임을 쓰고, 언제 직접 등록할까?")])),_:1,__:[6]}),s("ul",null,[s("li",null,[a(t,{to:"#_1-반복되는-구조에서는-이벤트-위임"},{default:e(()=>n[7]||(n[7]=[p("1. 반복되는 구조에서는 이벤트 위임")])),_:1,__:[7]})]),s("li",null,[a(t,{to:"#_2-단일-또는-중요한-인터랙션은-직접-등록"},{default:e(()=>n[8]||(n[8]=[p("2) 단일 또는 중요한 인터랙션은 직접 등록")])),_:1,__:[8]})]),s("li",null,[a(t,{to:"#_3-버블링이-중단되는-구조에서는-위임이-어려움"},{default:e(()=>n[9]||(n[9]=[p("3) 버블링이 중단되는 구조에서는 위임이 어려움")])),_:1,__:[9]})])])]),s("li",null,[a(t,{to:"#마치며"},{default:e(()=>n[10]||(n[10]=[p("마치며")])),_:1,__:[10]})])])]),n[11]||(n[11]=s("hr",null,null,-1)),a(r,{name:"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략",desc:"프론트엔드 개발을 하다 보면 마크업이 점점 복잡해지고, 사용자 인터랙션이 늘어남에 따라 이벤트 핸들러도 함께 늘어나는 현상을 자주 겪게 됩니다. 특히 대규모 UI를 다루거나, 반복되는 DOM 구조를 포함하는 웹 애플리케이션에서는 버튼 수십 개, 리스트 수백 개에 이벤트를 각각 등록해야 할지도 모릅니다. 이처럼 이벤트 리스너가 많아지면 단순히 메모리 소비가 늘어나는 것을 넘어, 렌더링 성능 저하, 유지보수의 어려움으로 이어질 수 있습니다. 이때 이벤트 위임은 이벤트 버블링 특성을 활용하여, 효율적으로 이벤트를 처리하는 방식입니다.",url:"https://yozm.wishket.com/magazine/detail/3273/",logo:"https://yozm.wishket.com/favicon.ico",preview:"https://yozm.wishket.com/media/news/3273/0805__3_.png"}),n[12]||(n[12]=m(`<p>프론트엔드 개발을 하다 보면 마크업이 점점 복잡해지고, 사용자 인터랙션이 늘어남에 따라 이벤트 핸들러도 함께 늘어나는 현상을 자주 겪게 됩니다. 특히 대규모 UI를 다루거나, 반복되는 DOM 구조를 포함하는 웹 애플리케이션에서는 버튼 수십 개, 리스트 수백 개에 이벤트를 각각 등록해야 할지도 모릅니다. 이처럼 이벤트 리스너가 많아지면 단순히 메모리 소비가 늘어나는 것을 넘어, 렌더링 성능 저하, 유지보수의 어려움으로 이어질 수 있습니다.</p><p>이 문제를 해결할 수 있는 대표적인 패턴이 바로 이벤트 위임(Event Delegation)입니다.</p><figure><img src="https://wishket.com/media/news/3273/0805__3_.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이벤트 위임은 이벤트 버블링 특성을 활용하여, 여러 개의 하위 요소 각각에 이벤트를 등록하는 대신 상위 요소 하나에만 리스너를 걸어 효율적으로 이벤트를 처리하는 방식입니다.</p><p>이번 글에서는 이벤트 위임이 어떻게 동작하는지, 실제로는 어떤 장점을 제공하는지, 그리고 언제 위임을 쓰고 언제 직접 등록하는 것이 더 나은지에 대해 실무적인 관점에서 구체적인 예시와 함께 알아보겠습니다.</p><hr><h2 id="이벤트-위임이란" tabindex="-1"><a class="header-anchor" href="#이벤트-위임이란"><span>이벤트 위임이란?</span></a></h2><p>이벤트 위임은 이벤트 처리를 ‘위임한다’라는 개념으로, 자식 요소가 아닌 공통 부모 요소에 이벤트 핸들러를 등록해, 하위 요소의 이벤트까지 처리하는 방식입니다. 반복되는 구조나 동적으로 생성되는 요소가 많을 때 특히 유용하며, DOM 이벤트의 버블링 덕분에 가능한 전략입니다.</p><h3 id="_1-상위-요소에-이벤트를-등록해-하위-요소를-처리하는-방식" tabindex="-1"><a class="header-anchor" href="#_1-상위-요소에-이벤트를-등록해-하위-요소를-처리하는-방식"><span>1. 상위 요소에 이벤트를 등록해 하위 요소를 처리하는 방식</span></a></h3><p>예를 들어, <code>&lt;ul&gt;</code> 태그 안에 수십 개의 <code>&lt;li&gt;</code> 항목이 있다고 해봅시다.</p><figure><img src="https://wishket.com/media/news/3273/0805__2_.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>각 <code>&lt;li&gt;</code>에 일일이 클릭 이벤트를 붙이는 대신, 상위 요소인 <code>&lt;ul&gt;</code>에 단 하나의 이벤트 핸들러만 등록하고, 클릭 된 대상이 어떤 <code>&lt;li&gt;</code>인지 판단하여, 적절한 동작을 수행하도록 만드는 방식이죠.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;ul&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName <span class="token operator">===</span> <span class="token string">&quot;LI&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">클릭된 항목: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>textContent<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>여기서 <code>e.target.tagName</code>은 대문자로 반환되기 때문에 “LI”와 비교합니다. 소문자 “li”로 비교하면 조건이 항상 false가 되기 때문에 주의해야 합니다.</p><p>조금 더 실전적인 예시로, 쇼핑몰 상품 목록에서 <code>.delete-button</code> 클래스가 있는 삭제 버튼을 처리해 보겠습니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;#product-list&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&#39;.delete-button&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;삭제됨&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이 코드에서는 <code>.delete-button</code> 클래스를 가진 버튼을 클릭했을 때만 이벤트가 동작하도록 <code>e.target.matches()</code>를 사용합니다. 이렇게 하면 상위 요소인 <code>#product-list</code>에 이벤트를 한 번만 등록해도, 하위에 있는 수많은 삭제 버튼들을 한 번에 제어할 수 있습니다.</p><h3 id="_2-이벤트-버블링이란" tabindex="-1"><a class="header-anchor" href="#_2-이벤트-버블링이란"><span>2. 이벤트 버블링이란?</span></a></h3><p>이벤트 위임의 기반이 되는 개념이 바로 이벤트 버블링입니다. 이벤트 버블링(Event Bubbling)은 DOM 요소에서 이벤트가 발생했을 때, 해당 이벤트가 DOM 트리를 따라 상위 요소로 순차적으로 전파되는 현상을 말합니다.</p><p>예를 들어, 안의 요소를 클릭하면 클릭 이벤트는 <code>li</code> 요소에서 발생한 뒤, <code>ul</code>, <code>body</code>, <code>html</code>, <code>document</code> 순으로 전달됩니다. 이 구조 덕분에 하위 요소에서 발생한 이벤트를 상위 요소에서도 감지할 수 있는데요. 이것이 바로 이벤트 위임이 가능해지는 이유입니다. 아래와 같은 HTML 구조를 예로 들어볼게요.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">&quot;menu&quot;</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;item&quot;</span><span class="token operator">&gt;</span>홈<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;item&quot;</span><span class="token operator">&gt;</span>소개<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token operator">&lt;</span>li <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;item&quot;</span><span class="token operator">&gt;</span>문의<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span></span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이 리스트에서 각각의 <code>&lt;li class=”item”&gt;</code>에 개별 이벤트를 등록하는 대신, 다음과 같이 <code>&lt;ul id=”menu”&gt;</code> 하나에만 이벤트를 등록할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;menu&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> li <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">closest</span><span class="token punctuation">(</span><span class="token string">&#39;.item&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>li<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">클릭한 항목: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>li<span class="token punctuation">.</span>textContent<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이벤트는 실제로는 <code>&lt;li&gt;</code> 요소에서 발생했지만, 이 이벤트가 부모인 <code>&lt;ul&gt;</code>까지 전파되기 때문에 <code>&lt;ul&gt;</code>에서 감지하고 처리할 수 있습니다. <code>closest()</code> 메서드는 이벤트가 발생한 위치에서 가장 가까운 <code>.item</code> 클래스를 가진 상위 요소를 찾는 데 사용됩니다. 이러한 방식은 코드의 간결성과 유지보수성을 높이는 데 큰 도움이 되죠.</p><hr><h2 id="이벤트-위임의-장점" tabindex="-1"><a class="header-anchor" href="#이벤트-위임의-장점"><span>이벤트 위임의 장점</span></a></h2><p>또한 이벤트 위임은 단순히 이벤트 등록 수를 줄이는 기술이 아닙니다. 성능, 유지보수, 확장성 측면에서도 다양한 이점을 제공합니다.</p><h3 id="_1-반복-구조에서-핸들러-수-대폭-감소" tabindex="-1"><a class="header-anchor" href="#_1-반복-구조에서-핸들러-수-대폭-감소"><span>1. 반복 구조에서 핸들러 수 대폭 감소</span></a></h3><p>이벤트 위임의 가장 큰 강점 중 하나는 바로 이벤트 핸들러의 수를 대폭 줄일 수 있다는 점입니다. 반복되는 UI 구조에서 각 요소마다 일일이 핸들러를 붙이는 방식은 브라우저 메모리에 부담을 줄 수 있고, 코드도 불필요하게 길어지기 마련입니다. 이와 달리 이벤트 위임을 활용하면 수십, 수백 개의 요소도 단 한 줄의 핸들러로 통합해서 관리할 수 있습니다.</p><figure><img src="https://wishket.com/media/news/3273/0805__1_.png" alt="출처 : 왼-한입 커뮤니티, 오: 요즘IT" tabindex="0" loading="lazy"><figcaption>출처 : 왼-한입 커뮤니티, 오: 요즘IT</figcaption></figure><p>예를 들어, 댓글 목록이나 쇼핑몰의 상품 카드처럼 수많은 항목이 반복되는 UI에서는 각 요소에 핸들러를 붙이는 것보다, 상위 컨테이너에 하나의 핸들러를 등록하는 편이 훨씬 효율적입니다.</p><h3 id="_2-동적으로-생성된-요소에서도-자동-적용" tabindex="-1"><a class="header-anchor" href="#_2-동적으로-생성된-요소에서도-자동-적용"><span>2. 동적으로 생성된 요소에서도 자동 적용</span></a></h3><p>또 다른 장점은 동적으로 생성되는 요소에도 별도의 핸들러를 붙이지 않아도 자동으로 동작한다는 점입니다. 다음 예제를 보시면 이해하기 쉬울 겁니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;todo-list&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">matches</span><span class="token punctuation">(</span><span class="token string">&#39;.todo-delete&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>parentElement<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> newItem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;li&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">newItem<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">&#39;새 할 일 &lt;button class=&quot;todo-delete&quot;&gt;삭제&lt;/button&gt;&#39;</span><span class="token punctuation">;</span></span>
<span class="line">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;todo-list&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>newItem<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이 코드는 기존에 등록된 핸들러로 새로 추가된 <code>.todo-delete</code> 버튼까지 제어할 수 있습니다. appendChild로 새롭게 생성된 요소에는 개별 이벤트를 등록하지 않았지만, 상위 요소에 등록된 이벤트 핸들러가 정상적으로 동작하는 것을 볼 수 있습니다. 이처럼 동적 UI에서 이벤트 위임은 유지보수와 성능 측면에서 매우 유리한 전략입니다.</p><hr><h2 id="언제-이벤트-위임을-쓰고-언제-직접-등록할까" tabindex="-1"><a class="header-anchor" href="#언제-이벤트-위임을-쓰고-언제-직접-등록할까"><span>언제 이벤트 위임을 쓰고, 언제 직접 등록할까?</span></a></h2><p>이벤트 위임은 많은 상황에서 유용하지만, 모든 곳에 무조건 적용할 수 있는 만능 도구는 아닙니다. 상황에 따라 적절히 위임과 직접 등록 방식을 구분해야 합니다.</p><h3 id="_1-반복되는-구조에서는-이벤트-위임" tabindex="-1"><a class="header-anchor" href="#_1-반복되는-구조에서는-이벤트-위임"><span>1. 반복되는 구조에서는 이벤트 위임</span></a></h3><p><code>&lt;ul&gt;</code>, <code>&lt;table&gt;</code>, <code>&lt;div class=”grid”&gt;</code>처럼 동일한 구조가 반복되는 경우라면 이벤트 위임을 사용하는 것이 좋습니다. 수십 개 이상의 요소에 동일한 이벤트를 등록해야 할 때는 위임 방식이 거의 필수입니다. 특히 리스트 항목이나 게시글 목록, 댓글 UI처럼 동적 요소가 반복되는 경우 위임 방식은 성능과 유지보수 측면 모두에서 탁월한 선택입니다.</p><h3 id="_2-단일-또는-중요한-인터랙션은-직접-등록" tabindex="-1"><a class="header-anchor" href="#_2-단일-또는-중요한-인터랙션은-직접-등록"><span>2) 단일 또는 중요한 인터랙션은 직접 등록</span></a></h3><p>반면, <code>submit</code>, <code>scroll</code>, <code>drag</code>, <code>touchmove</code>와 같은 이벤트는 예기치 않은 전파나 성능 문제를 막기 위해 직접 등록하는 것이 더 안전합니다. 로그인, 결제, 보안 관련 이벤트처럼 반드시 의도한 대상에서만 동작해야 하는 이벤트도 마찬가지입니다. 이 경우 이벤트 위임보다는 명확하게 해당 요소에 직접 핸들러를 등록하는 것이 더 바람직합니다.</p><h3 id="_3-버블링이-중단되는-구조에서는-위임이-어려움" tabindex="-1"><a class="header-anchor" href="#_3-버블링이-중단되는-구조에서는-위임이-어려움"><span>3) 버블링이 중단되는 구조에서는 위임이 어려움</span></a></h3><p>이벤트 버블링이 도중에 중단되는 구조에서는 위임이 제대로 작동하지 않습니다. 예를 들어, <code>stopPropagation()</code>이 호출되거나, Shadow DOM 같은 캡슐화된 환경에서는 이벤트가 상위 요소까지 전파되지 않기 때문에 이벤트 위임 방식이 무력화될 수 있습니다. 이럴 땐 위임이 아닌 직접 이벤트 등록 방식을 고려해야 합니다.</p><hr><h2 id="마치며" tabindex="-1"><a class="header-anchor" href="#마치며"><span>마치며</span></a></h2><p>대규모 UI를 다룰 때, 반복되는 DOM 구조나 동적으로 생성되는 요소가 많다면, 이벤트 위임은 매우 유용한 전략입니다. 핸들러 수를 줄이고 성능을 개선할 수 있을 뿐만 아니라, 코드 유지보수와 확장성 측면에서도 뛰어난 이점을 제공합니다. 물론 모든 상황에 적용되는 것은 아니므로, 이벤트 전파 구조나 UI의 특성에 따라 위임과 직접 등록을 적절히 조합하는 것이 중요합니다.</p><p>마지막으로, 크롬 개발자 도구의 Performance와 Memory 탭을 활용해, 이벤트 핸들러 수, 실행 시간, GC 상태 등을 주기적으로 점검해 보는 것이 좋습니다. 우리가 무심코 붙인 이벤트 하나가 앱 성능에 큰 영향을 미칠 수 있습니다. 올바른 전략으로 이벤트를 다루는 습관이 쌓일수록, 더욱 빠르고 안정적인 프론트엔드 개발이 가능해질 것입니다.</p>`,48)),g(" TODO: add ARTICLE CARD "),a(l,c(i({title:"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략",desc:"프론트엔드 개발을 하다 보면 마크업이 점점 복잡해지고, 사용자 인터랙션이 늘어남에 따라 이벤트 핸들러도 함께 늘어나는 현상을 자주 겪게 됩니다. 특히 대규모 UI를 다루거나, 반복되는 DOM 구조를 포함하는 웹 애플리케이션에서는 버튼 수십 개, 리스트 수백 개에 이벤트를 각각 등록해야 할지도 모릅니다. 이처럼 이벤트 리스너가 많아지면 단순히 메모리 소비가 늘어나는 것을 넘어, 렌더링 성능 저하, 유지보수의 어려움으로 이어질 수 있습니다. 이때 이벤트 위임은 이벤트 버블링 특성을 활용하여, 효율적으로 이벤트를 처리하는 방식입니다.",link:"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3273.html",logo:"https://yozm.wishket.com/favicon.ico",background:"rgba(84,7,224,0.2)"})),null,16)])}const z=d(b,[["render",w]]),I=JSON.parse('{"path":"/yozm.wishket.com/3273.html","title":"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략","description":"Article(s) > 프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략","icon":"fa-brands fa-js","category":["JavaScript","Article(s)"],"tag":["blog","yozm.wishket.com","js","javascript"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략\\",\\"image\\":[\\"https://wishket.com/media/news/3273/0805__3_.png\\",\\"https://wishket.com/media/news/3273/0805__2_.png\\",\\"https://wishket.com/media/news/3273/0805__1_.png\\"],\\"datePublished\\":\\"2025-08-06T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"효빈\\",\\"url\\":\\"https://yozm.wishket.com/magazine/@hbin12212/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3273.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략"}],["meta",{"property":"og:description","content":"Article(s) > 프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yozm.wishket.com/media/news/3273/0805__3_.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://yozm.wishket.com/media/news/3273/0805__3_.png"}],["meta",{"name":"twitter:image:alt","content":"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략"}],["meta",{"property":"article:author","content":"효빈"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"yozm.wishket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-08-06T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > 프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략"},{"property":"og:description","content":"프론트엔드 성능 최적화를 위한 ‘이벤트 위임’ 전략"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3273.html"}]],"prev":"/programming/js/articles/README.md","date":"2025-08-06T00:00:00.000Z","isOriginal":false,"author":[{"name":"효빈","url":"https://yozm.wishket.com/magazine/@hbin12212/"}],"cover":"https://yozm.wishket.com/media/news/3273/0805__3_.png"},"git":{},"readingTime":{"minutes":1.13,"words":339},"filePathRelative":"yozm.wishket.com/3273.md","copyright":{"author":"효빈"}}');export{z as comp,I as data};
