import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,d as t,f as n,b as i,a as f,t as y,n as p,g as d,w as a,e as o,r as l,o as b}from"./app-BItykJLQ.js";const w={},v={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},k={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},x={class:"table-of-contents"},I={href:"http://lxc.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},C={href:"http://docker.io",target:"_blank",rel:"noopener noreferrer"},D={href:"http://lwn.net/Articles/549580/",target:"_blank",rel:"noopener noreferrer"},T={href:"http://collectd.org/",target:"_blank",rel:"noopener noreferrer"},P={href:"https://github.com/jpetazzo/pipework",target:"_blank",rel:"noopener noreferrer"},j={href:"http://collectd.org/",target:"_blank",rel:"noopener noreferrer"},S={href:"http://graphite.wikidot.com/",target:"_blank",rel:"noopener noreferrer"},z={href:"https://metrics.librato.com/",target:"_blank",rel:"noopener noreferrer"},A={href:"http://aws.amazon.com/cloudwatch/",target:"_blank",rel:"noopener noreferrer"},L={href:"http://newrelic.com/server-monitoring",target:"_blank",rel:"noopener noreferrer"},O={class:"hint-container info"},_={href:"http://en.wikipedia.org/wiki/Cessna_EC-2",target:"_blank",rel:"noopener noreferrer"},U={href:"https://x.com/jpetazzo",target:"_blank",rel:"noopener noreferrer"};function W(h,e){const c=l("VPCard"),s=l("router-link"),u=l("SiteInfo"),r=l("VPIcon");return b(),g("div",null,[t("h1",v,[t("a",k,[t("span",null,y(h.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),n(c,p(d({title:"Docker > Article(s)",desc:"Article(s)",link:"/devops/docker/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",x,[t("ul",null,[t("li",null,[n(s,{to:"#locate-your-control-groups"},{default:a(()=>[...e[0]||(e[0]=[o("Locate your control groups",-1)])]),_:1}),t("ul",null,[t("li",null,[n(s,{to:"#control-groups-hierarchies"},{default:a(()=>[...e[1]||(e[1]=[o("Control groups hierarchies",-1)])]),_:1})]),t("li",null,[n(s,{to:"#enumerating-our-cgroups"},{default:a(()=>[...e[2]||(e[2]=[o("Enumerating our cgroups",-1)])]),_:1})]),t("li",null,[n(s,{to:"#finding-the-cgroup-for-a-given-container"},{default:a(()=>[...e[3]||(e[3]=[o("Finding the cgroup for a given container",-1)])]),_:1})])])]),t("li",null,[n(s,{to:"#collecting-memory-cpu-block-i-o-metrics"},{default:a(()=>[...e[4]||(e[4]=[o("Collecting memory, CPU, block I/O metrics",-1)])]),_:1}),t("ul",null,[t("li",null,[n(s,{to:"#memory-metrics"},{default:a(()=>[...e[5]||(e[5]=[o("Memory metrics",-1)])]),_:1})]),t("li",null,[n(s,{to:"#cpu-metrics"},{default:a(()=>[...e[6]||(e[6]=[o("CPU metrics",-1)])]),_:1})]),t("li",null,[n(s,{to:"#block-i-o-metrics"},{default:a(()=>[...e[7]||(e[7]=[o("Block I/O metrics",-1)])]),_:1})])])]),t("li",null,[n(s,{to:"#collecting-network-metrics"},{default:a(()=>[...e[8]||(e[8]=[o("Collecting network metrics",-1)])]),_:1}),t("ul",null,[t("li",null,[n(s,{to:"#iptables"},{default:a(()=>[...e[9]||(e[9]=[o("Iptables",-1)])]),_:1})]),t("li",null,[n(s,{to:"#interface-level-counters"},{default:a(()=>[...e[10]||(e[10]=[o("Interface-level counters",-1)])]),_:1})])])]),t("li",null,[n(s,{to:"#collecting-metrics-when-a-container-exits"},{default:a(()=>[...e[11]||(e[11]=[o("Collecting metrics when a container exits",-1)])]),_:1})]),t("li",null,[n(s,{to:"#wrapping-it-up"},{default:a(()=>[...e[12]||(e[12]=[o("Wrapping it up",-1)])]),_:1})])])]),e[55]||(e[55]=t("hr",null,null,-1)),n(u,{name:"Gathering LXC and Docker containers metricsDocker",desc:"Learn from Docker experts to simplify and advance your app development and management with Docker. Stay up to date on Docker events and new version",url:"https://docker.com/blog/gathering-lxc-docker-containers-metrics",logo:"https://docker.com/app/uploads/2024/02/cropped-docker-logo-favicon-192x192.png",preview:"https://docker.com/app/uploads/2013/08/jerome_docker_in_docker_squ.jpg"}),t("p",null,[e[15]||(e[15]=o("Linux Containers rely on control groups which not only track groups of processes, but also expose a lot of metrics about CPU, memory, and block I/O usage. We will see how to access those metrics, and how to obtain network usage metrics as well. This is relevant for ‚Äúpure‚Äù ",-1)),t("a",I,[n(r,{icon:"fas fa-globe"}),e[13]||(e[13]=o("LXC containers",-1))]),e[16]||(e[16]=o(", as well as for ",-1)),t("a",C,[n(r,{icon:"fa-brands fa-docker"}),e[14]||(e[14]=o("Docker",-1))]),e[17]||(e[17]=o(" containers.",-1))]),e[56]||(e[56]=i(`<hr><h2 id="locate-your-control-groups" tabindex="-1"><a class="header-anchor" href="#locate-your-control-groups"><span>Locate your control groups</span></a></h2><p>Control groups are exposed through a pseudo-filesystem. In recent distros, you should find this filesystem under <code>/sys/fs/cgroup</code>. Under that directory, you will see multiple sub-directories, called <code>devices</code>, <code>freezer</code>, <code>blkio</code>, etc.; each sub-directory actually corresponds to a different cgroup <em>hierarchy</em>.</p><p>On older systems, the control groups might be mounted on <code>/cgroup</code>, without distinct hierarchies. In that case, instead of seeing the sub-directories, you will see a bunch of files in that directory, and possibly some directories corresponding to existing containers.</p><p>To figure out where your control groups are mounted, you can run:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">grep</span> cgroup /proc/mounts</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="control-groups-hierarchies" tabindex="-1"><a class="header-anchor" href="#control-groups-hierarchies"><span>Control groups hierarchies</span></a></h3><p>The fact that different control groups can be in different hierarchies mean that you can use completely different groups (and policies) for e.g. CPU allocation and memory allocation. Let‚Äôs make up a completely imaginary example: you have a 2-CPU system running Python webapps with Gunicorn, a PostgreSQL database, and accepting SSH logins. You can put each webapp and each SSH session in their own memory control group (to make sure that a single app or user doesn‚Äôt use up the memory of the whole system), and at the same time, stick the webapps and database on a CPU, and the SSH logins on another CPU.</p><p>Of course, if you run LXC containers, each hierarchy will have one group per container, and all hierarchies will look the same.</p><p>Merging or splitting hierarchies is achieved by using special options when mounting the cgroup pseudo-filesystems. Note that if you want to change that, you will have to remove all existing cgroups in the hierarchies that you want to split or merge.</p><h3 id="enumerating-our-cgroups" tabindex="-1"><a class="header-anchor" href="#enumerating-our-cgroups"><span>Enumerating our cgroups</span></a></h3><p>You can look into <code>/proc/cgroups</code> to see the different control group subsystems known to the system, the hierarchy they belong to, and how many groups they contain.</p><p>You can also look at <code>/proc/&lt;pid&gt;/cgroup</code> to see which control groups a process belongs to. The control group will be shown as a path relative to the root of the hierarchy mountpoint; e.g. <code>/</code> means ‚Äúthis process has not been assigned into a particular group‚Äù, while <code>/lxc/pumpkin</code> means that the process is likely to be a member of a container named <code>pumpkin</code>.</p><h3 id="finding-the-cgroup-for-a-given-container" tabindex="-1"><a class="header-anchor" href="#finding-the-cgroup-for-a-given-container"><span>Finding the cgroup for a given container</span></a></h3><p>For each container, one cgroup will be created in each hierarchy. On older systems with older versions of the LXC userland tools, the name of the cgroup will be the name of the container. With more recent versions of the LXC tools, the cgroup will be <code>lxc/&lt;container_name&gt;</code>.</p><p>Additional note for Docker users: the container name will be the <em>full ID</em> or <em>long ID</em> of the container. If a container shows up as <code>ae836c95b4c3</code> in <code>docker ps</code>, its long ID might be something like <code>ae836c95b4c3c9e9179e0e91015512da89fdec91612f63cebae57df9a5444c79</code>. You can look it up with <code>docker inspect</code> or <code>docker ps -notrunc</code>.</p><p>Putting everything together: on my system, if I want to look at the memory metrics for a Docker container, I have to look at <code>/sys/fs/cgroup/memory/lxc/&lt;longid&gt;/</code>.</p><hr><h2 id="collecting-memory-cpu-block-i-o-metrics" tabindex="-1"><a class="header-anchor" href="#collecting-memory-cpu-block-i-o-metrics"><span>Collecting memory, CPU, block I/O metrics</span></a></h2><p>For each subsystem, we will find one pseudo-file (in some cases, multiple) containing statistics about used memory, accumulated CPU cycles, or number of I/O completed. Those files are easy to parse, as we will see.</p><h3 id="memory-metrics" tabindex="-1"><a class="header-anchor" href="#memory-metrics"><span>Memory metrics</span></a></h3><p>Those will be found in the <code>memory</code> cgroup (duh!). Note that the memory control group adds a little overhead, because it does very fine-grained accounting of the memory usage on your system. Therefore, many distros chose to <em>not</em> enable it by default. Generally, to enable it, all you have to do is to add some kernel command-line parameters: <code>cgroup_enable=memory swapaccount=1</code>.</p><p>The metrics are in the pseudo-file <code>memory.stat</code>. Here is what it will look like:</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="memory.stat"><span>memory.stat</span></div><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">cache 11492564992</span>
<span class="line">rss 1930993664</span>
<span class="line">mapped_file 306728960</span>
<span class="line">pgpgin 406632648</span>
<span class="line">pgpgout 403355412</span>
<span class="line">swap 0</span>
<span class="line">pgfault 728281223</span>
<span class="line">pgmajfault 1724</span>
<span class="line">inactive_anon 46608384</span>
<span class="line">active_anon 1884520448</span>
<span class="line">inactive_file 7003344896</span>
<span class="line">active_file 4489052160</span>
<span class="line">unevictable 32768</span>
<span class="line">hierarchical_memory_limit 9223372036854775807</span>
<span class="line">hierarchical_memsw_limit 9223372036854775807</span>
<span class="line">total_cache 11492564992</span>
<span class="line">total_rss 1930993664</span>
<span class="line">total_mapped_file 306728960</span>
<span class="line">total_pgpgin 406632648</span>
<span class="line">total_pgpgout 403355412</span>
<span class="line">total_swap 0</span>
<span class="line">total_pgfault 728281223</span>
<span class="line">total_pgmajfault 1724</span>
<span class="line">total_inactive_anon 46608384</span>
<span class="line">total_active_anon 1884520448</span>
<span class="line">total_inactive_file 7003344896</span>
<span class="line">total_active_file 4489052160</span>
<span class="line">total_unevictable 32768</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>The first half (without the <code>total_</code> prefix) contains statistics relevant to the processes within the cgroup, excluding sub-cgroups. The second half (with the <code>total_</code> prefix) includes sub-cgroups as well.</p><p>Some metrics are ‚Äúgauges‚Äù, i.e. values that can increase or decrease (e.g. <code>swap</code>, the amount of swap space used by the members of the cgroup). Some others are ‚Äúcounters‚Äù, i.e. values that can only go up, because they represent occurrences of a specific event (e.g. <code>pgfault</code>, which indicates the number of page faults which happened since the creation of the cgroup; this number can never decrease).</p><p>Let‚Äôs see what those metrics stand for. All memory amounts are in bytes (except for event counters).</p><ul><li><strong>cache</strong> is the amount of memory used by the processes of this control group that can be associated precisely with a block on a block device. When you read and write files from and to disk, this amount will increase. This will be the case if you use ‚Äúconventional‚Äù I/O (<code>open</code>, <code>read</code>, <code>write</code> syscalls) as well as mapped files (with <code>mmap</code>). It also accounts for the memory used by <code>tmpfs</code> mounts. I don‚Äôt know exactly why; it might be because <code>tmpfs</code> filesystems work directly with the page cache.</li><li><strong>rss</strong> is the amount of memory that <em>doesn‚Äôt</em> correspond to anything on disk: stacks, heaps, and anonymous memory maps.</li><li><strong>mapped_file</strong> indicates the amount of memory mapped by the processes in the control group. In my humble opinion, it doesn‚Äôt give you an information about <em>how much</em> memory is used; it rather tells you <em>how</em> it is used.</li><li><strong>pgpgin</strong> and <strong>pgpgout</strong> are a bit tricky. If you are used to <code>vmstat</code>, you might think that they indicate the number of times that a page had to be read and written (respectively) by a process of the cgroup, and that they should reflect both file I/O and swap activity. Wrong! In fact, they correspond to <em>charging events</em>. Each time a page is ‚Äúcharged‚Äù (=added to the accounting) to a cgroup, <strong>pgpgin</strong> increases. When a page is ‚Äúuncharged‚Äù (=no longer ‚Äúbilled‚Äù to a cgroup), <strong>pgpgout</strong> increases.</li><li><strong>pgfault</strong> and <strong>pgmajfault</strong> indicate the number of times that a process of the cgroup triggered a ‚Äúpage fault‚Äù and a ‚Äúmajor fault‚Äù, respectively. A page fault happens when a process accesses a part of its virtual memory space which is inexistent or protected. The former can happen if the process is buggy and tries to access an invalid address (it will then be sent a <code>SIGSEGV</code> signal, typically killing it with the famous <code>Segmentation fault</code> message). The latter can happen when the process reads from a memory zone which has been swapped out, or which corresponds to a mapped file: in that case, the kernel will load the page from disk, and let the CPU complete the memory access. It can also happen when the process writes to a copy-on-write memory zone: likewise, the kernel will preempt the process, duplicate the memory page, and resume the write operation on the process‚Äô own copy of the page. ‚ÄúMajor‚Äù faults happen when the kernel actually has to read the data from disk. When it just has to duplicate an existing page, or allocate an empty page, it‚Äôs a regular (or ‚Äúminor‚Äù) fault.</li><li><strong>swap</strong> is (as expected) the amount of swap currently used by the processes in this cgroup.</li><li><strong>active_anon</strong> and <strong>inactive_anon</strong> is the amount of <em>anonymous</em> memory that has been identified has respectively <em>active</em> and <em>inactive</em> by the kernel. ‚ÄúAnonymous‚Äù memory is the memory that is <em>not</em> linked to disk pages. In other words, that‚Äôs the equivalent of the <strong>rss</strong> counter described above. In fact, the very definition of the <strong>rss</strong> counter is <strong>active_anon</strong>+<strong>inactive_anon</strong>-<strong>tmpfs</strong> (where <strong>tmpfs</strong> is the amount of memory used up by <code>tmpfs</code> filesystems mounted by this control group). Now, what‚Äôs the difference between ‚Äúactive‚Äù and ‚Äúinactive‚Äù? Pages are initially ‚Äúactive‚Äù; and at regular intervals, the kernel sweeps over the memory, and tags some pages as ‚Äúinactive‚Äù. Whenever they are accessed again, they are immediately retagged ‚Äúactive‚Äù. When the kernel is almost out of memory, and time comes to swap out to disk, the kernel will swap ‚Äúinactive‚Äù pages.</li><li>Likewise, the <strong>cache</strong> memory is broken down into <strong>active_file</strong> and <strong>inactive_file</strong>. The exact formula is <strong>cache</strong>=<strong>active_file</strong>+<strong>inactive_file</strong>+<strong>tmpfs</strong>. The exact rules used by the kernel to move memory pages between active and inactive sets are different from the ones used for anonymous memory, but the general principle is the same. Note that when the kernel needs to reclaim memory, it is cheaper to reclaim a clean (=non modified) page from this pool, since it can be reclaimed immediately (while anonymous pages and dirty/modified pages have to be written to disk first).</li><li><strong>unevictable</strong> is the amount of memory that cannot be reclaimed; generally, it will account for memory that has been ‚Äúlocked‚Äù with <code>mlock</code>. It is often used by crypto frameworks to make sure that secret keys and other sensitive material never gets swapped out to disk.</li><li>Last but not least, the <strong>memory</strong> and <strong>memsw</strong> limits are not really metrics, but a reminder of the limits applied to this cgroup. The first one indicates the maximum amount of physical memory that can be used by the processes of this control group; the second one indicates the maximum amount of RAM+swap.</li></ul><p>Accounting for memory in the page cache is very complex. If two processes in different control groups both read the same file (ultimately relying on the same blocks on disk), the corresponding memory charge will be split between the control groups. It‚Äôs nice, but it also means that when a cgroup is terminated, it could increase the memory usage of another cgroup, because they are not splitting the cost anymore for those memory pages.</p><h3 id="cpu-metrics" tabindex="-1"><a class="header-anchor" href="#cpu-metrics"><span>CPU metrics</span></a></h3><p>Now that we‚Äôve covered memory metrics, everything else will look very simple in comparison. CPU metrics will be found in the <code>cpuacct</code> controller.</p><p>For each container, you will find a pseudo-file <code>cpuacct.stat</code>, containing the CPU usage accumulated by the processes of the container, broken down between <code>user</code> and <code>system</code> time. If you‚Äôre not familiar with the distinction, <code>user</code> is the time during which the processes were in direct control of the CPU (i.e. executing process code), and <code>system</code> is the time during which the CPU was executing system calls on behalf of those processes.</p>`,32)),t("p",null,[e[19]||(e[19]=o("Those times are expressed in ticks of 1/100th of second. (Actually, they are expressed in ‚Äúuser jiffies‚Äù. There are ",-1)),e[20]||(e[20]=t("code",null,"USER_HZ",-1)),e[21]||(e[21]=o()),e[22]||(e[22]=t("em",null,"‚Äújiffies‚Äù",-1)),e[23]||(e[23]=o(" per second, and on x86 systems, ",-1)),e[24]||(e[24]=t("code",null,"USER_HZ",-1)),e[25]||(e[25]=o(" is 100. This used to map exactly to the number of scheduler ‚Äúticks‚Äù per second; but with the advent of higher frequency scheduling, as well as ",-1)),t("a",D,[n(r,{icon:"fas fa-globe"}),e[18]||(e[18]=o("tickless kernels",-1))]),e[26]||(e[26]=o(", the number of kernel ticks wasn‚Äôt relevant anymore. It stuck around anyway, mainly for legacy and compatibility reasons.)",-1))]),e[57]||(e[57]=i(`<h3 id="block-i-o-metrics" tabindex="-1"><a class="header-anchor" href="#block-i-o-metrics"><span>Block I/O metrics</span></a></h3><p>Block I/O is accounted in the <code>blkio</code> controller. Different metrics are scattered across different files. While you can find in-depth details in the blkio-controller file in the kernel documentation, here is a short list of the most relevant ones:</p><ul><li><strong>blkio.sectors</strong> contains the number of 512-bytes sectors read and written by the processes member of the cgroup, device by device. Reads and writes are merged in a single counter.</li><li><strong>blkio.io_service_bytes</strong> indicates the number of bytes read and written by the cgroup. It has 4 counters per device, because for each device, it differentiates between synchronous vs. asynchronous I/O, and reads vs. writes.</li><li><strong>blkio.io_serviced</strong> is similar, but instead of showing byte counters, it will show the number of I/O operations performed, regardless of their size. It also has 4 counters per device.</li><li><strong>blkio.io_queued</strong> indicates the number of I/O operations currently queued for this cgroup. In other words, if the cgroup isn‚Äôt doing any I/O, this will be zero. Note that the opposite is not true. In other words, if there is no I/O queued, it does not mean that the cgroup is idle (I/O-wise). It could be doing purely synchronous reads on an otherwise quiescent device, which is therefore able to handle them immediately, without queuing. Also, while it is helpful to figure out which cgroup is putting stress on the I/O subsystem, keep in mind that is is a relative quantity. Even if a process group does not perform more I/O, its queue size can increase just because the device load increases because of other devices.</li></ul><p>For each file, there is a <code>_recursive</code> variant, that aggregates the metrics of the control group and all its sub-cgroups.</p><p>Also, it‚Äôs worth mentioning that in most cases, if the processes of a control group have not done any I/O on a given block device, the block device will not appear in the pseudo-files. In other words, you have to be careful each time you parse one of those files, because new entries might have appeared since the previous time.</p><hr><h2 id="collecting-network-metrics" tabindex="-1"><a class="header-anchor" href="#collecting-network-metrics"><span>Collecting network metrics</span></a></h2><p>Interestingly, network metrics are not exposed directly by control groups. There is a good explanation for that: network interfaces exist within the context of <em>network namespaces</em>. The kernel could probably accumulate metrics about packets and bytes sent and received by a group of processes, but those metrics wouldn‚Äôt be very useful. You want (at least!) per-interface metrics (because traffic happening on the local <code>lo</code> interface doesn‚Äôt really count). But since processes in a single cgroup can belong to multiple network namespaces, those metrics would be harder to interpret: multiple network namespaces means multiple <code>lo</code> interfaces, potentially multiple <code>eth0</code> interfaces, etc.; so this is why there is no easy way to gather network metrics with control groups.</p><p>So what shall we do? Well, we have multiple options.</p><h3 id="iptables" tabindex="-1"><a class="header-anchor" href="#iptables"><span>Iptables</span></a></h3><p>When people think about <code>iptables</code>, they usually think about firewalling, and maybe NAT scenarios. But <code>iptables</code> (or rather, the <code>netfilter</code> framework for which <code>iptables</code> is just an interface) can also do some serious accounting.</p><p>For instance, you can setup a rule to account for the outbound HTTP traffic on a web server:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">iptables <span class="token parameter variable">-I</span> OUTPUT <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">--sport</span> <span class="token number">80</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>There is no <code>-j</code> or <code>-g</code> flag, so the rule will just count matched packets and go to the following rule.</p><p>Later, you can check the values of the counters, with:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">iptables <span class="token parameter variable">-nxvL</span> OUTPUT</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>(Technically, <code>-n</code> is not required, but it will prevent iptables from doing DNS reverse lookups, which are probably useless in this scenario.)</p><p>Counters include packets and bytes. If you want to setup metrics for container traffic like this, you could execute a <code>for</code> loop to add two <code>iptables</code> rules per container IP address (one in each direction), in the <code>FORWARD</code> chain. This will only meter traffic going through the NAT layer; you will also have to add traffic going through the userland proxy.</p>`,18)),t("p",null,[e[28]||(e[28]=o("Then, you will need to check those counters on a regular basis. If you happen to use ",-1)),t("a",T,[n(r,{icon:"fas fa-globe"}),e[27]||(e[27]=o("collectd",-1))]),e[29]||(e[29]=o(", there is a nice plugin to automate iptables counters collection.",-1))]),e[58]||(e[58]=i(`<h3 id="interface-level-counters" tabindex="-1"><a class="header-anchor" href="#interface-level-counters"><span>Interface-level counters</span></a></h3><p>Since each container has a virtual Ethernet interface, you might want to check directly the TX and RX counters of this interface. However, this is not as easy as it sounds. If you use Docker (as of current version 0.6) or <code>lxc-start</code>, then you will notice that each container is associated to a virtual Ethernet interface in your host, with a name like <code>vethKk8Zqi</code>. Figuring out which interface corresponds to which container is, unfortunately, difficult. (If you know an easy way, let me know.)</p><p>In the long run, Docker will probably take over the setup of those virtual interfaces. It will keep track of their names, and make sure that it can easily associate containers with their respective interfaces.</p><p>But for now, the best way is to check the metrics <em>from within the containers</em>. I‚Äôm not talking about running a special agent in the container, or anything like that. We are going to run an executable from the host environment, but within the network namespace of a container.</p><h4 id="ip-netns-magic" tabindex="-1"><a class="header-anchor" href="#ip-netns-magic"><span>ip-netns magic</span></a></h4><p>To do that, we will use the <code>ip netns exec</code> command. This command will let you execute any program (present in the host system) within any network namespace visible to the current process. This means that your host will be able to enter the network namespace of your containers, but your containers won‚Äôt be able to access the host, nor their sibling containers. Containers will be able to ‚Äúsee‚Äù and affect their sub-containers, though.</p><p>The exact format of the command is:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token operator">&lt;</span>nsname<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>command<span class="token punctuation">..</span>.<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>For instance:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> mycontainer <span class="token function">netstat</span> <span class="token parameter variable">-i</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>How does the naming system work? How does <code>ip netns</code> find <code>mycontainer</code>? Answer: by using the namespaces pseudo-files. Each process belongs to one network namespace, one PID namespace, one <code>mnt</code> namespace, etc.; and those namespaces are materialized under <code>/proc/&lt;pid&gt;/ns/</code>. For instance, the network namespace of PID 42 is materialized by the pseudo-file <code>/proc/42/ns/net</code>.</p><p>When you run <code>ip netns exec mycontainer ...</code>, it expects <code>/var/run/netns/mycontainer</code> to be one of those pseudo-files. (Symlinks are accepted.)</p><p>In other words, to execute a command within the network namespace of a container, we need to:</p><ul><li>find out the PID of any process within the container that we want to investigate;</li><li>create a symlink from <code>/var/run/netns/&lt;somename&gt;</code> to <code>/proc/&lt;thepid&gt;/ns/net</code>;</li><li>execute <code>ip netns exec &lt;somename&gt; ...</code>.</li></ul><p>Now, we need to figure out a way to find the PID of a process (any process!) running in the container that we want to investigate. This is actually very easy. You have to locate one of the control groups corresponding to the container. We explained how to locate those cgroups in the beginning of this post, so we won‚Äôt cover that again.</p><p>On my machine, a control group will typically be located in <code>/sys/fs/cgroup/devices/lxc/&lt;containerid&gt;</code>. Within that directory, you will find a pseudo-file called <code>tasks</code>. It contains the list of the PIDs that are in the control group, i.e., in the container. We can take any of them; so the first one will do.</p><p>Putting everything together, if the ‚Äúshort ID‚Äù of a container is held in the environment variable <code>$CID</code>, here is a small shell snippet to put everything together:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token assign-left variable">TASKS</span><span class="token operator">=</span>/sys/fs/cgroup/devices/<span class="token variable">$CID</span>*/tasks</span>
<span class="line"><span class="token assign-left variable">PID</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> $TASKS<span class="token variable">)</span></span></span>
<span class="line"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/run/netns</span>
<span class="line"><span class="token function">ln</span> <span class="token parameter variable">-sf</span> /proc/<span class="token variable">$PID</span>/ns/net /var/run/netns/<span class="token variable">$CID</span></span>
<span class="line"><span class="token function">ip</span> netns <span class="token builtin class-name">exec</span> <span class="token variable">$CID</span> <span class="token function">netstat</span> <span class="token parameter variable">-i</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,18)),t("p",null,[e[33]||(e[33]=o("The same mechanism is used in ",-1)),t("a",P,[e[30]||(e[30]=o("Pipework (",-1)),n(r,{icon:"iconfont icon-github"}),e[31]||(e[31]=t("code",null,"jpetazzo/pipework",-1)),e[32]||(e[32]=o(")",-1))]),e[34]||(e[34]=o(" to setup network interfaces within containers ",-1)),e[35]||(e[35]=t("em",null,"from outside",-1)),e[36]||(e[36]=o(" the containers.",-1))]),e[59]||(e[59]=i('<h4 id="tips-for-high-performance-metric-collection" tabindex="-1"><a class="header-anchor" href="#tips-for-high-performance-metric-collection"><span>Tips for high-performance metric collection</span></a></h4><p>Note that running a new process each time you want to update metrics is (relatively) expensive. If you want to collect metrics at high resolutions, and/or over a large number of containers (think 1000 containers on a single host), you do not want to fork a new process each time.</p><p>Here is how to collect metrics from a single process. You will have to write your metric collector in C (or any language that lets you do low-level system calls). You need to use a special system call, <code>setns()</code>, which lets the current process enter any arbitrary namespace. It requires, however, an open file descriptor to the namespace pseudo-file (remember: that‚Äôs the pseudo-file in <code>/proc/&lt;pid&gt;/ns/net</code>).</p><p>However, there is a catch: you must not keep this file descriptor open. If you do, when the last process of the control group exits, the namespace will not be destroyed, and its network resources (like the virtual interface of the container) will stay around for ever (or until you close that file descriptor).</p><p>The right approach would be to keep track of the first PID of each container, and re-open the namespace pseudo-file each time.</p><hr><h2 id="collecting-metrics-when-a-container-exits" tabindex="-1"><a class="header-anchor" href="#collecting-metrics-when-a-container-exits"><span>Collecting metrics when a container exits</span></a></h2><p>Sometimes, you do not care about real time metric collection, but when a container exits, you want to know how much CPU, memory, etc. it has used.</p><p>The current implementation of Docker (as of 0.6) makes this particularly challenging, because it relies on <code>lxc-start</code>, and when a container stops, <code>lxc-start</code> carefully cleans up behind it. If you really want to collect the metrics anyway, here is how. For each container, start a collection process, and move it to the control groups that you want to monitor by writing its PID to the <code>tasks</code> file of the cgroup. The collection process should periodically re-read the <code>tasks</code> file to check if it‚Äôs the last process of the control group. (If you also want to collect network statistics as explained in the previous section, you should also move the process to the appropriate network namespace.)</p><p>When the container exits, <code>lxc-start</code> will try to delete the control groups. It will fail, since the control group is still in use; but that‚Äôs fine. You process should now detect that it is the only one remaining in the group. Now is the right time to collect all the metrics you need!</p><p>Finally, your process should move itself back to the root control group, and remove the container control group. To remove a control group, just <code>rmdir</code> its directory. It‚Äôs counter-intuitive to <code>rmdir</code> a directory as it still contains files; but remember that this is a pseudo-filesystem, so usual rules don‚Äôt apply. After the cleanup is done, the collection process can exit safely.</p><p>As you can see, collecting metrics when a container exits can be tricky; for this reason, it is usually easier to collect metrics at regular intervals (e.g. every minute, with the collectd LXC plugin) and rely on that instead.</p><hr><h2 id="wrapping-it-up" tabindex="-1"><a class="header-anchor" href="#wrapping-it-up"><span>Wrapping it up</span></a></h2><p>To recap, we covered:</p><ul><li>how to locate the control groups for containers;</li><li>reading and interpreting compute metrics for containers;</li><li>different ways to obtain network metrics for containers;</li><li>a technique to gather overall metrics when a container exits.</li></ul><p>As we have seen, metrics collection is not insanely difficult, but still involves many complicated steps, with special cases like those for the network subsystem. Docker will take care of this, or at least expose hooks to make it more straightforward. It is one of the reasons why we repeat over and over ‚ÄúDocker is not production ready yet‚Äù: it‚Äôs fine to skip metrics for development, continuous testing, or staging environments, but it‚Äôs definitely <em>not fine</em> to run production services without metrics!</p>',17)),t("p",null,[e[42]||(e[42]=o("Last but not least, note that even with all that information, you will still need a storage and graphing system for those metrics. There are many such systems out there. If you want something that you can deploy on your own, you can check e.g. ",-1)),t("a",j,[n(r,{icon:"fas fa-globe"}),e[37]||(e[37]=o("collectd",-1))]),e[43]||(e[43]=o(" or ",-1)),t("a",S,[n(r,{icon:"fas fa-globe"}),e[38]||(e[38]=o("Graphite",-1))]),e[44]||(e[44]=o(". There are also ‚Äú-as-a-Service‚Äù offerings. Those services will store your metrics and let you query them in various ways, for a given price. Some examples include ",-1)),t("a",z,[n(r,{icon:"fas fa-globe"}),e[39]||(e[39]=o("Librato",-1))]),e[45]||(e[45]=o(", ",-1)),t("a",A,[n(r,{icon:"fa-brands fa-aws"}),e[40]||(e[40]=o("AWS CloudWatch",-1))]),e[46]||(e[46]=o(", ",-1)),t("a",L,[n(r,{icon:"fas fa-globe"}),e[41]||(e[41]=o("New Relic Server Monitoring",-1))]),e[47]||(e[47]=o(", and many more.",-1))]),t("div",O,[e[53]||(e[53]=t("p",{class:"hint-container-title"},"About J√©r√¥me Petazzoni",-1)),e[54]||(e[54]=t("figure",null,[t("img",{src:"https://docker.com/app/uploads/2013/08/jerome_docker_in_docker_squ.jpg",alt:"J√©r√¥me Petazzoni",tabindex:"0",loading:"lazy"}),t("figcaption",null,"J√©r√¥me Petazzoni")],-1)),t("p",null,[e[49]||(e[49]=o("J√©r√¥me is a senior engineer at dotCloud, where he rotates between Ops, Support and Evangelist duties and has earned the nickname of ‚Äúmaster Yoda‚Äù. In a previous life he built and operated large scale Xen hosting back when EC2 was ",-1)),t("a",_,[n(r,{icon:"fa-brands fa-wikipedia-w"}),e[48]||(e[48]=o("just the name of a plane",-1))]),e[50]||(e[50]=o(", supervized the deployment of fiber interconnects through the French subway, built a specialized GIS to visualize fiber infrastructure, specialized in commando deployments of large-scale computer systems in bandwidth-constrained environments such as conference centers, and various other feats of technical wizardry. He cares for the servers powering dotCloud, helps our users feel at home on the platform, and documents the many ways to use dotCloud in articles, tutorials and sample applications. He‚Äôs also an avid dotCloud power user who has deployed just about anything on dotCloud - look for one of his many custom services on our Github repository.",-1))]),t("p",null,[t("em",null,[e[52]||(e[52]=o("Connect with J√©r√¥me on Twitter! ",-1)),t("a",U,[n(r,{icon:"fa-brands fa-x-twitter"}),e[51]||(e[51]=t("code",null,"@jpetazzo",-1))])])])]),f(" TODO: add ARTICLE CARD "),n(c,p(d({title:"Gathering LXC and Docker containers metricsDocker",desc:"Learn from Docker experts to simplify and advance your app development and management with Docker. Stay up to date on Docker events and new version",link:"https://chanhi2000.github.io/bookshelf/docker.com/gathering-lxc-docker-containers-metrics.html",logo:"https://docker.com/app/uploads/2024/02/cropped-docker-logo-favicon-192x192.png",background:"rgba(29,99,237,0.2)"})),null,16)])}const N=m(w,[["render",W]]),X=JSON.parse('{"path":"/docker.com/gathering-lxc-docker-containers-metrics.html","title":"Gathering LXC and Docker containers metricsDocker","lang":"en-US","frontmatter":{"lang":"en-US","title":"Gathering LXC and Docker containers metricsDocker","description":"Article(s) > Gathering LXC and Docker containers metricsDocker","icon":"fa-brands fa-docker","category":["DevOps","Docker","Article(s)"],"tag":["blog","docker.com","devops","docker"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Gathering LXC and Docker containers metricsDocker\\",\\"image\\":[\\"https://docker.com/app/uploads/2013/08/jerome_docker_in_docker_squ.jpg\\"],\\"datePublished\\":\\"2013-10-09T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"J√©r√¥me Petazzoni\\",\\"url\\":\\"https://docker.com/author/jerome/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/docker.com/gathering-lxc-docker-containers-metrics.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Gathering LXC and Docker containers metricsDocker"}],["meta",{"property":"og:description","content":"Article(s) > Gathering LXC and Docker containers metricsDocker"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docker.com/app/uploads/2013/08/jerome_docker_in_docker_squ.jpg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://docker.com/app/uploads/2013/08/jerome_docker_in_docker_squ.jpg"}],["meta",{"name":"twitter:image:alt","content":"Gathering LXC and Docker containers metricsDocker"}],["meta",{"property":"article:author","content":"J√©r√¥me Petazzoni"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"docker.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2013-10-09T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Gathering LXC and Docker containers metricsDocker"},{"property":"og:description","content":"Gathering LXC and Docker containers metricsDocker"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/docker.com/gathering-lxc-docker-containers-metrics.html"}]],"prev":"/devops/docker/articles/README.md","date":"2013-10-09T00:00:00.000Z","isOriginal":false,"author":[{"name":"J√©r√¥me Petazzoni","url":"https://docker.com/author/jerome/"}],"cover":"https://docker.com/app/uploads/2013/08/jerome_docker_in_docker_squ.jpg"},"git":{},"readingTime":{"minutes":14.66,"words":4399},"filePathRelative":"docker.com/gathering-lxc-docker-containers-metrics.md","copyright":{"author":"J√©r√¥me Petazzoni"}}');export{N as comp,X as data};
