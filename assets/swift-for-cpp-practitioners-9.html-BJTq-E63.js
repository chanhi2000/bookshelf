import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,d as s,f as t,b as p,t as h,n as r,g as u,w as o,e as a,r as l,o as b}from"./app-BItykJLQ.js";const v={},f={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},y={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},w={class:"table-of-contents"},x={href:"https://developer.apple.com/documentation/swift/expressiblebyintegerliteral",target:"_blank",rel:"noopener noreferrer"},S={href:"https://developer.apple.com/documentation/swift/expressiblebyfloatliteral",target:"_blank",rel:"noopener noreferrer"},q={href:"https://developer.apple.com/documentation/swift/expressiblebybooleanliteral",target:"_blank",rel:"noopener noreferrer"},I={href:"https://developer.apple.com/documentation/swift/expressiblebystringliteral",target:"_blank",rel:"noopener noreferrer"},L={href:"https://developer.apple.com/documentation/swift/expressiblebystringinterpolation",target:"_blank",rel:"noopener noreferrer"},E={href:"https://developer.apple.com/documentation/swift/expressiblebynilliteral",target:"_blank",rel:"noopener noreferrer"},C={href:"https://developer.apple.com/documentation/swift/expressiblebyarrayliteral",target:"_blank",rel:"noopener noreferrer"},B={href:"https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral",target:"_blank",rel:"noopener noreferrer"},T={href:"https://cplusplus.com/reference/sstream/ostringstream/",target:"_blank",rel:"noopener noreferrer"},N={href:"https://github.com/swiftlang/swift-syntax?tab=readme-ov-file",target:"_blank",rel:"noopener noreferrer"},j={href:"https://developer.apple.com/documentation/swift/defaultstringinterpolation",target:"_blank",rel:"noopener noreferrer"};function O(k,n){const c=l("VPCard"),i=l("router-link"),d=l("RouteLink"),e=l("VPIcon");return b(),g("div",null,[s("h1",f,[s("a",y,[s("span",null,h(k.$frontmatter.title)+" ê´€ë ¨",1)])]),t(c,r(u({title:"Swift > Article(s)",desc:"Article(s)",link:"/programming/swift/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t(c,r(u({title:"C++ > Article(s)",desc:"Article(s)",link:"/programming/cpp/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",w,[s("ul",null,[s("li",null,[t(i,{to:"#the-expressibleby-literal-protocols"},{default:o(()=>[...n[0]||(n[0]=[a("The ExpressibleBy*Literal protocols",-1)])]),_:1}),s("ul",null,[s("li",null,[t(i,{to:"#aside-hashing-in-swift"},{default:o(()=>[...n[1]||(n[1]=[a("Aside: Hashing in Swift",-1)])]),_:1})])])]),s("li",null,[t(i,{to:"#strings-and-characters"},{default:o(()=>[...n[2]||(n[2]=[a("Strings and characters",-1)])]),_:1})]),s("li",null,[t(i,{to:"#string-interpolation"},{default:o(()=>[...n[3]||(n[3]=[a("String interpolation",-1)])]),_:1}),s("ul",null,[s("li",null,[t(i,{to:"#the-expressiblebystringinterpolation-protocol"},{default:o(()=>[...n[4]||(n[4]=[a("The ExpressibleByStringInterpolation protocol",-1)])]),_:1})]),s("li",null,[t(i,{to:"#string-interpolation-in-action"},{default:o(()=>[...n[5]||(n[5]=[a("String interpolation in action",-1)])]),_:1})]),s("li",null,[t(i,{to:"#extending-the-default-string-interpolation-behavior"},{default:o(()=>[...n[6]||(n[6]=[a("Extending the default string interpolation behavior",-1)])]),_:1})])])]),s("li",null,[t(i,{to:"#wrap-up-and-what-s-next"},{default:o(()=>[...n[7]||(n[7]=[a("Wrap-up and what's next?",-1)])]),_:1})])])]),n[63]||(n[63]=s("hr",null,null,-1)),t(c,r(u({title:"Swift for C++ Practitioners, Part 9: Extensible Literals | Doug's Compiler Corner",desc:"Swift for C++ Practitioners, Part 9: Extensible Literals",link:"https://www.douggregor.net/posts/swift-for-cxx-practitioners-literals/",background:"rgba(22,22,22,0.2)"})),null,16),n[64]||(n[64]=s("p",null,[a("One of the things that I "),s("em",null,"really"),a(" liked about C++ was the ability to create great libraries: the combination of classes, templates, and operator overloading made it possible to create abstractions that nicely describe a subject domain (whether graphs, matrices, parsers, whatever) within a library.")],-1)),s("p",null,[n[10]||(n[10]=a("Swift provides similar affordances to create the right abstractions to model a subject domain. I've already talked about ",-1)),t(d,{to:"/douggregor.net/swift-for-cpp-practitioners-1.html"},{default:o(()=>[...n[8]||(n[8]=[a("value types",-1)])]),_:1}),n[11]||(n[11]=a(" and ",-1)),t(d,{to:"/douggregor.net/swift-for-cpp-practitioners-4.html"},{default:o(()=>[...n[9]||(n[9]=[a("generics",-1)])]),_:1}),n[12]||(n[12]=a(" at length, so we won't go into those again. However, Swift also has additional features that let you customize the language to your needs, including the ability to interact with literals (like ",-1)),n[13]||(n[13]=s("code",null,"0",-1)),n[14]||(n[14]=a(" or ",-1)),n[15]||(n[15]=s("code",null,'"https://douggregor.net"',-1)),n[16]||(n[16]=a("), overload operators to your heart's content, provide specific access behavior for properties, or define your own declarative sub-language (DSL) embedded in Swift. These features, used well, can enable beautiful library designs that get at the heart of describing a domain.",-1))]),n[65]||(n[65]=p(`<p>I&#39;m going to tackle language extensibility in several different posts, because there&#39;s a lot to explore, including a few side quests into other parts of the language. For this post, we&#39;re going to dive ito something that you use everyday but probably don&#39;t think about much in C++: literals.</p><p>Literals are constant values written in the source code. In Swift, there are quite a few different kinds of literals:</p><ul><li><em>Integer literals</em>: numbers like <code>42</code> and <code>-10</code>.</li><li><em>Floating-point literals</em>: numbers like <code>3.14159</code></li><li><em>Boolean literals</em>: <code>true</code> and <code>false</code></li><li><em>String literals</em>: strings like <code>&quot;Hello, world!&quot;</code></li><li><em>Interpolated string literals</em>: strings with interpolations in them, such as <code>&quot;Hello, \\(name)!&quot;</code></li><li><em>Nil literal</em>: <code>nil</code></li><li><em>Array literal</em>: an array of things, such as <code>[a, b, c]</code></li><li><em>Dictionary literal</em>: a list of key-value pairs, such as <code>[a: x, b: y, c: z]</code></li></ul><p>In most programming languages, literals have a specific type. <code>0</code> in C++ is an <code>int</code>, <code>3.14159</code> is a <code>double</code>. C++ also has suffixes that are part of the literal to let you change the literal type: <code>0u</code> is an <code>unsigned int</code>, <code>3.14159f</code> is a <code>float</code>, and so on. C++ also allows many kinds of implicit conversion, which lets us be somewhat cavalier with the exact type of literals: you can write <code>int8_t x = 64;</code> and the literal <code>int</code> will be implicitly converted to <code>int8_t</code>. One hopes to get a compiler warning if the literal doesn&#39;t fit into the type of <code>x</code>.</p><p>In Swift, literals pick up the type of their enclosing context. So, we can write the equivalent to the above <code>x</code> as:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token class-name">UInt8</span> <span class="token operator">=</span> <span class="token number">64</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>and the literal <code>64</code> will pick up the type <code>UInt8</code> from its context. You can also be explicit about what type you want your literal to have by using the <code>as</code> operator: <code>64 as UInt8</code> will ensure that the integer literal <code>64</code> is treated as a <code>UInt8</code>. You can use the <code>as</code> operator to perform an implicit conversion explicitly in Swift: <code>x as Any</code> will put the value of <code>x</code> into a value types as <code>Any</code>.</p><p>With the so-called &quot;collection&quot; literals (for arrays and dictionaries), the contextual type can affect both the collection type and its element type. For example, if I were to write:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> numbers<span class="token punctuation">:</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">UInt8</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span> <span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Then the array literal has type <code>Set&lt;&lt;&gt;UInt8&gt;</code>, meaning that each of the elements in the array literal will have type <code>UInt8</code>. This inference can go both ways: consider something like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> someNumbers<span class="token punctuation">:</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token omit keyword">_</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span> <span class="token keyword">as</span> <span class="token class-name">UInt8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">64</span> <span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The <code>_</code> is a placeholder for &quot;I don&#39;t want to write the type, figure it out for me&quot;. I&#39;ve specified that I want a <code>Set</code>, so the array literal will be of a <code>Set</code> type, but the element type will be dictated by the array literal elements themselves: here the only one given a specific type is given <code>UInt8</code>, so the type of <code>someNumbers</code> will be <code>Set&lt;&lt;&gt;UInt8&gt;</code>.</p><p>If there is no contextual type for a literal, it will default to an appropriate type: <code>Bool</code> for Boolean literals, <code>Int</code> for integer literals, <code>Double</code> for floating-point literals, <code>String</code> for string literals, <code>Array</code> for array literals, and <code>Dictionary</code> for dictionary literals. This is what enables type inference for something like</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> favoriteConstants <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string-literal"><span class="token string">&quot;Ï€&quot;</span></span> <span class="token punctuation">:</span> <span class="token number">3.14159</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;e&quot;</span></span><span class="token punctuation">:</span> <span class="token number">2.71828</span> <span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>to determine that <code>favoriteConstants</code> has the type <code>[String: Double]</code> aka <code>Dictionary&lt;&lt;&gt;String, Double&gt;</code>.</p><p>Type inference is nice and all, but I promised <em>extensibility</em>. Let&#39;s get to that.</p><hr><h2 id="the-expressibleby-literal-protocols" tabindex="-1"><a class="header-anchor" href="#the-expressibleby-literal-protocols"><span>The <code>ExpressibleBy*Literal</code> protocols</span></a></h2><p>The types I listed above that work as literal types aren&#39;t magical. They are defined in the standard library, and declare conformances to protocols in the &quot;expressible by&quot; family. Each kind of literal has one or more protocols associated with it: a type that conforms to one of these protocols can be constructed from the corresponding literal type. Here&#39;s the mapping from literal kinds to protocols:</p>`,19)),s("ul",null,[s("li",null,[n[18]||(n[18]=s("em",null,"Integer literals",-1)),n[19]||(n[19]=a(": ",-1)),s("a",x,[t(e,{icon:"fa-brands fa-apple"}),n[17]||(n[17]=s("code",null,"ExpressibleByIntegerLiteral",-1))])]),s("li",null,[n[21]||(n[21]=s("em",null,"Floating-point literals",-1)),n[22]||(n[22]=a(": ",-1)),s("a",S,[t(e,{icon:"fa-brands fa-apple"}),n[20]||(n[20]=s("code",null,"ExpressibleByFloatLiteral",-1))])]),s("li",null,[n[24]||(n[24]=s("em",null,"Boolean literals",-1)),n[25]||(n[25]=a(": ",-1)),s("a",q,[t(e,{icon:"fa-brands fa-apple"}),n[23]||(n[23]=s("code",null,"ExpressibleByBooleanLiteral",-1))])]),s("li",null,[n[27]||(n[27]=s("em",null,"String literals",-1)),n[28]||(n[28]=a(": ",-1)),s("a",I,[t(e,{icon:"fa-brands fa-apple"}),n[26]||(n[26]=s("code",null,"ExpressibleByStringLiteral",-1))]),n[29]||(n[29]=a(" (and friends; we'll get there')",-1))]),s("li",null,[n[31]||(n[31]=s("em",null,"Interpolated string literals",-1)),n[32]||(n[32]=a(": ",-1)),s("a",L,[t(e,{icon:"fa-brands fa-apple"}),n[30]||(n[30]=s("code",null,"ExpressibleByStringInterpolation",-1))])]),s("li",null,[n[34]||(n[34]=s("em",null,"Nil literal",-1)),n[35]||(n[35]=a(": ",-1)),s("a",E,[t(e,{icon:"fa-brands fa-apple"}),n[33]||(n[33]=s("code",null,"ExpressibleByNilLiteral",-1))])]),s("li",null,[n[37]||(n[37]=s("em",null,"Array literal",-1)),n[38]||(n[38]=a(": ",-1)),s("a",C,[t(e,{icon:"fa-brands fa-apple"}),n[36]||(n[36]=s("code",null,"ExpressibleByArrayLiteral",-1))])]),s("li",null,[n[40]||(n[40]=s("em",null,"Dictionary literal",-1)),n[41]||(n[41]=a(": ",-1)),s("a",B,[t(e,{icon:"fa-brands fa-apple"}),n[39]||(n[39]=s("code",null,"ExpressibleByDictionaryLiteral",-1))])])]),n[66]||(n[66]=p(`<p>If you had some kind of collection type that you wanted to work be constructible from an array literal, you would make it conform to <code>ExpressibleByArrayLiteral</code>. For our example, let&#39;s create a single type that conforms to <em>lots</em> of these protocols: a representation of a JSON value. We can describe any JSON value as an enum, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">enum</span> <span class="token class-name">JSONValue</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">case</span> null</span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">number</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">JSONValue</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">dictionary</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token class-name">JSONValue</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We can represent the JSON <code>null</code> value with a <code>nil</code> literal by introducing a conformance to <code>ExpressibleByNilLiteral</code>, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">JSONValue</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByNilLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>nilLiteral<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>null</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There&#39;s one oddity here to point out: the parameter <code>nilLiteral</code> has the type <code>()</code>, which is an empty tuple. Here, it&#39;s used so that we can provide a special name for this initializer (<code>init(nilLiteral:)</code>) even though there&#39;s no need for a specific value with a <code>nil</code> literal. Fun fact: the Swift standard library has a type <code>Void</code> that&#39;s defined like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">typealias</span> <span class="token class-name">Void</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Functions that have no specified return type in Swift are said to return <code>Void</code>, somewhat like in C++. But the analogy to C++ <code>void</code> stops there. Empty tuple types are normal types in Swift: you can have variables and properties of empty tuple type, and they have a size of zero (<em>gasp</em>). One can create a value of empty tuple type with the expression <code>()</code>. Some languages refer to these types as &quot;unit&quot; types.</p><p>For the next two cases of <code>JSONValue</code>, we can provide string, integer, and floating-point literal conformances:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">JSONValue</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByStringLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>stringLiteral value<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">JSONValue</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByIntegerLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>integerLiteral value<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token function">number</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">JSONValue</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByFloatLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>floatLiteral value<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token function">number</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We can now create a <code>JSONValue</code> instance from a nil literal (<code>nil</code>), string literal (<code>&quot;Hello&quot;</code>), integer literal (&#39;42&#39;), or floating-point literal (&#39;3.14159&#39;).</p><p>Let&#39;s do some collections to finish it off:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">JSONValue</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByArrayLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>arrayLiteral elements<span class="token punctuation">:</span> <span class="token class-name">JSONValue</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span>elements<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">JSONValue</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByDictionaryLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>dictionaryLiteral elements<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">JSONValue</span><span class="token punctuation">)</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token function">dictionary</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>uniqueKeysWithValues<span class="token punctuation">:</span> elements<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The only new bit of syntax is the <code>...</code>. These are variadic parameters (not variadic <em>generics</em>), which accept any number of arguments, all of the same type. Within the body of the function/initializer, variadic parameters are accessed as arrays. So, the <code>init(arrayLiteral:)</code> initializer can directly put the <code>elements</code> array into its <code>array</code> case, because it already contains JSON values. The <code>init(dictionaryLiteral:)</code> initializer accepts an array of <code>(String, JSONValue)</code> pairs, which it uniques based on key to place in the dictionary.</p><p>Now, we can go ahead and write out JSON literals in Swift:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> math<span class="token punctuation">:</span> <span class="token class-name">JSONValue</span> <span class="token operator">=</span> <span class="token punctuation">[</span> </span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;Ï€&quot;</span></span> <span class="token punctuation">:</span> <span class="token number">3.14159</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;e&quot;</span></span><span class="token punctuation">:</span> <span class="token number">2.71828</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;i&quot;</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;sqrt(i)&quot;</span></span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;zero&quot;</span></span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;undefined&quot;</span></span><span class="token punctuation">:</span> <span class="token nil constant">nil</span></span>
<span class="line"><span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we were to print the above variable without any additional customization, we&#39;d get something like this (formatting is mine):</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token function">dictionary</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token punctuation">[</span></span>
<span class="line">    <span class="token string-literal"><span class="token string">&quot;zero&quot;</span></span><span class="token punctuation">:</span> <span class="token class-name">Extensibility</span><span class="token punctuation">.</span><span class="token class-name">JSONValue</span><span class="token punctuation">.</span><span class="token function">number</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string-literal"><span class="token string">&quot;Ï€&quot;</span></span><span class="token punctuation">:</span> <span class="token class-name">Extensibility</span><span class="token punctuation">.</span><span class="token class-name">JSONValue</span><span class="token punctuation">.</span><span class="token function">number</span><span class="token punctuation">(</span><span class="token number">3.14159</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string-literal"><span class="token string">&quot;i&quot;</span></span><span class="token punctuation">:</span> <span class="token class-name">Extensibility</span><span class="token punctuation">.</span><span class="token class-name">JSONValue</span><span class="token punctuation">.</span><span class="token function">object</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;sqrt(i)&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string-literal"><span class="token string">&quot;e&quot;</span></span><span class="token punctuation">:</span> <span class="token class-name">Extensibility</span><span class="token punctuation">.</span><span class="token class-name">JSONValue</span><span class="token punctuation">.</span><span class="token function">number</span><span class="token punctuation">(</span><span class="token number">2.71828</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token string-literal"><span class="token string">&quot;undefined&quot;</span></span><span class="token punctuation">:</span> <span class="token class-name">Extensibility</span><span class="token punctuation">.</span><span class="token class-name">JSONValue</span><span class="token punctuation">.</span>null</span>
<span class="line">  <span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="aside-hashing-in-swift" tabindex="-1"><a class="header-anchor" href="#aside-hashing-in-swift"><span>Aside: Hashing in Swift</span></a></h3><p>If you try the above example yourself, you might notice an interesting difference in the output: the dictionary key/value pairs could get printed in a different order from what I have above. Run the program again---you&#39;ll likely get a different order! Swift&#39;s hashed collections (<code>Dictionary</code> and <code>Set</code>) choose a random seed at program start to mix into hash elements, so you&#39;ll get different hash values for the same values from one run to the next. This was motivated partially by security and partially to promote correctness.</p><p>The security angle is that knowing how a hash table performs hashes allows you to craft a set of inputs that all hash to the same value, making operations on the hash table linear when they shouldn&#39;t be, leading to a potential denial-of-service attack. By changing the random seed on each execution, it makes it harder to provide a set of inputs like this.</p><p>The correctness angle is, essentially, that it&#39;s often too easy to mistakenly depend on the iteration order of a hashed data structure or the specific hash value of a type. One approach I&#39;ve seen proposed for C++ is to prohibit iteration on hashed data structures entirely (e.g., by not providing <code>begin</code>/<code>end</code> on a custom version of <code>unordered_map</code> or <code>unordered_set</code>). Swift&#39;s approach to allow the iteration, but have the ordering changing from one program run to the next. That way, you can iterate to make use of collection algorithms, but if it affects your output (e.g., because you forgot to sort at the end), you&#39;re very likely to notice because your unit tests will break.</p><hr><h2 id="strings-and-characters" tabindex="-1"><a class="header-anchor" href="#strings-and-characters"><span>Strings and characters</span></a></h2><p>String literals have their own hierarchy of protocols. <code>ExpressibleByStringLiteral</code> is the most capable, allowing an arbitrary, well-formed UTF-8 string literal. A string literal like <code>&quot;Hello&quot;</code> will go through this protocol.</p><p><code>ExpressibleByStringLiteral</code> inherits from the <code>ExpressibleByExtendedGraphemeClusterLiteral</code> protocol. The name is a mouthful, but this protocol is used for string literals that consist of a single extended grapheme cluster---the closest thing what a human would think of as a &quot;character&quot;. The string literal &quot;ðŸ‡ºðŸ‡¦&quot; is a single extended grapheme cluster (although it has several Unicode scalars in it). Any type that conforms to <code>ExpressibleByStringLiteral</code> can handle such a string literal, but the converse is not true: some types might only be able to represent a single character, not an entire string. The standard library&#39;s <code>Character</code> type, for example, conforms to only <code>ExpressibleByExtendedGraphemeClusterLiteral</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> c1<span class="token punctuation">:</span> <span class="token class-name">Character</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;ðŸ‡ºðŸ‡¦&quot;</span></span>      <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string-literal"><span class="token string">&quot;comment&quot;</span></span><span class="token operator">&gt;</span><span class="token comment">// okay</span></span>
<span class="line"><span class="token keyword">let</span> c2<span class="token punctuation">:</span> <span class="token class-name">Character</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span>   <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string-literal"><span class="token string">&quot;comment&quot;</span></span><span class="token operator">&gt;</span><span class="token comment">// error: Character does not conform to ExpressibleByStringLiteral</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>There is one more protocol in the string literal family: <code>ExpressibleByUnicodeScalarLiteral</code>, from which <code>ExpressibleByExtendedGraphemeClusterLiteral</code> inherits, handles string literals that can be represented by a single Unicode scalar such as <code>&quot;!&quot;</code> or <code>&quot;ê¹€&quot;</code>. The <code>Unicode.Scalar</code> type in the Swift standard library conforms to this protocol. One benefit to <code>ExpressibleByUnicodeScalarLiteral</code> is that all Unicode scalars can fit into a single 32-bit word, whereas extended grapheme clusters can require several scalars.</p><hr><h2 id="string-interpolation" tabindex="-1"><a class="header-anchor" href="#string-interpolation"><span>String interpolation</span></a></h2><p>The final &quot;expressible by&quot; protocol we&#39;ll explore is <code>ExpressibleByStringInterpolation</code>. This is the protocol a type can conform to for string literals that include interpolations, i.e., something like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Ï€=</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token number">3.14159</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, but the answer is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token number">42</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,31)),s("p",null,[n[43]||(n[43]=a("The closest analogy in C++ is probably output streaming (with ",-1)),n[44]||(n[44]=s("code",null,">>",-1)),n[45]||(n[45]=a(") to a ",-1)),s("a",T,[t(e,{icon:"iconfont icon-cpp"}),n[42]||(n[42]=s("code",null,"std::ostringstream",-1))]),n[46]||(n[46]=a(", which lets you mix string literals and values to be formatted. That's a pure library solution; in Swift, we have string interpolation syntax in the language, and libraries can opt in to supporting string interpolation by conforming to ",-1)),n[47]||(n[47]=s("code",null,"ExpressibleByStringInterpolation",-1)),n[48]||(n[48]=a(". Why might a library want to do that? Well, you can think of string interpolation as a general templating engine built that lets you layer on type safety in an appropriate manner.",-1))]),n[67]||(n[67]=p(`<p>Say you want to create a SQL query that&#39;s customized by some user-supplied values. You could absolutely do this with normal strings and interpolation:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> query<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&quot;&quot;</span>
<span class="line">SELECT * FROM </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">tableName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"></span>
<span class="line">ORDER BY </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">fieldName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">;</span>
<span class="line">&quot;&quot;&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),s("p",null,[n[52]||(n[52]=a("That code just ",-1)),n[53]||(n[53]=s("em",null,"screams",-1)),n[54]||(n[54]=a(` "SQL injection attack", so we need to do better. By creating a SQL query type that supports string interpolation, it can make sure to properly escape any values interpolated into the string, as well as performing any other validation that's needed. The `,-1)),s("a",N,[n[49]||(n[49]=a("swift-syntax package (",-1)),t(e,{icon:"iconfont icon-github"}),n[50]||(n[50]=s("code",null,"swiftlang/swift-syntax",-1)),n[51]||(n[51]=a(")",-1))]),n[55]||(n[55]=a(" for manipulating Swift source code uses this approach to make it easy to create Swift source code from templates, like this:",-1))]),n[68]||(n[68]=p(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> sourceFile<span class="token punctuation">:</span> <span class="token class-name">SourceFileSyntax</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;&quot;&quot;</span>
<span class="line">let </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">varName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: Int = </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"></span>
<span class="line">print(</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">varName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> + 42)</span>
<span class="line">&quot;&quot;&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="the-expressiblebystringinterpolation-protocol" tabindex="-1"><a class="header-anchor" href="#the-expressiblebystringinterpolation-protocol"><span>The <code>ExpressibleByStringInterpolation</code> protocol</span></a></h3><p>To create your own strongly-typed templating solution with string interpolation, you&#39;ll need to create a type that conforms to the <code>ExpressibleByStringInterpolation</code> protocol:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">ExpressibleByStringInterpolation</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByStringLiteral</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">StringInterpolation</span><span class="token punctuation">:</span> <span class="token class-name">StringInterpolationProtocol</span> <span class="token operator">=</span> <span class="token keyword">where</span> <span class="token class-name">StringLiteralType</span> <span class="token operator">==</span> <span class="token class-name">StringInterpolation</span><span class="token punctuation">.</span><span class="token class-name">StringLiteralType</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>stringInterpolation<span class="token punctuation">:</span> <span class="token class-name">StringInterpolation</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ExpressibleByStringInterpolation</code> inherits from <code>ExpressibleByStringLiteral</code>, because anything that can be created from a string interpolation must also be able to handle the simpler case of a non-interpolated string literal. For a string interpolation with a given contextual type (let&#39;s call it <code>MyString</code>), the compiler will create an instance of the type <code>MyString.StringInterpolation</code> to collect the various parts of the string interpolation. That instance will then be passed into <code>init(stringInterpolation:)</code> to create the final string.</p><p>The <code>StringInterpolation</code> type conforms to the <code>StringInterpolationProtocol</code> protocol, which is a little odd because it only lists two requirements... even though the compiler requires that every type conforming to <code>StringInterpolationProtocol</code> support addition operations <em>not</em> described by the requirements. We refer to this as an <em>ad hoc</em> protocol, and it&#39;s a pragmatic compromise: we lose some descriptive benefits (you can&#39;t just look at the protocol to figure out how to write a fully-conforming type), but we gain a bit of expressive power through the use of overloading. We&#39;ll get back to that last part in a bit; for now, here&#39;s the protocol as written:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">StringInterpolationProtocol</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">StringLiteralType</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>literalCapacity<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> interpolationCount<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">appendLiteral</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> literal<span class="token punctuation">:</span> <span class="token class-name">StringLiteralType</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The initializer (<code>init(literalCapacity:interpolationCount:)</code>) is called to initialize an instance of the <code>StringInterpolation</code> type, and is provided with the total number of characters in the string literal parts and the number of &quot;interpolation&quot; segments (for the values that are placed into string). So, if we have a string interpolation like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> myStr<span class="token punctuation">:</span> <span class="token class-name">MyString</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Ï€=</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token number">3.14159</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, but the answer is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token number">42</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The call to create the instance will be <code>MyString.StringInterpolation(literalCapacity: 23, interpolationCount: 2)</code>. Once created, the contents of the interpolation will be passed to the instance with method calls: <code>appendLiteral</code> for each string literal part (e.g., the first call is <code>appendLiteral(&quot;Ï€=&quot;)</code>) and <code>appendInterpolation</code> for each interpolated value (e.g., the second call is <code>appendInterpolation(3.14159)</code>), alternating. Once all of the pieces of the string interpolation have been sent to the <code>StringInterpolation</code> instance, that value is passed to the initializer of the <code>ExpressibleByStringInterpolation</code>-conforming type, i.e., <code>MyString(stringInterpolation: /*the MyString.StringInterpolation instance*/)</code>.</p><h3 id="string-interpolation-in-action" tabindex="-1"><a class="header-anchor" href="#string-interpolation-in-action"><span>String interpolation in action</span></a></h3><p>To see this in action, let&#39;s create a string interpolation type that&#39;s only for debugging purposes:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">struct</span> <span class="token class-name">MyString</span><span class="token punctuation">:</span> <span class="token class-name">ExpressibleByStringInterpolation</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">typealias</span> <span class="token class-name">StringLiteralType</span> <span class="token operator">=</span> <span class="token class-name">String</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">init</span><span class="token punctuation">(</span>stringLiteral value<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">#&quot;MyString(stringLiteral: &quot;</span><span class="token interpolation-punctuation punctuation">\\#(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;)&quot;#</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">init</span><span class="token punctuation">(</span>stringInterpolation<span class="token punctuation">:</span> <span class="token class-name">StringInterpolation</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;MyString(stringInterpolation:)&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">struct</span> <span class="token class-name">StringInterpolation</span><span class="token punctuation">:</span> <span class="token class-name">StringInterpolationProtocol</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">init</span><span class="token punctuation">(</span>literalCapacity<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> interpolationCount<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;MyString.StringInterpolation(literalCapacity: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">literalCapacity</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">, interpolationCount: </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">interpolationCount</span><span class="token interpolation-punctuation punctuation">)</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">appendLiteral</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">#&quot;appendLiteral(&quot;</span><span class="token interpolation-punctuation punctuation">\\#(</span><span class="token interpolation">string</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;)&quot;#</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">appendInterpolation</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">#&quot;appendInterpolation(</span><span class="token interpolation-punctuation punctuation">\\#(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: Int)&quot;#</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">appendInterpolation</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">#&quot;appendInterpolation(</span><span class="token interpolation-punctuation punctuation">\\#(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: Double)&quot;#</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When we initialize a value of type <code>MyString</code> from a string interpolation, we&#39;ll see the set of calls that will be performed. Here&#39;s the output from the string interpolation example we&#39;ve been using:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token class-name">MyString</span><span class="token punctuation">.</span><span class="token class-name">StringInterpolation</span><span class="token punctuation">(</span>literalCapacity<span class="token punctuation">:</span> <span class="token number">23</span><span class="token punctuation">,</span> interpolationCount<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendLiteral</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Ï€=&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendInterpolation</span><span class="token punctuation">(</span><span class="token number">3.14159</span><span class="token punctuation">:</span> <span class="token class-name">Double</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendLiteral</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;, but the answer is &quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendInterpolation</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendLiteral</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token class-name">MyString</span><span class="token punctuation">(</span>stringInterpolation<span class="token punctuation">:</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There are a few things to notice: the <code>appendLiteral</code> calls alternate with <code>appendInterpolation</code> calls, even when the string literal is empty. This means that there are always <code>interpolationCount * 2 + 1</code> calls to <code>appendLiteral</code> along with <code>interpolationCount</code> calls to <code>appendInterpolation</code>.</p><p>Additionally, the two interpolated values have different types (<code>Double</code> and <code>Int</code>, respectively), and end up calling different overloads of <code>appendInterpolation</code>. This is where the <em>ad hoc</em> nature of the <code>StringInterpolationProtocol</code> comes in: you can define different overloads of <code>appendInterpolation</code> for each of the types that your type is intended to support. If you don&#39;t want to support a type, don&#39;t provide an <code>appendInterpolation</code> overload for it. If you want to support entire classes of types, add a generic <code>appendInterpolation</code> with the appropriate constraints on it. Moreover, you can add additional parameters to <code>appendInterpolation</code> that can be used to customize rendering. For example, we could support an optional &quot;radix&quot; for integer interpolations:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">appendInterpolation</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">print</span><span class="token punctuation">(</span>#&quot;<span class="token function">appendInterpolation</span><span class="token punctuation">(</span><span class="token punctuation">\\</span>#<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token punctuation">\\</span>#<span class="token punctuation">(</span>radix<span class="token punctuation">)</span>&quot;<span class="token punctuation">)</span>#<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, if we have a string interpolation like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token string-literal"><span class="token string">&quot;The value of </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> in hexadecimal is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value<span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span> <span class="token keyword">as</span> <span class="token class-name">MyString</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>we&#39;ll get this series of calls:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token class-name">MyString</span><span class="token punctuation">.</span><span class="token class-name">StringInterpolation</span><span class="token punctuation">(</span>literalCapacity<span class="token punctuation">:</span> <span class="token number">32</span><span class="token punctuation">,</span> interpolationCount<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendLiteral</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The value of &quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendInterpolation</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendLiteral</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot; in hexadecimal is &quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendInterpolation</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">appendLiteral</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token class-name">MyString</span><span class="token punctuation">(</span>stringInterpolation<span class="token punctuation">:</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="extending-the-default-string-interpolation-behavior" tabindex="-1"><a class="header-anchor" href="#extending-the-default-string-interpolation-behavior"><span>Extending the default string interpolation behavior</span></a></h3>`,23)),s("p",null,[n[57]||(n[57]=a("If all you want is to customize the way your own types get interpolated into strings, you don't need to create a new ",-1)),n[58]||(n[58]=s("code",null,"ExpressibleByStringInterpolation",-1)),n[59]||(n[59]=a(" type at all. Instead, you can add on to the default string interpolation behavior by adding your own ",-1)),n[60]||(n[60]=s("code",null,"appendInterpolation",-1)),n[61]||(n[61]=a(" operations to the standard library's ",-1)),s("a",j,[t(e,{icon:"fa-brands fa-apple"}),n[56]||(n[56]=s("code",null,"DefaultStringInterpolation",-1))]),n[62]||(n[62]=a(" type. For example, say we want to be able to render a string with inline Markdown format, as described by this enum:",-1))]),n[69]||(n[69]=p(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">enum</span> <span class="token class-name">InlineMarkdownStyle</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">case</span> regular</span>
<span class="line">  <span class="token keyword">case</span> italicized</span>
<span class="line">  <span class="token keyword">case</span> bold</span>
<span class="line">  <span class="token keyword">case</span> underlined</span>
<span class="line">  <span class="token keyword">case</span> monospaced</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, we can add string interpolation support for supplying the inline markdown style to a string literal (but please do so with better escaping than I did):</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">DefaultStringInterpolation</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">appendInterpolation</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> markdownStyle<span class="token punctuation">:</span> <span class="token class-name">InlineMarkdownStyle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">switch</span> markdownStyle <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token punctuation">.</span>regular<span class="token punctuation">:</span>    <span class="token function">write</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token punctuation">.</span>italicized<span class="token punctuation">:</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;*</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">*&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token punctuation">.</span>bold<span class="token punctuation">:</span>       <span class="token function">write</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;**</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">**&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token punctuation">.</span>underlined<span class="token punctuation">:</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;_</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">_&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token punctuation">.</span>monospaced<span class="token punctuation">:</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;\`</span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">\`&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, we can do this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;String interpolation is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation"><span class="token string-literal"><span class="token string">&quot;so&quot;</span></span><span class="token punctuation">,</span> markdownStyle<span class="token punctuation">:</span> <span class="token punctuation">.</span>italicized&quot;</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">positiveAdjective<span class="token punctuation">,</span> markdownStyle<span class="token punctuation">:</span> <span class="token punctuation">.</span>bold</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">.&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>and if <code>positiveAdjective</code> were <code>&quot;cool&quot;</code>, this would print:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token class-name">String</span> interpolation <span class="token keyword">is</span> <span class="token operator">*</span>so<span class="token operator">*</span> <span class="token operator">**</span>cool<span class="token operator">**</span><span class="token punctuation">.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="wrap-up-and-what-s-next" tabindex="-1"><a class="header-anchor" href="#wrap-up-and-what-s-next"><span>Wrap-up and what&#39;s next?</span></a></h2><p>Literals in Swift are a surprisingly deep topic. The surface is very much like other languages, including C++: you have numeric literals, Boolean literals, and string literals, plus some additional support for array and dictionary literals that&#39;s straightforward. But Swift literals are affected by their contextual type, and any library can opt to supply its own literal types by conforming to the various \`ExpressibleBy<em>Literal</em> protocols, allowing one to express structured data cleanly. String interpolation is also highly extensible, allowing one to create type-safe templating engines that work well with the language syntax.</p><p>Next up, we&#39;re going to look at operator overloading, where the story is much the same: on the surface, it&#39;s fairly similar to C++ and other languages that have such overloading. But dig a little deeper and there&#39;s a world of customization you can do to create elegant domain-specific embedded languages (DSELs).</p>`,11))])}const A=m(v,[["render",O]]),D=JSON.parse('{"path":"/douggregor.net/swift-for-cpp-practitioners-9.html","title":"Swift for C++ Practitioners, Part 9: Extensible Literals","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Swift for C++ Practitioners, Part 9: Extensible Literals","description":"Article(s) > Swift for C++ Practitioners, Part 9: Extensible Literals","icon":"fa-brands fa-swift","category":["Swift","C++","Article(s)"],"tag":["blog","douggregor.net","swift","ios","c++","cpp"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Swift for C++ Practitioners, Part 9: Extensible Literals\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-28T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/douggregor.net/swift-for-cpp-practitioners-9.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Swift for C++ Practitioners, Part 9: Extensible Literals"}],["meta",{"property":"og:description","content":"Article(s) > Swift for C++ Practitioners, Part 9: Extensible Literals"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:tag","content":"c++"}],["meta",{"property":"article:tag","content":"ios"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"douggregor.net"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-09-28T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Swift for C++ Practitioners, Part 9: Extensible Literals"},{"property":"og:description","content":"Swift for C++ Practitioners, Part 9: Extensible Literals"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/douggregor.net/swift-for-cpp-practitioners-7.html"}]],"prev":"/programming/swift/articles/README.md","date":"2024-09-28T00:00:00.000Z","isOriginal":false},"git":{},"readingTime":{"minutes":11.65,"words":3496},"filePathRelative":"douggregor.net/swift-for-cpp-practitioners-9.md"}');export{A as comp,D as data};
