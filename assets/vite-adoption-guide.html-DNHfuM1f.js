import{_ as f}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as v,d as t,f as i,b as r,a as l,t as b,n as u,g as c,w as o,e as n,r as d,o as w}from"./app-BVguHYKu.js";const y="/bookshelf/assets/image/blog.logrocket.com/vite-adoption-guide/banner.png",k="/bookshelf/assets/image/blog.logrocket.com/vite-adoption-guide/Non-optimized-import-with-two-async-chunks-one-common-chunk-e1701204460643.png",V={},x={id:"frontmatter-title-관련",tabindex:"-1"},S={class:"header-anchor",href:"#frontmatter-title-관련"},T={class:"table-of-contents"},A={class:"hint-container info"},C={class:"hint-container info"},z={class:"hint-container info"},R={class:"hint-container info"},j={class:"hint-container info"},D={class:"hint-container info"},O={class:"hint-container info"};function I(h,e){const p=d("VPCard"),a=d("router-link"),m=d("SiteInfo"),s=d("RouteLink"),g=d("VPIcon");return w(),v("div",null,[t("h1",x,[t("a",S,[t("span",null,b(h.$frontmatter.title)+" 관련",1)])]),i(p,u(c({title:"Node.js > Article(s)",desc:"Article(s)",link:"/programming/js-node/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",T,[t("ul",null,[t("li",null,[i(a,{to:"#why-build-tools-matter"},{default:o(()=>e[0]||(e[0]=[n("Why build tools matter")])),_:1,__:[0]})]),t("li",null,[i(a,{to:"#what-is-vite"},{default:o(()=>e[1]||(e[1]=[n("What is Vite?")])),_:1,__:[1]})]),t("li",null,[i(a,{to:"#how-vite-works"},{default:o(()=>e[2]||(e[2]=[n("How Vite works")])),_:1,__:[2]})]),t("li",null,[i(a,{to:"#why-use-vite"},{default:o(()=>e[3]||(e[3]=[n("Why use Vite")])),_:1,__:[3]}),t("ul",null,[t("li",null,[i(a,{to:"#ease-of-use"},{default:o(()=>e[4]||(e[4]=[n("Ease of use")])),_:1,__:[4]})]),t("li",null,[i(a,{to:"#build-optimization-with-async-chunk-loading"},{default:o(()=>e[5]||(e[5]=[n("Build optimization with async chunk loading")])),_:1,__:[5]})]),t("li",null,[i(a,{to:"#build-optimization-with-css-code-splitting"},{default:o(()=>e[6]||(e[6]=[n("Build optimization with CSS code splitting")])),_:1,__:[6]})]),t("li",null,[i(a,{to:"#typescript-support"},{default:o(()=>e[7]||(e[7]=[n("TypeScript support")])),_:1,__:[7]})])])]),t("li",null,[i(a,{to:"#pros-and-cons-of-vite"},{default:o(()=>e[8]||(e[8]=[n("Pros and cons of Vite")])),_:1,__:[8]})]),t("li",null,[i(a,{to:"#key-vite-features-to-know"},{default:o(()=>e[9]||(e[9]=[n("Key Vite features to know")])),_:1,__:[9]}),t("ul",null,[t("li",null,[i(a,{to:"#hot-module-replacement"},{default:o(()=>e[10]||(e[10]=[n("Hot module replacement")])),_:1,__:[10]})]),t("li",null,[i(a,{to:"#build-setup-and-customization"},{default:o(()=>e[11]||(e[11]=[n("Build setup and customization")])),_:1,__:[11]})]),t("li",null,[i(a,{to:"#additional-vite-features"},{default:o(()=>e[12]||(e[12]=[n("Additional Vite features")])),_:1,__:[12]})])])]),t("li",null,[i(a,{to:"#use-cases-for-vite"},{default:o(()=>e[13]||(e[13]=[n("Use cases for Vite")])),_:1,__:[13]}),t("ul",null,[t("li",null,[i(a,{to:"#admin-panels-and-dashboards"},{default:o(()=>e[14]||(e[14]=[n("Admin panels and dashboards")])),_:1,__:[14]})]),t("li",null,[i(a,{to:"#blogs-and-content-websites"},{default:o(()=>e[15]||(e[15]=[n("Blogs and content websites")])),_:1,__:[15]})]),t("li",null,[i(a,{to:"#full-stack-and-decentralized-applications"},{default:o(()=>e[16]||(e[16]=[n("Full-stack and decentralized applications")])),_:1,__:[16]})]),t("li",null,[i(a,{to:"#rapid-prototyping"},{default:o(()=>e[17]||(e[17]=[n("Rapid prototyping")])),_:1,__:[17]})]),t("li",null,[i(a,{to:"#testing"},{default:o(()=>e[18]||(e[18]=[n("Testing")])),_:1,__:[18]})])])]),t("li",null,[i(a,{to:"#vite-vs-the-competition"},{default:o(()=>e[19]||(e[19]=[n("Vite vs. the competition")])),_:1,__:[19]}),t("ul",null,[t("li",null,[i(a,{to:"#features"},{default:o(()=>e[20]||(e[20]=[n("Features")])),_:1,__:[20]})]),t("li",null,[i(a,{to:"#performance"},{default:o(()=>e[21]||(e[21]=[n("Performance")])),_:1,__:[21]})]),t("li",null,[i(a,{to:"#community"},{default:o(()=>e[22]||(e[22]=[n("Community")])),_:1,__:[22]})]),t("li",null,[i(a,{to:"#documentation-and-other-resources"},{default:o(()=>e[23]||(e[23]=[n("Documentation and other resources")])),_:1,__:[23]})]),t("li",null,[i(a,{to:"#comparison-table-vite-vs-snowpack-vs-webpack"},{default:o(()=>e[24]||(e[24]=[n("Comparison table: Vite vs. Snowpack vs. webpack")])),_:1,__:[24]})]),t("li",null,[i(a,{to:"#create-vite-vs-create-react-app"},{default:o(()=>e[25]||(e[25]=[n("create-vite vs. Create React App")])),_:1,__:[25]})])])]),t("li",null,[i(a,{to:"#wrapping-up"},{default:o(()=>e[26]||(e[26]=[n("Wrapping up")])),_:1,__:[26]})])])]),e[61]||(e[61]=t("hr",null,null,-1)),i(m,{name:"Vite adoption guide: Overview, examples, and alternatives",desc:"Vite is a versatile, fast, lightweight build tool with an exceptional DX. Let's explore when and why you should adopt Vite in your projects.",url:"https://blog.logrocket.com/vite-adoption-guide",logo:"/assets/image/blog.logrocket.com/favicon.png",preview:"/assets/image/blog.logrocket.com/vite-adoption-guide/banner.png"}),e[62]||(e[62]=r('<p>The advent of build tools made many new innovations in frontend development possible. While tools such as webpack were at the forefront of this innovation, as time went by, they became slow and bloated. This made new build tools necessary — tools like Vite that were designed to be fast and lightweight.</p><figure><img src="'+y+'" alt="Vite Adoption Guide Overview Examples And Alternatives" tabindex="0" loading="lazy"><figcaption>Vite Adoption Guide Overview Examples And Alternatives</figcaption></figure><p>In this guide, I will provide an overview of Vite, explain why you should use it, discuss what makes it better than its competition, explore its use cases, and more.</p><hr><hr><h2 id="why-build-tools-matter" tabindex="-1"><a class="header-anchor" href="#why-build-tools-matter"><span>Why build tools matter</span></a></h2><p>Build tools enable us to create complex user interfaces with multiple components, which were previously difficult or impossible to create with traditional HTML, CSS, and JavaScript. They also make it possible to minify and compress code, which improves the performance of web pages.</p><p>Additionally, build tools allow us to automate tasks such as code compilation and asset generation, which saves time and effort in the development process. Generally speaking, they make it possible for developers to create complex web applications with ease.</p><p>However, older build tools like webpack and Parcel were designed to work with large, complex applications. For smaller apps, they were overkill. While these older tools are still widely used, newer build tools like Vite and Snowpack have become the standard for building web apps.</p><hr><hr><h2 id="what-is-vite" tabindex="-1"><a class="header-anchor" href="#what-is-vite"><span>What is Vite?</span></a></h2><p>Vite is a build tool and development server created by Evan You, the creator of Vue.js. Evan’s initial goal was to simplify and speed up the development and build processes for Vue applications.</p><p>Unexpectedly, Vite’s adoption surged, starting a new wave of innovation within the web framework ecosystem. Frameworks such as Nuxt 3, SvelteKit, Astro, Refine, Hydrogen, and SolidStart now use Vite by default. The React team also recently dropped its support for Create React App and recommends Vite’s <code>create-vite</code> template instead.</p><p>Vite’s evolution continued with v2.0, which introduced significant changes such as a redesigned architecture and optimized performance and efficiency. This version also featured a new plugin system that enhances customization and extensibility in the development process, plus first-class support for CSS.</p><p>While Vite 2.0 introduced significant changes, the development team has continually improved on existing features while introducing new ones with every subsequent release.</p><p>The latest Vite 5.0 iteration leverages the updated Rollup module bundler and introduces a cutting-edge feature, <code>server.warmup</code>. This feature allows us to specify a list of modules that should be pre-transformed as soon as the server starts, thus improving startup time.</p>',17)),t("div",A,[e[29]||(e[29]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/whats-new-in-vite-2-0.html"},{default:o(()=>e[27]||(e[27]=[t("strong",null,"What’s new in Vite 2.0",-1)])),_:1,__:[27]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/getting-started-with-vite.html"},{default:o(()=>e[28]||(e[28]=[t("strong",null,"Getting started with Vite",-1)])),_:1,__:[28]})])]),l(" TODO: VPCard로 대체 ")]),e[63]||(e[63]=r('<hr><hr><h2 id="how-vite-works" tabindex="-1"><a class="header-anchor" href="#how-vite-works"><span>How Vite works</span></a></h2><p>Vite was created to improve DX by harnessing the capabilities of modern web technologies — such as native ES modules and esbuild — to speed up large-scale and modern web projects. This approach addresses issues with bundling and extended waiting times when initializing development servers.</p><p>Before ES modules, developers wrote code in formats such as CommonJS and AMD, relying on complex tools like webpack and Parcel to bundle this code. This involves concatenating multiple source modules and other assets into a single JavaScript bundle that can run in the browser using a dependency graph.</p><p>Unfortunately, as the application adds more code and dependencies, the bundling process becomes increasingly slow. This makes initializing development servers unbearably slow and even affects the feedback loop for hot module replacement (HMR) when changes are made in the application.</p><p>Vite mitigates this problem using ES modules and browser APIs, allowing developers to import and export modules directly without a complex bundling process. You can work with individual modules as separate files and leave the browser to handle how each module communicates, making the development process faster and more intuitive.</p><p>To improve the development server initialization time, Vite employs a unique technique that carefully segregates modules into two distinct groups:</p><ul><li><strong>Dependencies</strong>: Any JavaScript code that isn’t frequently updated during development. Dependencies can be very large and are often shipped in CommonJS and UMD formats, which makes them expensive to process. Vite converts them to ES modules and bundles them using esbuild, a JavaScript bundler written in Go. This makes Vite between 10 to 100 times faster than JavaScript-based bundlers</li><li><strong>Source code</strong>: The code that makes up your application and is often subject to change. This includes code written in JSX or CSS, as well as code written for Vue or Svelte components. Not all source code needs to be used at the same time, as some of it is split up based on routes. Vite only needs to parse the code and serve it on demand. Since the code is served over native ESM, the browser will handle bundling, so Vite doesn’t need to worry about it</li></ul><p>Vite’s exceptionally fast development server is particularly well-suited for JavaScript-native application frameworks like Electron, which is known for its sluggish development server.</p>',10)),t("div",C,[e[33]||(e[33]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/getting-started-with-nestjs-vite-esbuild.html"},{default:o(()=>e[30]||(e[30]=[t("strong",null,"Getting started with NestJS, Vite, and esbuild",-1)])),_:1,__:[30]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/setting-up-dev-environment-react-vite-tailwind.html"},{default:o(()=>e[31]||(e[31]=[t("strong",null,"Setting up a dev environment with React, Vite, and Tailwind",-1)])),_:1,__:[31]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/build-electron-app-electron-vite.html"},{default:o(()=>e[32]||(e[32]=[t("strong",null,"Build an Electron app with electron-vite",-1)])),_:1,__:[32]})])]),l(" TODO: VPCard로 대체 ")]),e[64]||(e[64]=t("hr",null,null,-1)),e[65]||(e[65]=t("h2",{id:"why-use-vite",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#why-use-vite"},[t("span",null,"Why use Vite")])],-1)),e[66]||(e[66]=t("p",null,"Vite’s blazing-fast development server, build customization, and other features make it a compelling choice for many developers. We’ll discuss its key features in detail shortly, but first, let’s review why I believe Vite is the future of frontend development and why you should use it.",-1)),e[67]||(e[67]=t("h3",{id:"ease-of-use",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#ease-of-use"},[t("span",null,"Ease of use")])],-1)),e[68]||(e[68]=t("p",null,"The frontend DX basically revolves around the speed at which a developer can set up a dev environment and implement real-time changes. Even with project starters meant for quick setup, developers often spend a significant amount of time configuring essential development tools.",-1)),e[69]||(e[69]=t("p",null,"Vite checks all the boxes when it comes to this. It not only comes with pre-configured build settings out of the box but also offers a minimal-configuration setup and an extensive plugin system that encompasses all the necessary components for a development environment.",-1)),e[70]||(e[70]=t("p",null,"All of this, along with support for TypeScript, JSX, and CSS, makes it straightforward and efficient to initiate a web application development environment.",-1)),t("div",z,[e[35]||(e[35]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/configure-worker-plugins-vite-2.html"},{default:o(()=>e[34]||(e[34]=[t("strong",null,"How to configure worker plugins in Vite 2.8",-1)])),_:1,__:[34]})])]),l(" TODO: VPCard로 대체 ")]),e[71]||(e[71]=r('<h3 id="build-optimization-with-async-chunk-loading" tabindex="-1"><a class="header-anchor" href="#build-optimization-with-async-chunk-loading"><span>Build optimization with async chunk loading</span></a></h3><p>Providing support for a feature is important, but it’s not always enough. Accounting for edge cases is a whole other issue — but it’s one that Vite handles very well.</p><p>We discussed how shipping unbundled ESM isn’t efficient because of the additional network round trips caused by nested imports. Rollup and other build tools encounter similar issues when code-splitting with dynamic imports.</p><p>Rollup typically encounters this issue because it often produces a common chunk, or code that is shared between two or more chunks. When combined with a dynamic import, this can cause performance dips.</p><p>To provide a clearer picture, the Vite docs show the following visual representation of a common non-optimized scenario:</p><figure><img src="'+k+`" alt="Visualization Of A Non Optimized Import That Includes Two Async Chunks And One Common Chunk, Requiring Both Dynamic And Direct Imports, To Show How Common Chunks Combined With Dynamic Imports Can Cause Performance Dips" tabindex="0" loading="lazy"><figcaption>Visualization Of A Non Optimized Import That Includes Two Async Chunks And One Common Chunk, Requiring Both Dynamic And Direct Imports, To Show How Common Chunks Combined With Dynamic Imports Can Cause Performance Dips</figcaption></figure><p>As shown in the image, when <strong>async chunk A</strong> is imported, the browser will have to request and parse this chunk before it can figure out if it also needs to request and parse <strong>common chunk C</strong> or not. This will result in an extra network round-trip:</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">Entry ---&gt; A ---&gt; C</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,8)),l(" TODO: mermaid로 작성 "),e[72]||(e[72]=r(`<p>Vite automatically rewrites every code-split dynamic import call with a preload step, which ensures that when <strong>async chunk A</strong> is requested, <strong>common chunk C</strong> is fetched in parallel:</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">Entry ---&gt; (A + C)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,2)),l(" TODO: mermaid로 작성 "),e[73]||(e[73]=r('<p>As you may have already surmised, there is an additional edge case to consider here. In a non-optimized scenario, where the import depth is greater than what is shown in the example, there will be even more round trips. So, how does Vite deal with this?</p><p>It does so by precisely tracing every direct import and fetching them in parallel, thus eliminating further network round trips regardless of import depth.</p><p>This is a common issue in other build tools with similar features, but Vite automatically handles it for you without you having to worry about it.</p><h3 id="build-optimization-with-css-code-splitting" tabindex="-1"><a class="header-anchor" href="#build-optimization-with-css-code-splitting"><span>Build optimization with CSS code splitting</span></a></h3><p>As Vite loads async chunks, it automatically extracts the CSS used by modules in each chunk into separate files. These files are then loaded using the <code>&lt;link&gt;</code> tag back to the associated chunk when it is loaded.</p><p>We’ll discuss this feature in more detail later, but essentially, this ensures that the CSS is only loaded when it is needed, which can improve performance. Additionally, Vite makes sure that each chunk’s CSS is loaded before it’s evaluated, thus preventing the dreaded flash of unstyled content (FOUC).</p><p>CSS code splitting is enabled by default. With this feature enabled, you don’t have to worry about unused CSS clogging up your application’s rendering pipeline in production.</p><p>Should you need to disable CSS code splitting, Vite provides the flexibility to do so by configuring the <code>build.cssCodeSplit</code> option in your <code>vite.config.js</code> file and setting it to <code>false</code>. In this case, Vite will extract all the CSS in your project into a single file.</p><h3 id="typescript-support" tabindex="-1"><a class="header-anchor" href="#typescript-support"><span>TypeScript support</span></a></h3><p>Vite’s out-of-the-box support for TypeScript is what I would consider the pièce de résistance of why many developers have migrated to Vite. Given the hassle of setting up TypeScript in a project, a tool that imports and transpiles <code>.ts</code> files out of the box would be very appealing to most developers.</p><p>But Vite doesn’t stop there. It transpiles TypeScript into JavaScript using esbuild, which means that transpilation is 20 to 30 times faster compared to the vanilla TypeScript compiler. As a result, you can expect HMR updates to reflect in the browser in under 50ms. Yes, it is that fast.</p><hr><h2 id="pros-and-cons-of-vite" tabindex="-1"><a class="header-anchor" href="#pros-and-cons-of-vite"><span>Pros and cons of Vite</span></a></h2><p>Now that you know why I think you should use Vite, let’s discuss some of its drawbacks. To help you make an informed decision, I’ve listed below the pros and cons of Vite based on different aspects of web development:</p><table><thead><tr><th style="text-align:right;"></th><th>Pros</th><th>Cons</th></tr></thead><tbody><tr><td style="text-align:right;"><strong>Dev workflow</strong></td><td>Vite excels in providing a streamlined development workflow. Its instant server and fast HMR make development a pleasant experience, reducing the need for time-consuming rebuilds</td><td>Some developers might find Vite different from traditional bundlers, requiring an adjustment in their workflow</td></tr><tr><td style="text-align:right;"><strong>Performance/speed</strong></td><td>Vite is renowned for its exceptional performance. It leverages ES modules and efficient bundling techniques, resulting in rapid build times and a responsive development server</td><td>In huge projects, Vite’s performance benefits might not be as pronounced due to the inherent complexities of such projects</td></tr><tr><td style="text-align:right;"><strong>Ease of use</strong> / DX / productivity</td><td>Vite is designed with DX in mind. Its simple configuration, quick setup, and immediate feedback loop enhance productivity</td><td>Developers transitioning from traditional bundlers might need some time to adapt to Vite’s unique approach</td></tr><tr><td style="text-align:right;"><strong>Optimized code size</strong></td><td>Vite supports tree shaking and code splitting, resulting in smaller and more optimized code bundles for production</td><td>Achieving optimal code size may require some configuration and fine-tuning</td></tr><tr><td style="text-align:right;"><strong>Community &amp; ecosystem</strong></td><td>Vite has a growing community and a rapidly expanding ecosystem. It’s supported by the Vue team and has gained adoption in the broader JavaScript community</td><td>While Vite is gaining momentum, it might not have as extensive an ecosystem as more established tools like webpack</td></tr><tr><td style="text-align:right;"><strong>Learning curve</strong></td><td>Vite’s simplicity and intuitive setup make it relatively easy to learn, especially for developers with prior experience in web development</td><td>Developers entirely new to modern JavaScript tooling may still face a learning curve, but it’s less steep compared to some other tools</td></tr><tr><td style="text-align:right;"><strong>Documentation</strong></td><td>Vite’s documentation is comprehensive and well-maintained, providing clear guidance on how to use the tool effectively</td><td>As with any evolving project, there may be occasional gaps or updates in the documentation that require attention</td></tr><tr><td style="text-align:right;"><strong>Integrations</strong></td><td>Vite easily integrates with various front-end frameworks, libraries, and tools. It supports popular JavaScript frameworks like React, Vue, and Svelte, allowing you to seamlessly incorporate Vite into your existing project stacks</td><td>The level of integration with some less common or specialized tools might vary, requiring additional configuration</td></tr></tbody></table><p>As you can see, while Vite does have certain limitations, it’s a great tool with many benefits and features that can improve DX as well as application performance. Knowing its limitations and how they might affect your specific use case will help you work around them strategically and use Vite effectively.</p><hr><h2 id="key-vite-features-to-know" tabindex="-1"><a class="header-anchor" href="#key-vite-features-to-know"><span>Key Vite features to know</span></a></h2><p>We’ve discussed a few of Vite’s standout features in previous sections. Now, let’s dive into more of its key features in greater detail.</p><h3 id="hot-module-replacement" tabindex="-1"><a class="header-anchor" href="#hot-module-replacement"><span>Hot module replacement</span></a></h3><p>Vite and traditional bundle-based tools share one common feature: hot module replacement.</p><p>HMR is a dynamic process that allows a module to seamlessly replace itself without affecting the rest of the page, like updating a single piece of a jigsaw puzzle without having to redo the entire puzzle. This prevents the bundler from having to rebuild the entire application whenever something changes, which is a laborious task.</p><p>While HMR is a cutting-edge technique that greatly speeds up development by retaining an application’s state — which is lost during a full reload — the problem of progressive performance deterioration persists in most bundlers.</p><p>Vite solves this problem by performing HMR over native ES modules and letting the browser do most of the work. This means that Vite only has to invalidate the chain between the edited module and its closest HMR boundary.</p><p>In simpler terms, Vite marks the edited dependency modules as outdated and reloads them alone. This is faster and more efficient than reloading the whole page or all the modules, making it consistently fast regardless of the application’s size.</p><h3 id="build-setup-and-customization" tabindex="-1"><a class="header-anchor" href="#build-setup-and-customization"><span>Build setup and customization</span></a></h3><p>Vite uses Rollup to bundle your code for production. You may be wondering why it doesn’t use esbuild or ship directly to production since the browser supports ES modules natively. Comparing the pros and cons of Rollup and esbuild reveals the rationale behind the Vite team’s decision to use Rollup.</p><p>Firstly, esbuild is fairly new and doesn’t offer the same performance and flexibility tradeoffs as Rollup. The Vite team also believes that Vite would not be as popular without its adoption of Rollup’s plugin system.</p><p>Furthermore, shipping unbundled ESM in production is not efficient, as the additional network round trips caused by nested imports can quickly become an issue. You also lose out on features like tree shaking, chunk splitting, and lazy loading, which Vite uses to optimize loading performance in production.</p><p>Basically, Rollup has it all. Although it’s primarily known as the bundler tool that creates small and efficient bundles of code to improve performance, it is much more than that. Vite’s build customization options provide a testament to how powerful Rollup is:</p>',30)),t("ul",null,[e[42]||(e[42]=t("li",null,[t("strong",null,"Chunking strategy"),n(": Allows you to control how Vite splits your code into chunks. You can choose to have Vite split your code into chunks based on file path, function, or component")],-1)),t("li",null,[e[36]||(e[36]=t("strong",null,"Rebuilding on file change",-1)),e[37]||(e[37]=n(": Enables the Rollup watcher with the ")),e[38]||(e[38]=t("code",null,"vite build --watch command",-1)),e[39]||(e[39]=n(", allowing you to have Vite rebuild your code whenever the ")),i(g,{icon:"fa-brands fa-js"}),e[40]||(e[40]=t("code",null,"vite.config.js",-1)),e[41]||(e[41]=n(" file changes, or when any code to be bundled changes. This can be useful for development, as it ensures that your code is always up-to-date"))]),e[43]||(e[43]=t("li",null,[t("strong",null,"Library mode"),n(": Allows you to use Vite as a library in another project. This can be useful if you want to use Vite’s features in a project that is not using Vite as its main build tool")],-1))]),e[74]||(e[74]=r(`<p>In addition to these customizations, you can also customize Vite’s other settings, such as its port, watch options, and polyfills.</p><p>These strategies are reserved for advanced build configurations. However, Vite ships with a build setup that incorporates the necessary performance optimizations for simple applications. This build setup is run using the <code>build</code> command, like so:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">vite build</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="additional-vite-features" tabindex="-1"><a class="header-anchor" href="#additional-vite-features"><span>Additional Vite features</span></a></h3><p>Vite features aren’t limited to what’s highlighted above. It also offers several other key features, including:</p><ul><li><strong>Lazy loading</strong>: Vite supports lazy loading modules, so you can choose to load certain components or parts of your application only when they are needed. This can improve the initial load time of your application and enhance overall performance</li><li><strong>Tree shaking</strong>: This technique eliminates unused code from your project during the build process. Vite is proficient at tree shaking, helping reduce the size of your application bundle, which is crucial for optimizing performance and load times</li><li><strong>Code splitting</strong>: Breaking your application code into smaller chunks enables you to load these chunks on demand. Vite supports automatic code splitting, allowing you to improve the loading performance of your application by only loading the code required for a specific page or feature</li><li><strong>Debugging capabilities</strong>: Vite provides efficient debugging capabilities, including source maps and error handling, making it easier to identify and fix issues during development. This contributes to a smoother development process</li></ul><p>Lastly, since Vite is platform-agnostic, you can use it to develop web applications for various platforms, including traditional web browsers, Electron applications, and more. It’s a versatile tool that can adapt to different use cases and project requirements.</p><hr><h2 id="use-cases-for-vite" tabindex="-1"><a class="header-anchor" href="#use-cases-for-vite"><span>Use cases for Vite</span></a></h2><p>Vite is highly versatile and can be used for a wide range of business use cases, from simple statically generated pages to complex single-page and full-stack applications. Let’s explore some of the most common use cases for Vite, along with reasons why it is a good choice for each.</p><h3 id="admin-panels-and-dashboards" tabindex="-1"><a class="header-anchor" href="#admin-panels-and-dashboards"><span>Admin panels and dashboards</span></a></h3><p>Admin panels and dashboards are examples of enterprise and B2B applications that tend to be data-intensive. These apps require proper optimization for their frontend workflows. Vite is the perfect web development tool for these kinds of applications.</p><p>For one, Vite’s hot reloading mechanism allows changes to code to be reflected in the browser almost immediately. This can save a lot of time when developing and debugging applications. Vite also supports code splitting, which can help improve the performance of these applications.</p><h3 id="blogs-and-content-websites" tabindex="-1"><a class="header-anchor" href="#blogs-and-content-websites"><span>Blogs and content websites</span></a></h3><p>For content-driven websites like blogs, where page load speed is crucial for retaining readers, Vite’s rapid development server and efficient bundling can significantly improve UX. Faster load times mean readers can access articles more quickly and enjoy a smoother browsing experience.</p><p>Another use case for Vite is for building beautiful documentation sites using Vitepress, a static site generator built on Vite and Vue that uses Markdown and Vue components. Vitepress’s static site generation and efficient bundling can significantly improve UX as well.</p>`,16)),t("div",R,[e[46]||(e[46]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/build-blog-astro-vite-mdx.html"},{default:o(()=>e[44]||(e[44]=[t("strong",null,"Build a blog with Astro, Vite, and MDX",-1)])),_:1,__:[44]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/build-blog-vitepress-vue-js.html"},{default:o(()=>e[45]||(e[45]=[t("strong",null,"Build a blog with Vitepress and Vue.js",-1)])),_:1,__:[45]})])]),l(" TODO: VPCard로 대체 ")]),e[75]||(e[75]=t("h3",{id:"full-stack-and-decentralized-applications",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#full-stack-and-decentralized-applications"},[t("span",null,"Full-stack and decentralized applications")])],-1)),e[76]||(e[76]=t("p",null,"Full-stack and decentralized applications are complex applications that require seamless integration between the frontend and backend. Vite’s flexibility and support for various front-end frameworks make it a solid choice for developing these types of applications.",-1)),t("p",null,[e[48]||(e[48]=n("Vite can easily integrate with backend technologies, contributing to the overall efficiency of the application. For an in-depth example, check out our ")),i(s,{to:"/blog.logrocket.com/full-stack-dapp-tutorial-vite-react-tailwind-css-solidity.html"},{default:o(()=>e[47]||(e[47]=[t("strong",null,"Full-stack DApp tutorial with Vite + React, Tailwind CSS, and Solidity",-1)])),_:1,__:[47]}),e[49]||(e[49]=n("."))]),e[77]||(e[77]=t("h3",{id:"rapid-prototyping",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#rapid-prototyping"},[t("span",null,"Rapid prototyping")])],-1)),e[78]||(e[78]=t("p",null,"Vite’s fast development server and HMR make it perfect for quickly prototyping ideas and building minimum viable products. It allows developers to iterate rapidly, reducing time to market.",-1)),e[79]||(e[79]=t("h3",{id:"testing",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#testing"},[t("span",null,"Testing")])],-1)),e[80]||(e[80]=t("p",null,"Vite is not a testing framework in itself, but it does incorporate a testing framework called Vitest.",-1)),e[81]||(e[81]=t("p",null,"Vitest uses Vite under the hood, which means that it inherits essential Vite features without any compatibility issues, including rapid feedback, minimal and sensible configuration, and optional chaining and nullish coalescing. This makes Vitest a powerful tool for ensuring code quality and developing test suites.",-1)),t("div",j,[e[54]||(e[54]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/testing-svelte-app-vitest.html"},{default:o(()=>e[50]||(e[50]=[t("strong",null,"Testing a Svelte app with Vitest",-1)])),_:1,__:[50]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/guide-vitest-automated-testing-vue-components.html"},{default:o(()=>e[51]||(e[51]=[t("strong",null,"A guide to Vitest automated testing with Vue components",-1)])),_:1,__:[51]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/visual-debugging-vitest-preview.html"},{default:o(()=>e[52]||(e[52]=[t("strong",null,"A guide to visual debugging with Vitest Preview",-1)])),_:1,__:[52]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/testing-vite-minimal-config-using-vitest.html"},{default:o(()=>e[53]||(e[53]=[t("strong",null,"Testing Vite with minimal config using Vitest",-1)])),_:1,__:[53]})])]),l(" TODO: VPCard로 대체 ")]),e[82]||(e[82]=r('<hr><h2 id="vite-vs-the-competition" tabindex="-1"><a class="header-anchor" href="#vite-vs-the-competition"><span>Vite vs. the competition</span></a></h2><p>Vite is often compared to Create React App — so much so that the first few results you’ll get when looking up “Vite” on a search engine are likely to feature comparisons of both tools. However, this comparison is a misunderstanding, as Vite’s true counterpart is not Create React App.</p><p>Vite is a build tool, while Create React App specializes in generating preconfigured React templates. Vite does offer a CLI tool, create-vite, that lets you bootstrap templates for popular frontend frameworks and libraries.</p><p>A better comparison point for Vite would be tools like webpack and Snowpack, as they all function as build tools with similar purposes. Let’s delve into a comprehensive comparison of Vite, Snowpack, and webpack, considering their features, performance, community, and documentation.</p><h3 id="features" tabindex="-1"><a class="header-anchor" href="#features"><span>Features</span></a></h3><p>Vite and Snowpack are quite similar, as they both leverage ES modules to speed up development and build times. They’re also both relatively simple to use, making them a good choice for beginners.</p><p>However, Vite has a few advantages over Snowpack. First, Vite is more versatile and supports a wider range of frontend frameworks, including Nuxt, React, Preact, and Svelte. Next, Vite has a plugin system that allows you to extend its functionality. Finally, Vite supports TypeScript out of the box.</p><p>On the other hand, webpack is a more powerful build tool than either Vite or Snowpack. It offers more customization options and can handle more complex projects. However, it is also more difficult to learn and lacks the flexibility and speed provided by Vite and Snowpack.</p><h3 id="performance" tabindex="-1"><a class="header-anchor" href="#performance"><span>Performance</span></a></h3><p>In terms of performance, Vite and Snowpack are standout choices for fast development.</p><p>Vite, using ES modules and esbuild, offers blazingly quick hot module replacement (HMR) and rapid initial builds. It’s ideal for projects demanding instant feedback. Snowpack also focuses on speed with ES modules, catering to smaller to mid-sized projects that require swift iteration.</p><p>On the other hand, webpack’s performance varies based on configuration complexity. While it can be optimized, it typically falls short of the rapid speeds provided by Vite and Snowpack. However, webpack excels at handling diverse and complex project requirements, making it suitable for large-scale applications.</p><h3 id="community" tabindex="-1"><a class="header-anchor" href="#community"><span>Community</span></a></h3><p>Vite is a relatively new tool, and its community is not as established as, for example, webpack. However, its community is steadily growing, particularly within the Vue ecosystem. This growth is driven by active development and contributions.</p><p>Snowpack is also experiencing increased popularity, especially among developers seeking fast build times. However, it is no longer being maintained, and even its team recommends Vite as an alternative. Nonetheless, there are still a handful of developers who use Snowpack.</p><p>Meanwhile, webpack boasts a vast and seasoned community thanks to its widespread adoption and industry use. It offers extensive resources and a multitude of third-party plugins.</p><h3 id="documentation-and-other-resources" tabindex="-1"><a class="header-anchor" href="#documentation-and-other-resources"><span>Documentation and other resources</span></a></h3><p>Vite offers comprehensive documentation that makes it easy for developers to get started. Its docs are well-organized and easy to follow, covering everything from basic usage to advanced topics. Vite also provides a range of tutorials and guides that can help users learn how to use the framework effectively.</p><p>Snowpack provides clear and concise documentation to help developers kickstart their projects. While not as extensive as webpack, Snowpack’s documentation equips users with the essential information needed to work efficiently.</p><p>Additionally, Snowpack’s active community contributes to the availability of resources and support. However, remember that the project is no longer actively maintained by its core team.</p><p>In comparison, webpack stands out with its extensive documentation and a wealth of third-party resources. The sheer number of tutorials and solutions available for webpack makes it a robust choice for developers seeking in-depth guidance and solutions for various scenarios.</p><h3 id="comparison-table-vite-vs-snowpack-vs-webpack" tabindex="-1"><a class="header-anchor" href="#comparison-table-vite-vs-snowpack-vs-webpack"><span>Comparison table: Vite vs. Snowpack vs. webpack</span></a></h3><p>The following comparison table summarizes the similarities and differences we’ve discussed for Vite, Snowpack, and webpack:</p><table><thead><tr><th style="text-align:right;"></th><th>Vite</th><th>Snowpack</th><th>webpack</th></tr></thead><tbody><tr><td style="text-align:right;"><strong>Features</strong></td><td>ES modules, HMR, out-of-the-box TypeScript support</td><td>ES modules</td><td>HMR and extended TypeScript and other feature integration through plugins</td></tr><tr><td style="text-align:right;"><strong>Framework support</strong></td><td>Framework-agnostic</td><td>Focus on React, Vue and Svelte</td><td>Framework-agnostic</td></tr><tr><td style="text-align:right;"><strong>Extensibility and customizability</strong></td><td>Flexible; has a plugin system for extending functionality</td><td>Offers a plugin-based architecture</td><td>Robust plugin ecosystem</td></tr><tr><td style="text-align:right;"><strong>Learning curve</strong></td><td>Easy to learn</td><td>Easy to learn</td><td>More difficult to learn</td></tr><tr><td style="text-align:right;"><strong>Performance</strong></td><td>Extremely fast and performant</td><td>Fast development and build times</td><td>Slightly slower due to more extensive features</td></tr><tr><td style="text-align:right;"><strong>Community</strong></td><td>Relatively newer and smaller, but active and steadily growing</td><td>Has an active and supportive community, but is no longer maintained by its core team</td><td>Vast and well-established</td></tr><tr><td style="text-align:right;"><strong>Documentation</strong></td><td>Comprehensive, well-organized, and easy to follow</td><td>Clear and concise, but not extensive</td><td>Extensive, both in terms of official docs and third-party resources</td></tr><tr><td style="text-align:right;"><strong>Best for…</strong></td><td>Projects of any size that require instant feedback</td><td>Smaller to mid-sized projects</td><td>Diverse, complex, and large applications</td></tr></tbody></table>',25)),t("div",D,[e[56]||(e[56]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/vite-vs-snowpack-a-comparison-of-frontend-build-tools.html"},{default:o(()=>e[55]||(e[55]=[t("strong",null,"Vite vs. Snowpack: A comparison of frontend build tools",-1)])),_:1,__:[55]})])])]),e[83]||(e[83]=r('<h3 id="create-vite-vs-create-react-app" tabindex="-1"><a class="header-anchor" href="#create-vite-vs-create-react-app"><span><code>create-vite</code> vs. Create React App</span></a></h3><p><code>create-vite</code> and Create React App are tools for bootstrapping web development projects, but they cater to different ecosystems and have distinct characteristics. They do this by scaffolding code that includes the necessary libraries and frameworks for building a modern web application.</p><p>Using these tools can save developers a lot of time and effort, as they don’t have to start from scratch each time they create a new project. Here’s a quick overview of how they compare.</p><p><code>create-vite</code> is a versatile project generator tool designed for speed:</p><ul><li><strong>Framework-agnostic</strong>: A versatile choice for developing applications with Vue, React, Svelte, and more</li><li><strong>Performance-oriented</strong>: Vite, the build tool behind create-vite, is designed for speed, offering near-instantaneous development feedback and quicker builds</li><li><strong>ES module support</strong>: Leverages ES modules for faster loading and development, contributing to its performance advantage.</li><li><strong>Extensible</strong>: Allows developers to customize project configurations and add plugins as needed</li></ul><p>Create React App provides a solid foundation for building React applications complete with service workers, testing setup, and more:</p><ul><li><strong>React-focused:</strong> Tailored specifically for React projects; provides a solid foundation for building React apps complete with service workers, testing setup, and more</li><li><strong>Well-established tool</strong>: As a widely used tool within the React community, it offers stability and a wealth of resources</li><li><strong>Abstraction layer</strong>: Abstracting many configuration details makes it easier to dive into React development without getting bogged down in complex setups</li></ul><p>The choice between create-vite and Create React App depends on your project requirements and preferences. If you’re more focused on performance optimization and versatility, create-vite is probably the way to go. Meanwhile, Create React App offers a well-established, React-specific solution with an abstraction layer.</p>',8)),t("div",O,[e[60]||(e[60]=t("p",{class:"hint-container-title"},"Further reading",-1)),t("ul",null,[t("li",null,[i(s,{to:"/blog.logrocket.com/vite-3-vs-create-react-app-comparison-migration-guide.html"},{default:o(()=>e[57]||(e[57]=[t("strong",null,"Vite 3.0 vs. Create React App: Comparison and migration guide",-1)])),_:1,__:[57]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/build-pomodoro-timer-tauri-using-react-and-vite.html"},{default:o(()=>e[58]||(e[58]=[t("strong",null,"Building a pomodoro timer with Tauri using React and Vite",-1)])),_:1,__:[58]})]),t("li",null,[i(s,{to:"/blog.logrocket.com/build-react-typescript-app-vite.html"},{default:o(()=>e[59]||(e[59]=[t("strong",null,"How to build a React + TypeScript app with Vite",-1)])),_:1,__:[59]})])])]),e[84]||(e[84]=t("hr",null,null,-1)),e[85]||(e[85]=t("h2",{id:"wrapping-up",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#wrapping-up"},[t("span",null,"Wrapping up")])],-1)),e[86]||(e[86]=t("p",null,"At the end of the day, the choice of the right tool depends on its compatibility with the specific use case, regardless of its flaws. This is precisely why tools like webpack continue to have a significant presence in the development ecosystem, despite the existence of superior alternatives such as Vite.",-1)),e[87]||(e[87]=t("p",null,"Switching to new tools can be challenging, as there is no guarantee that they will be maintained in the long term. Snowpack is an example of a tool that was discontinued, although this was reportedly due to burnout rather than technical reasons.",-1)),e[88]||(e[88]=t("p",null,"Vite, on the other hand, has grown to a point where it is unlikely to be discontinued, as it has a large community of backers and maintainers who are constantly working on it.",-1)),e[89]||(e[89]=t("p",null,"Each tool has its unique strengths and weaknesses and is tailored to meet a wide range of project requirements, from the established reliability of webpack to the unrivaled performance of Vite. Ultimately, to decide which tool to use, make sure you thoroughly assess the specific needs and constraints of your project.",-1)),l(" TODO: add ARTICLE CARD "),i(p,u(c({title:"Vite adoption guide: Overview, examples, and alternatives",desc:"Vite is a versatile, fast, lightweight build tool with an exceptional DX. Let's explore when and why you should adopt Vite in your projects.",link:"https://chanhi2000.github.io/bookshelf/blog.logrocket.com/vite-adoption-guide.html",logo:"/assets/image/blog.logrocket.com/favicon.png",background:"rgba(112,76,182,0.2)"})),null,16)])}const F=f(V,[["render",I]]),H=JSON.parse('{"path":"/blog.logrocket.com/vite-adoption-guide.html","title":"Vite adoption guide: Overview, examples, and alternatives","lang":"en-US","frontmatter":{"lang":"en-US","title":"Vite adoption guide: Overview, examples, and alternatives","description":"Article(s) > Vite adoption guide: Overview, examples, and alternatives","icon":"fa-brands fa-node","category":["Node.js","Vite.js","Article(s)"],"tag":["blog","blog.logrocket.com","node","nodejs","node-js","vite","vitejs","vite-js"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vite adoption guide: Overview, examples, and alternatives\\",\\"image\\":[\\"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/vite-adoption-guide/banner.png\\",\\"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/vite-adoption-guide/Non-optimized-import-with-two-async-chunks-one-common-chunk-e1701204460643.png\\"],\\"datePublished\\":\\"2023-11-29T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"David Omotayo\\",\\"url\\":\\"https://blog.logrocket.com/author/davidomotayo/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/blog.logrocket.com/vite-adoption-guide.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Vite adoption guide: Overview, examples, and alternatives"}],["meta",{"property":"og:description","content":"Article(s) > Vite adoption guide: Overview, examples, and alternatives"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/vite-adoption-guide/banner.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/vite-adoption-guide/banner.png"}],["meta",{"name":"twitter:image:alt","content":"Vite adoption guide: Overview, examples, and alternatives"}],["meta",{"property":"article:author","content":"David Omotayo"}],["meta",{"property":"article:tag","content":"vite-js"}],["meta",{"property":"article:tag","content":"vitejs"}],["meta",{"property":"article:tag","content":"vite"}],["meta",{"property":"article:tag","content":"node-js"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:tag","content":"blog.logrocket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2023-11-29T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Vite adoption guide: Overview, examples, and alternatives"},{"property":"og:description","content":"Vite adoption guide: Overview, examples, and alternatives"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/blog.logrocket.com/vite-adoption-guide.html"}]],"prev":"/programming/js-node/articles/README.md","date":"2023-11-29T00:00:00.000Z","isOriginal":false,"author":[{"name":"David Omotayo","url":"https://blog.logrocket.com/author/davidomotayo/"}],"cover":"/assets/image/blog.logrocket.com/vite-adoption-guide/banner.png"},"git":{},"readingTime":{"minutes":16.66,"words":4999},"filePathRelative":"blog.logrocket.com/vite-adoption-guide.md","copyright":{"author":"David Omotayo"}}');export{F as comp,H as data};
