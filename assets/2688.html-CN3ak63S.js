import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as m,d as t,f as n,b as r,t as u,n as f,g as h,w as a,e as o,r as d,o as _}from"./app-BVguHYKu.js";const w={},y={id:"frontmatter-title-관련",tabindex:"-1"},b={class:"header-anchor",href:"#frontmatter-title-관련"},k={class:"table-of-contents"},z={href:"https://medium.com/@resul.dilek/react-the-virtual-dom-4a54b4c31973",target:"_blank",rel:"noopener noreferrer"},x={href:"https://react.dev/reference/react/Component",target:"_blank",rel:"noopener noreferrer"},R={href:"https://react.dev/learn/react-developer-tools",target:"_blank",rel:"noopener noreferrer"},S={href:"http://nextjs.org",target:"_blank",rel:"noopener noreferrer"};function M(l,e){const p=d("VPCard"),s=d("router-link"),g=d("SiteInfo"),i=d("VPIcon");return _(),m("div",null,[t("h1",y,[t("a",b,[t("span",null,u(l.$frontmatter.title)+" 관련",1)])]),n(p,f(h({title:"React.js > Article(s)",desc:"Article(s)",link:"/programming/js-react/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",k,[t("ul",null,[t("li",null,[n(s,{to:"#리액트의-기본-개념"},{default:a(()=>e[0]||(e[0]=[o("리액트의 기본 개념")])),_:1,__:[0]}),t("ul",null,[t("li",null,[n(s,{to:"#_1-컴포넌트-기반-아키텍처"},{default:a(()=>e[1]||(e[1]=[o("1) 컴포넌트 기반 아키텍처")])),_:1,__:[1]})]),t("li",null,[n(s,{to:"#_2-jsx-문법"},{default:a(()=>e[2]||(e[2]=[o("2) JSX 문법")])),_:1,__:[2]})]),t("li",null,[n(s,{to:"#_3-가상-dom-virtual-dom"},{default:a(()=>e[3]||(e[3]=[o("3) 가상 DOM(Virtual DOM)")])),_:1,__:[3]})]),t("li",null,[n(s,{to:"#_4-props와-state"},{default:a(()=>e[4]||(e[4]=[o("4) Props와 State")])),_:1,__:[4]})])])]),t("li",null,[n(s,{to:"#리액트-훅-react-hooks-의-활용"},{default:a(()=>e[5]||(e[5]=[o("리액트 훅(React Hooks)의 활용")])),_:1,__:[5]}),t("ul",null,[t("li",null,[n(s,{to:"#_1-리액트-훅이란"},{default:a(()=>e[6]||(e[6]=[o("1) 리액트 훅이란?")])),_:1,__:[6]})]),t("li",null,[n(s,{to:"#_2-리액트-훅-사용-예시"},{default:a(()=>e[7]||(e[7]=[o("2) 리액트 훅 사용 예시")])),_:1,__:[7]})]),t("li",null,[n(s,{to:"#_3-커스텀-훅-만들기"},{default:a(()=>e[8]||(e[8]=[o("3) 커스텀 훅 만들기")])),_:1,__:[8]})]),t("li",null,[n(s,{to:"#_4-훅-사용-시-주의-사항"},{default:a(()=>e[9]||(e[9]=[o("4) 훅 사용 시 주의 사항")])),_:1,__:[9]})])])]),t("li",null,[n(s,{to:"#리액트-컴포넌트-종류와-데이터-전달-방법"},{default:a(()=>e[10]||(e[10]=[o("리액트 컴포넌트 종류와 데이터 전달 방법")])),_:1,__:[10]}),t("ul",null,[t("li",null,[n(s,{to:"#_1-클래스형-컴포넌트-vs-함수형-컴포넌트"},{default:a(()=>e[11]||(e[11]=[o("1) 클래스형 컴포넌트 vs 함수형 컴포넌트")])),_:1,__:[11]})]),t("li",null,[n(s,{to:"#_2-컴포넌트-간-데이터-전달-방법"},{default:a(()=>e[12]||(e[12]=[o("2) 컴포넌트 간 데이터 전달 방법")])),_:1,__:[12]})])])]),t("li",null,[n(s,{to:"#리액트-개발자-도구와-프레임워크"},{default:a(()=>e[13]||(e[13]=[o("리액트 개발자 도구와 프레임워크")])),_:1,__:[13]}),t("ul",null,[t("li",null,[n(s,{to:"#_1-리액트-개발자-도구"},{default:a(()=>e[14]||(e[14]=[o("1) 리액트 개발자 도구")])),_:1,__:[14]})]),t("li",null,[n(s,{to:"#_2-리액트-프레임워크"},{default:a(()=>e[15]||(e[15]=[o("2) 리액트 프레임워크")])),_:1,__:[15]})])])]),t("li",null,[n(s,{to:"#리액트-성능-최적화-팁"},{default:a(()=>e[16]||(e[16]=[o("리액트 성능 최적화 팁")])),_:1,__:[16]}),t("ul",null,[t("li",null,[n(s,{to:"#_1-불필요한-렌더링-방지"},{default:a(()=>e[17]||(e[17]=[o("1) 불필요한 렌더링 방지")])),_:1,__:[17]})]),t("li",null,[n(s,{to:"#_2-코드-스플리팅과-레이지-로딩"},{default:a(()=>e[18]||(e[18]=[o("2) 코드 스플리팅과 레이지 로딩")])),_:1,__:[18]})])])]),t("li",null,[n(s,{to:"#마치며"},{default:a(()=>e[19]||(e[19]=[o("마치며")])),_:1,__:[19]})])])]),e[44]||(e[44]=t("hr",null,null,-1)),n(g,{name:"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁 | 요즘IT",desc:"리액트는 프론트엔드 개발에서 가장 널리 사용되고 있는 자바스크립트 라이브러리입니다. 컴포넌트 기반 아키텍처와 가상 DOM 등의 개념을 도입하였으며, 여러 글로벌 기업이 리액트를 활용하여 웹 애플리케이션을 개발하고 있습니다. 이러한 리액트의 장점을 최대한 활용하기 위해서는 리액트의 기본 개념을 이해하고 적절한 성능 최적화 기법을 적용해야 합니다. 이에 본 글에서는 리액트 개발 시 알아야 할 기본 개념을 정리해 보고, 리액트 컴포넌트와 훅, 개발자 도구 및 성능 최적화 팁을 살펴보고자 합니다.",url:"https://yozm.wishket.com/magazine/detail/2688/",logo:"https://yozm.wishket.com/favicon.ico",preview:"https://yozm.wishket.com/media/news/2688/lautaro-andreani-UYsBCu9RP3Y-unsplash.jpg"}),e[45]||(e[45]=r('<p>리액트는 프론트엔드 개발에서 가장 널리 사용되고 있는 자바스크립트 라이브러리입니다. 컴포넌트 기반 아키텍처와 가상 DOM 등의 개념을 도입하였으며, 여러 글로벌 기업이 리액트를 활용하여 웹 애플리케이션을 개발하고 있습니다. 이러한 리액트의 장점을 최대한 활용하기 위해서는 리액트의 기본 개념을 이해하고 적절한 성능 최적화 기법을 적용해야 합니다. 이에 본 글에서는 리액트 개발 시 알아야 할 기본 개념을 정리해 보고, 리액트 컴포넌트와 훅, 개발자 도구 및 성능 최적화 팁을 살펴보고자 합니다.</p><hr><h2 id="리액트의-기본-개념" tabindex="-1"><a class="header-anchor" href="#리액트의-기본-개념"><span>리액트의 기본 개념</span></a></h2><h3 id="_1-컴포넌트-기반-아키텍처" tabindex="-1"><a class="header-anchor" href="#_1-컴포넌트-기반-아키텍처"><span>1) 컴포넌트 기반 아키텍처</span></a></h3><p>컴포넌트 기반 아키텍처는 리액트의 핵심 개념 중 하나이며, 웹 애플리케이션의 복잡한 UI를 <strong>재사용 가능한 단위로 분할</strong>하는 방식을 말합니다. 컴포넌트는 자체적으로 <strong>상태</strong>와 <strong>속성</strong>을 가지고 있으며, 독립적으로 작동합니다. 각 컴포넌트는 특정 기능이나 UI의 한 부분을 책임지며, 이를 통해 개발자는 관심사를 분리하여 개발에 집중할 수 있습니다. 또한 UI를 계층적으로 구조화하여 코드 가독성을 높이고 유지보수를 용이하게 할 수 있습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__1_.png" alt="버튼 컴포넌트 예시" tabindex="0" loading="lazy"><figcaption>버튼 컴포넌트 예시</figcaption></figure><p>컴포넌트 기반 아키텍처를 설계할 때는 구성 요소 간의 <strong>의존성을 최소화</strong>하고, 각 컴포넌트는 한 가지 책임만 진다는 <strong>단일 책임 원칙</strong>을 염두에 두어야 합니다. 즉, 컴포넌트 복잡도를 낮추고 재사용성을 높여야 합니다. 아울러, 다른 개발자가 컴포넌트를 쉽게 이해하고 사용할 수 있도록 컴포넌트 속성과 반환값(return)을 일관되게 작성해야 합니다.</p><h3 id="_2-jsx-문법" tabindex="-1"><a class="header-anchor" href="#_2-jsx-문법"><span>2) JSX 문법</span></a></h3><p>리액트에서는 JSX(JavaScript XML) 문법을 사용합니다. JSX는 <strong>자바스크립트를 확장한 문법</strong>으로 HTML과 유사한 형태이며, 컴포넌트 렌더링 로직과 마크업을 한 곳에서 관리할 수 있습니다. JSX를 작성할 때는 다음과 같은 규칙을 따라야 합니다.</p><ul><li>모든 태그는 반드시 닫혀 있어야 함 (자식 요소가 없는 경우에는 self-closing 사용)</li><li>최상위 요소는 하나여야 함 (여러 요소를 반환해야 하는 경우에는 Fragment(<code>&lt;&gt;``&lt;/&gt;</code>) 사용)</li><li>카멜 케이스(camelCase) 속성명 사용</li><li>중괄호(<code>{ }</code>)를 사용하여 자바스크립트 표현식 사용</li><li>조건부 렌더링은 <code>if</code> 또는 삼항 연산자 사용</li><li>인라인 스타일은 <code>style={{ }}</code> 적용</li><li>주석 작성은 {<code>/* … */</code>} 사용</li></ul><figure><img src="https://yozm.wishket.com/media/news/2688/1__2_.png" alt="JSX 문법 사용 예시" tabindex="0" loading="lazy"><figcaption>JSX 문법 사용 예시</figcaption></figure><h3 id="_3-가상-dom-virtual-dom" tabindex="-1"><a class="header-anchor" href="#_3-가상-dom-virtual-dom"><span>3) 가상 DOM(Virtual DOM)</span></a></h3><p>가상 DOM(Document Object Model)은 실제 DOM을 <strong>추상화한 DOM</strong>을 말합니다. 리액트에서는 컴포넌트가 처음 렌더링 될 때 가상 DOM 트리를 생성하고, 이후 상태나 속성이 변경되면 비교(Diffing)와 조정(Reconciliation) 절차를 통해 변경된 부분만 실제 DOM에 반영(Patch)합니다. 리액트는 이렇게 가상 DOM을 이용하여 불필요한 <strong>DOM 조작을 최소화</strong>합니다.</p>',13)),t("p",null,[e[23]||(e[23]=o("![가상 DOM 동작 방식 ")),e[24]||(e[24]=t("br",null,null,-1)),e[25]||(e[25]=o("<출처: ")),t("a",z,[e[20]||(e[20]=o("미디엄 (")),n(i,{icon:"fa-brands fa-medium"}),e[21]||(e[21]=t("code",null,"resul.dilek",-1)),e[22]||(e[22]=o(")"))]),e[26]||(e[26]=o(">](https://yozm.wishket.com/media/news/2688/1__1_.jpeg"))]),e[46]||(e[46]=r('<h3 id="_4-props와-state" tabindex="-1"><a class="header-anchor" href="#_4-props와-state"><span>4) Props와 State</span></a></h3><p>Props와 State는 속성과 상태를 나타내며, 리액트 컴포넌트에서 데이터를 관리하는 두 가지 주요 개념입니다. <strong>Props</strong>는 Properties의 약자로 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터를 말합니다. Props는 일반적으로 읽기 전용(read-only)이며, 자식 컴포넌트에서 직접 수정할 수 없습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__3_.png" alt="Props 사용 예시" tabindex="0" loading="lazy"><figcaption>Props 사용 예시</figcaption></figure><p><strong>State</strong>는 컴포넌트 내부에서 관리되는 상태 데이터를 말합니다. 컴포넌트 내부에서 직접 수정할 수 있으며, State가 변경되면 컴포넌트는 자동으로 다시 렌더링(Re-rendering)됩니다. 리액트에서는 다양한 방법으로 State를 관리합니다. 그중에서 가장 기본적인 방법이 useState라는 리액트 훅(React Hook)을 사용하는 방법입니다.</p><hr><h2 id="리액트-훅-react-hooks-의-활용" tabindex="-1"><a class="header-anchor" href="#리액트-훅-react-hooks-의-활용"><span>리액트 훅(React Hooks)의 활용</span></a></h2><h3 id="_1-리액트-훅이란" tabindex="-1"><a class="header-anchor" href="#_1-리액트-훅이란"><span>1) 리액트 훅이란?</span></a></h3><p>리액트 훅은 리액트 16.8 버전부터 도입되었으며, 컴포넌트 내에서 다양한 리액트 기능을 사용할 수 있게 해주는 <strong>일종의 함수 API</strong>입니다. 훅을 사용하면 컴포넌트 로직을 더욱 간결하게 작성할 수 있을 뿐만 아니라, 컴포넌트 간에 상태를 공유하거나 불필요한 렌더링을 방지하여 성능을 최적화하는 등의 역할을 수행할 수 있습니다. 리액트에서 제공하는 훅에는 다양한 종류가 있으며, 대표적으로 자주 사용하는 훅으로는 <strong><code>useState</code>, <code>useRef</code>, <code>useEffect</code>, <code>useMemo</code>, <code>useReducer</code> 등</strong>이 있습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__4_.png" alt="리액트 훅 종류 &lt;br/&gt;&lt;출처: react.dev&gt;" tabindex="0" loading="lazy"><figcaption>리액트 훅 종류 <br>&lt;출처: react.dev&gt;</figcaption></figure><h3 id="_2-리액트-훅-사용-예시" tabindex="-1"><a class="header-anchor" href="#_2-리액트-훅-사용-예시"><span>2) 리액트 훅 사용 예시</span></a></h3><h4 id="_1-usestate" tabindex="-1"><a class="header-anchor" href="#_1-usestate"><span>1. <code>useState</code></span></a></h4><p>useState는 컴포넌트에서 <strong>상태를 관리하기 위한 훅</strong>입니다. <code>useState</code>를 사용하면 상태 값과 상태를 업데이트하는 함수를 받습니다. 아래 예제에서는 <code>useState</code>로 count라는 상태 값을 다루고 있습니다. 여기서 <code>setCount</code>는 상태를 업데이트하는 함수입니다. <code>useState(0)</code>는 초기 상태 값을 0으로 설정한 것입니다. 이 컴포넌트에 클릭 이벤트가 발생하면 <code>setCount</code>를 통해 count 값이 변경되고, 해당 컴포넌트는 다시 렌더링됩니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__5_.png" alt=" 사용 예시" tabindex="0" loading="lazy"><figcaption><code>useState</code> 사용 예시</figcaption></figure><h4 id="_2-useref" tabindex="-1"><a class="header-anchor" href="#_2-useref"><span>2. <code>useRef</code>**</span></a></h4><p><code>useRef</code>는 컴포넌트 내에서 <strong>특정 값을 저장하고 참조</strong>할 수 있게 해줍니다. <code>useRef</code>로 생성한 ref 객체는 컴포넌트 생명주기 동안 유지되며, 값이 변경되어도 컴포넌트가 다시 렌더링되지 않습니다. 주로 DOM 엘리먼트에 직접 접근해야 하거나 이전 값을 저장해야 할 때 사용됩니다. useRef를 사용하여 저장한 값은 current 속성으로 접근할 수 있습니다. 아래 예제에서 <code>useRef(null)</code>는 초기 값이 <code>null</code>인 ref 객체를 생성합니다. 이 ref 객체를 input 엘리먼트에 연결하면 inputEl.current를 통해 해당 엘리먼트에 접근할 수 있습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__6_.png" alt=" 사용 예시" tabindex="0" loading="lazy"><figcaption><code>useRef</code> 사용 예시</figcaption></figure><h4 id="_3-useeffect" tabindex="-1"><a class="header-anchor" href="#_3-useeffect"><span>3. <code>useEffect</code></span></a></h4><p>useEffect는 컴포넌트의 <strong>Side Effect(부수 효과)를 처리</strong>하기 위해 사용하는 리액트 훅입니다. useEffect는 컴포넌트가 렌더링된 후에 실행되며, 두 개의 인자를 받습니다. 첫 번째 인자는 Side Effect 함수이고, 두 번째 인자는 의존성 배열입니다. 의존성 배열에 특정 값을 넣으면 그 값이 변경될 때마다 Side Effect 함수가 실행됩니다. 만약 의존성 배열을 빈 배열로 넣으면, 컴포넌트가 마운트될 때만 Side Effect 함수가 실행되며, 의존성 배열을 생략하면 컴포넌트가 업데이트될 때마다 실행됩니다. 아래 예제에서는 useEffect에 의해 count1 값이 변경될 때마다 console.log가 찍히게 됩니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__7_.png" alt=" 사용 예시" tabindex="0" loading="lazy"><figcaption><code>useEffect</code> 사용 예시</figcaption></figure><h4 id="_4-usememo" tabindex="-1"><a class="header-anchor" href="#_4-usememo"><span>4. useMemo</span></a></h4><p><code>useMemo</code>는 계산량이 많은 함수의 반환 값을 **메모이제이션(memoization)**하여 불필요한 중복 계산을 방지하는 리액트 훅입니다. <code>useMemo</code>도 두 개의 인자를 받습니다. 첫 번째 인자는 메모이제이션 할 함수이고, 두 번째 인자는 의존성 배열입니다. <code>useMemo</code>는 의존성 배열에 있는 값이 변경되지 않는 한, 이전에 계산된 값을 재사용합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__8_.png" alt=" 사용 예시" tabindex="0" loading="lazy"><figcaption><code>useMemo</code> 사용 예시</figcaption></figure><p>앞선 <code>useEffect</code>처럼 <code>useMemo</code>도 의존성 배열에 빈 배열을 넣으면 컴포넌트가 마운트될 때만 함수가 실행되고, 의존성 배열을 생략하면 컴포넌트가 업데이트될 때마다 함수가 실행됩니다. 위 예제에서는 <code>useMemo</code>를 사용하여 <code>count</code> 값이 변경될 때만 <code>expensiveResult</code> 함수를 실행하고, 그렇지 않은 경우에는 이전에 계산된 값을 재사용합니다.</p><h4 id="_5-usereducer" tabindex="-1"><a class="header-anchor" href="#_5-usereducer"><span>5. useReducer</span></a></h4><p>useReducer는 useState와 같이 <strong>컴포넌트의 상태를 관리</strong>하기 위한 훅입니다. useState는 컴포넌트 내에 상태를 업데이트하는 로직을 두어야 하는 반면, <code>useReducer</code>는 상태 업데이트 로직을 컴포넌트 외부에 둘 수 있습니다. 이를 통해 중복되는 상태 업데이트 로직을 한 곳에 모아 관리할 수 있습니다. 특히 <strong>여러 개의 상태를 관리</strong>해야 하거나, <strong>프로젝트 규모가 큰 경우</strong>에 유용하게 사용할 수 있는 훅입니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__9_.png" alt=" 사용 예시" tabindex="0" loading="lazy"><figcaption><code>useReducer</code> 사용 예시</figcaption></figure><p>위 예시 코드는 Counter 컴포넌트의 상태를 업데이트하기 위한 <code>useReducer</code> 사용 예시입니다. <code>useReducer</code>를 사용하기 위해서는 Reducer 함수와 Dispatch 함수가 필요합니다. Reducer 함수는 state와 action 객체를 인자로 받아 새로운 상태를 반환하며, Dispatch 함수는 action 객체를 인자로 받아 Reducer 함수를 호출하게 됩니다.</p><h3 id="_3-커스텀-훅-만들기" tabindex="-1"><a class="header-anchor" href="#_3-커스텀-훅-만들기"><span>3) 커스텀 훅 만들기</span></a></h3><p>커스텀 훅(Custom Hooks)은 개발자가 <strong>직접 만들어 사용하는 훅</strong>을 말합니다. 커스텀 훅을 사용하면 컴포넌트 간에 중복되는 로직을 제거하여 코드의 가독성을 높일 수 있습니다. 커스텀 훅을 작성할 때는 <strong>use로 시작하는 함수명</strong>을 써야 하며, 커스텀 훅 내부에 <code>useState</code>와 같은 다른 리액트 훅을 사용할 수 있습니다. 아래 예시는 입력 필드 값을 관리하는 <code>useInput</code>이라는 커스텀 훅 예시입니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__10_.png" alt=" 커스텀 훅" tabindex="0" loading="lazy"><figcaption><code>useInput</code> 커스텀 훅</figcaption></figure><p><code>useInput</code>은 초기값(initialValue)을 인자로 받으며, 내부적으로 useState를 사용하여 입력값의 상태를 관리합니다. 또한 <code>handleChange</code> 함수를 제공하여 입력값의 변경을 처리합니다. 이러한 <code>useInput</code> 커스텀 훅은 일반적인 리액트 훅처럼 다른 컴포넌트에서 사용할 수 있습니다. 아래 예시 코드는 InputComponent에서 <code>useInput</code>을 사용한 예시입니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__11_.png" alt=" 커스텀 훅 사용 예시" tabindex="0" loading="lazy"><figcaption><code>useInput</code> 커스텀 훅 사용 예시</figcaption></figure><h3 id="_4-훅-사용-시-주의-사항" tabindex="-1"><a class="header-anchor" href="#_4-훅-사용-시-주의-사항"><span>4) 훅 사용 시 주의 사항</span></a></h3><p>리액트 훅을 사용할 때는 컴포넌트나 커스텀 훅의 <strong>최상위 레벨에서만 호출</strong>해야 합니다. 즉, 일반 자바스크립트 함수나 반복문, 조건문 내에서는 훅을 호출할 수 없습니다. 이렇게 최상위 레벨에서만 리액트 훅을 호출해야 하는 이유는 리액트가 컴포넌트 렌더링 시, 훅이 동일한 순서로 호출될 것이라고 가정하기 때문입니다. 즉, 자바스크립트 함수나 반복문, 조건문 내에서 훅을 사용하면 호출 순서가 일관되지 않아, 리액트가 정상적으로 동작하지 않을 수 있습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__12_.png" alt="잘못된 훅 사용 예시" tabindex="0" loading="lazy"><figcaption>잘못된 훅 사용 예시</figcaption></figure><p>또한 <strong>훅을 과도하게 사용하면</strong> 오히려 코드의 복잡성을 증가시킬 수 있다는 점도 주의해야 합니다. 훅을 사용할 때는 상태와 로직을 적절히 추상화하여, 불필요한 코드를 추가하지 않도록 해야 합니다. 아울러 의존성 배열을 정확히 명시하여 불필요한 렌더링을 방지해야 합니다.</p><hr><h2 id="리액트-컴포넌트-종류와-데이터-전달-방법" tabindex="-1"><a class="header-anchor" href="#리액트-컴포넌트-종류와-데이터-전달-방법"><span>리액트 컴포넌트 종류와 데이터 전달 방법</span></a></h2><h3 id="_1-클래스형-컴포넌트-vs-함수형-컴포넌트" tabindex="-1"><a class="header-anchor" href="#_1-클래스형-컴포넌트-vs-함수형-컴포넌트"><span>1) 클래스형 컴포넌트 vs 함수형 컴포넌트</span></a></h3><p>리액트 컴포넌트의 종류에는 클래스형 컴포넌트와 함수형 컴포넌트가 있습니다. <strong>클래스형 컴포넌트</strong>는 ES6의 클래스 문법을 사용하며, 상태와 생명주기 메서드를 가집니다. 따라서 클래스형 컴포넌트는 생명주기와 관련된 복잡한 로직을 구현할 때 장점이 있지만, 자칫 코드가 길어져 가독성이 떨어지고 재사용성이 낮아질 수 있습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__13_.png" alt="클래스형 컴포넌트 예시" tabindex="0" loading="lazy"><figcaption>클래스형 컴포넌트 예시</figcaption></figure><p>반면, <strong>함수형 컴포넌트</strong>는 간단한 함수로 정의됩니다. 기존의 자바스크립트 함수 표현식으로 쓸 수 있고, ES6 문법인 화살표 함수를 사용해서 정의할 수도 있습니다. 함수형 컴포넌트 자체로는 상태와 생명주기 메서드를 사용할 수 없지만, 리액트 훅을 통해 상태나 생명주기와 관련된 기능을 사용할 수 있습니다.</p>',42)),t("p",null,[e[28]||(e[28]=o("함수형 컴포넌트는 클래스형 컴포넌트에 비해 코드가 간결하고, 테스트와 디버깅이 용이하다는 장점이 있습니다. 이러한 이유로 현재 ")),t("a",x,[n(i,{icon:"fa-brands fa-react"}),e[27]||(e[27]=o("리액트 공식 문서"))]),e[29]||(e[29]=o("에서는 클래스 컴포넌트 대신 ")),e[30]||(e[30]=t("strong",null,"함수형 컴포넌트를 사용할 것을 권장",-1)),e[31]||(e[31]=o("하고 있습니다."))]),e[47]||(e[47]=r('<figure><img src="https://yozm.wishket.com/media/news/2688/1__14_.png" alt="함수형 컴포넌트 예시" tabindex="0" loading="lazy"><figcaption>함수형 컴포넌트 예시</figcaption></figure><h3 id="_2-컴포넌트-간-데이터-전달-방법" tabindex="-1"><a class="header-anchor" href="#_2-컴포넌트-간-데이터-전달-방법"><span>2) 컴포넌트 간 데이터 전달 방법</span></a></h3><p>기본적으로 리액트에서 컴포넌트 간 데이터를 전달하는 방법은 <strong><code>props</code>를 사용</strong>하는 것입니다. 보통 <code>props</code>를 이용하여 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달합니다. 하지만, 실무에서는 자식에서 부모 컴포넌트로 데이터를 전달해야 하는 경우도 있습니다.</p><p>비록 리액트에서는 단방향 데이터 흐름(one-way data flow)을 권장하고 있지만, 이런 경우에는 부모 컴포넌트에서 콜백 함수를 props로 전달하고, 자식 컴포넌트에서 해당 함수를 호출하는 방식으로 처리하기도 합니다. 이때 <strong><code>useCallback</code> 훅</strong>을 사용하여 부모 컴포넌트가 렌더링될 때, 불필요하게 자식 컴포넌트가 렌더링되지 않도록 하는 것이 중요합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__15_.png" alt="콜백 함수를 이용한 데이터 전달 예시" tabindex="0" loading="lazy"><figcaption>콜백 함수를 이용한 데이터 전달 예시</figcaption></figure><p>웹 애플리케이션의 규모가 커지면 <code>props</code>를 통한 데이터 전달이 복잡해집니다. 이런 경우에는 리액트에서 기본적으로 제공하는 <strong>Context API</strong>를 이용하기도 합니다. Context API는 컴포넌트 트리 상위에서 데이터를 제공하고 하위의 어떤 컴포넌트에서든 해당 데이터에 접근할 수 있게 해줍니다.</p><p>이를 통해 props 드릴링(drilling)이 없이도 데이터를 전달할 수 있습니다. 또한 리덕스(Redux), 몹엑스(MobX), 주스탠드(Zustand) 같은 <strong>상태 관리 라이브러리</strong>를 사용하면 전역 상태를 관리할 수 있어 컴포넌트 간 데이터 전달을 더욱 용이하게 할 수 있습니다.</p><hr><h2 id="리액트-개발자-도구와-프레임워크" tabindex="-1"><a class="header-anchor" href="#리액트-개발자-도구와-프레임워크"><span>리액트 개발자 도구와 프레임워크</span></a></h2><h3 id="_1-리액트-개발자-도구" tabindex="-1"><a class="header-anchor" href="#_1-리액트-개발자-도구"><span>1) 리액트 개발자 도구</span></a></h3><p>리액트 개발자 도구(React Developer Tools)는 메타(Meta)에서 오픈소스로 개발한 도구로서, 크롬 웹 스토어와 파이어폭스 애드온에서 다운로드 받아 설치할 수 있는 <strong>브라우저 확장 도구</strong>입니다. 리액트 컴포넌트 계층 구조를 시각적으로 보여줘 컴포넌트 간의 관계를 쉽게 파악할 수 있으며, 각 컴포넌트의 Props와 State를 실시간으로 확인할 수 있어, 데이터의 흐름을 추적하고 <strong>디버깅하는 데 필수적인 도구</strong>입니다.</p>',11)),t("figure",null,[e[37]||(e[37]=t("img",{src:"https://yozm.wishket.com/media/news/2688/1__16_.png",alt:'리액트 개발자 도구 <br/><출처: <VPIcon icon="fa-brands fa-react"/>react.dev>',tabindex:"0",loading:"lazy"},null,-1)),t("figcaption",null,[e[33]||(e[33]=o("리액트 개발자 도구 ")),e[34]||(e[34]=t("br",null,null,-1)),e[35]||(e[35]=o("<출처: ")),t("a",R,[n(i,{icon:"fa-brands fa-react"}),e[32]||(e[32]=o("react.dev"))]),e[36]||(e[36]=o(">"))])]),e[48]||(e[48]=t("h3",{id:"_2-리액트-프레임워크",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_2-리액트-프레임워크"},[t("span",null,"2) 리액트 프레임워크")])],-1)),e[49]||(e[49]=t("p",null,[o("리액트로 앱이나 웹사이트를 개발할 때 대부분 "),t("strong",null,"리액트 기반의 프레임워크"),o("를 사용하게 됩니다. 리액트 자체만으로는 코드 분할이나 라우팅, 데이터 패칭 등을 구현하기 어렵기 때문에 추가적인 도구나 라이브러리를 사용해야 합니다. 하지만 리액트 기반의 프레임워크는 이러한 일반적인 문제들을 해결하기 위한 솔루션을 제공해 주며, 개발자가 빠르게 리액트 프로젝트를 시작할 수 있도록 해줍니다.")],-1)),t("figure",null,[e[43]||(e[43]=t("img",{src:"https://yozm.wishket.com/media/news/2688/1__17_.png",alt:'Next.js 주요 기능 <br/><출처: <VPIcon icon="iconfont icon-nextjs"/>nextjs.org>',tabindex:"0",loading:"lazy"},null,-1)),t("figcaption",null,[e[39]||(e[39]=o("Next.js 주요 기능 ")),e[40]||(e[40]=t("br",null,null,-1)),e[41]||(e[41]=o("<출처: ")),t("a",S,[n(i,{icon:"iconfont icon-nextjs"}),e[38]||(e[38]=o("nextjs.org"))]),e[42]||(e[42]=o(">"))])]),e[50]||(e[50]=r('<p>대표적인 리액트 프레임워크로는 Next.js, Remix, Gatsby, Astro 등이 있으며, 네이티브 앱 개발을 위해서는 Expo가 있습니다. 이러한 프레임워크를 사용하면 리액트로 개발할 때 프로젝트 구조 생성과 라우팅, 캐싱, 서버 사이드 렌더링과 같은 기능을 손쉽게 구현할 수 있습니다.</p><hr><h2 id="리액트-성능-최적화-팁" tabindex="-1"><a class="header-anchor" href="#리액트-성능-최적화-팁"><span>리액트 성능 최적화 팁</span></a></h2><h3 id="_1-불필요한-렌더링-방지" tabindex="-1"><a class="header-anchor" href="#_1-불필요한-렌더링-방지"><span>1) 불필요한 렌더링 방지</span></a></h3><p>컴포넌트 렌더링은 애플리케이션 성능에 큰 영향을 미칩니다. 따라서 리액트 애플리케이션 성능을 최적화하기 위해서는 먼저 불필요한 렌더링을 방지하는 것이 중요합니다. 예를 들어, 함수형 컴포넌트에서 특정 props의 변화에만 컴포넌트가 렌더링되게 하려면 <strong>React.memo를 사용</strong>하는 방법이 있습니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__18_.png" alt=" 사용 예시" tabindex="0" loading="lazy"><figcaption><code>React.memo</code> 사용 예시</figcaption></figure><p>참고로 <code>React.memo</code>는 <strong>고차 컴포넌트</strong>(Higher-Order Component)입니다. 고차 컴포넌트란 컴포넌트를 인자로 받아 새 컴포넌트를 반환하는 함수를 말합니다. <code>React.memo</code>는 함수형 컴포넌트를 인자로 받아 메모이제이션 된 컴포넌트를 반환합니다. 따라서 위 예시와 같이 부모 컴포넌트에서 자식 컴포넌트와 관련이 없는 count 상태 값이 변경되더라도, 자식 컴포넌트에 대한 불필요한 렌더링이 발생하지 않습니다.</p><p>이와 같이 <code>React.memo</code>는 특정 props의 변경에만 렌더링되도록 조건을 설정할 수 있습니다. 다만 <code>React.memo</code>는 **얕은 비교(Shallow Equal)**를 하기 때문에, props가 함수이거나 객체인 경우에는 자식 컴포넌트의 렌더링이 발생할 수 있습니다. 이를 해결하기 위해서 아래 코드처럼 <code>useCallback</code>이나 <code>useMemo</code>와 같은 훅을 사용하기도 합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__19_.png" alt="메모이제이션 훅 사용 예시" tabindex="0" loading="lazy"><figcaption>메모이제이션 훅 사용 예시</figcaption></figure><p><code>useCallback</code>과 <code>useMemo</code>를 사용하면 콜백 함수나 객체를 메모이제이션하여 부모 컴포넌트에서 새로운 함수나 객체 주소가 할당되더라도, 자식 컴포넌트의 렌더링을 방지할 수 있습니다. 다만 <code>useCallback</code>이나 <code>useMemo</code>와 같은 메모이제이션 훅은 추가적인 메모리가 필요하므로, <strong>무분별하게 사용하면 오히려 성능이 저하</strong>될 수도 있으니 주의해야 합니다.</p><h3 id="_2-코드-스플리팅과-레이지-로딩" tabindex="-1"><a class="header-anchor" href="#_2-코드-스플리팅과-레이지-로딩"><span>2) 코드 스플리팅과 레이지 로딩</span></a></h3><p>코드 스플리팅(Code Splitting)은 번들링된 자바스크립트 코드를 여러 개의 작은 조각 단위(chunk)로 분할하는 것을 말합니다. 일반적으로 리액트 애플리케이션은 모든 코드를 하나의 큰 번들로 빌드하여 배포하는데, 이는 초기 로딩 시간을 길어지게 할 수 있습니다. 반면 코드 스플리팅을 하면 <strong>필요한 코드만 동적으로 로드</strong>하여 초기 번들 크기를 줄이고, 로딩 속도를 개선할 수 있습니다. 리액트에서 코드 스플리팅을 구현하기 위해서는 <code>React.lazy()</code> 함수와 Suspense 컴포넌트를 이용한 **레이지 로딩(Lazy Loading)**을 이용하기도 합니다.</p><figure><img src="https://yozm.wishket.com/media/news/2688/1__20_.png" alt="레이지 로딩 예시" tabindex="0" loading="lazy"><figcaption>레이지 로딩 예시</figcaption></figure><p>위 예제 코드에서는 <code>React.lazy()</code>의 동적 임포트를 통해 컴포넌트 로딩을 지연하고, <code>Suspense</code> 컴포넌트로 로딩 중 폴백(fallback) UI를 보여주어 레이지 로딩을 구현하고 있습니다. 이처럼 레이지 로딩을 적용하면, 애플리케이션의 초기 로딩 속도와 성능을 최적화할 수 있습니다.</p><hr><h2 id="마치며" tabindex="-1"><a class="header-anchor" href="#마치며"><span>마치며</span></a></h2><p>지금까지 리액트 개발 시 알아두어야 할 기본 개념과 성능 최적화 팁을 살펴보았습니다. 특히 리액트의 핵심 개념인 컴포넌트 기반 아키텍처, JSX 문법, 가상 DOM, Props와 State, 클래스형 컴포넌트와 함수형 컴포넌트의 차이점 등을 중점적으로 다뤘습니다.</p><p>더불어 리액트 훅, 리액트 개발 도구, 리액트 프레임워크에 관한 내용도 함께 정리했습니다. 실무에서 활용할 수 있는 성능 최적화 방법으로는 React.memo와 메모이제이션 훅, 코드 스플리팅을 위한 레이지 로딩 구현 방법을 살펴봤는데요. 이번 글에서 정리한 내용이 현재 리액트를 사용하고 있거나, 이제 막 리액트 공부를 시작하는 개발자분들에게 도움이 되길 바랍니다.</p>',18))])}const P=c(w,[["render",M]]),C=JSON.parse('{"path":"/yozm.wishket.com/2688.html","title":"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁","description":"Article(s) > 알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁","icon":"fas fa-user-tie","category":["Node.js","React.js","Article(s)"],"tag":["blog","yozm.wishket.com","node","nodejs","node-js","react","reactjs","react-js"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁\\",\\"image\\":[\\"https://yozm.wishket.com/media/news/2688/1__1_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__2_.png\\",\\"https://medium.com/@resul.dilek/react-the-virtual-dom-4a54b4c31973\\",\\"https://yozm.wishket.com/media/news/2688/1__3_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__4_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__5_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__6_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__7_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__8_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__9_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__10_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__11_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__12_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__13_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__14_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__15_.png\\",\\"https://react.dev/learn/react-developer-tools\\",\\"http://nextjs.org\\",\\"https://yozm.wishket.com/media/news/2688/1__18_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__19_.png\\",\\"https://yozm.wishket.com/media/news/2688/1__20_.png\\"],\\"datePublished\\":\\"2024-07-25T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2688.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁"}],["meta",{"property":"og:description","content":"Article(s) > 알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yozm.wishket.com/media/news/2688/lautaro-andreani-UYsBCu9RP3Y-unsplash.jpg"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://yozm.wishket.com/media/news/2688/lautaro-andreani-UYsBCu9RP3Y-unsplash.jpg"}],["meta",{"name":"twitter:image:alt","content":"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁"}],["meta",{"property":"article:tag","content":"react-js"}],["meta",{"property":"article:tag","content":"reactjs"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"node-js"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:tag","content":"yozm.wishket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-07-25T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > 알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁"},{"property":"og:description","content":"알아두면 유용한 ‘리액트’ 개념과 성능 최적화 팁"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2688.html"}]],"prev":"/programming/js-react/articles/README.md","date":"2024-07-25T00:00:00.000Z","isOriginal":false,"cover":"https://yozm.wishket.com/media/news/2688/lautaro-andreani-UYsBCu9RP3Y-unsplash.jpg"},"git":{},"readingTime":{"minutes":1.86,"words":558},"filePathRelative":"yozm.wishket.com/2688.md"}');export{P as comp,C as data};
