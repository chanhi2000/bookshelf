import{_ as b}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as v,d as e,f as n,b as c,a as y,t as f,n as u,g as d,w as s,r as o,o as k,e as t}from"./app-BItykJLQ.js";const w={},q={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},S={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},L={class:"table-of-contents"};function T(m,a){const p=o("VPCard"),i=o("router-link"),h=o("SiteInfo"),g=o("Tabs");return k(),v("div",null,[e("h1",q,[e("a",S,[e("span",null,f(m.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),n(p,u(d({title:"Data Science > Article(s)",desc:"Article(s)",link:"/data-science/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e("nav",L,[e("ul",null,[e("li",null,[n(i,{to:"#the-supposed-optimization"},{default:s(()=>[...a[0]||(a[0]=[t('The Supposed "Optimization"',-1)])]),_:1})]),e("li",null,[n(i,{to:"#testing-with-real-data"},{default:s(()=>[...a[1]||(a[1]=[t("Testing with Real Data",-1)])]),_:1})]),e("li",null,[n(i,{to:"#the-results"},{default:s(()=>[...a[2]||(a[2]=[t("The Results",-1)])]),_:1})]),e("li",null,[n(i,{to:"#query-optimizers-are-smarter-than-you"},{default:s(()=>[...a[3]||(a[3]=[t("Query Optimizers Are Smarter Than You",-1)])]),_:1})]),e("li",null,[n(i,{to:"#how-cost-based-optimization-works"},{default:s(()=>[...a[4]||(a[4]=[t("How Cost-Based Optimization Works",-1)])]),_:1})]),e("li",null,[n(i,{to:"#summary"},{default:s(()=>[...a[5]||(a[5]=[t("Summary",-1)])]),_:1})])])]),a[10]||(a[10]=e("hr",null,null,-1)),n(h,{name:"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth",desc:"That viral SQL performance tip about filtering before joining? It is complete nonsense. Here is why query optimizers make it irrelevant.",url:"https://milanjovanovic.tech/blog/debunking-the-filter-early-join-later-sql-performance-myth",logo:"https://milanjovanovic.tech/profile_favicon.png",preview:"https://milanjovanovic.tech/blog-covers/mnw_145.png"}),a[11]||(a[11]=c(`<p>I came across a Medium article with 700+ claps promoting this &quot;SQL performance trick&quot;:</p><p><strong>&quot;Filter Early, JOIN Later&quot;</strong></p><figure><img src="https://milanjovanovic.tech/blogs/mnw_145/sql_performance_tip.png?imwidth=1920" alt="SQL performance tip that doesn&#39;t actually work." tabindex="0" loading="lazy"><figcaption>SQL performance tip that doesn&#39;t actually work.</figcaption></figure><p>Source: SQL Tricks that Cut My Query Time by 80%</p><p>The claim goes like this: instead of joining tables first and then filtering, you should filter in a subquery first, then join.</p><p>The supposed benefit?</p><blockquote><p>The database filtered the smaller table first, then did the JOIN ‚Äî saving time and memory.</p></blockquote><p>Here is the thing - this advice is <strong>completely wrong</strong> for modern databases.</p><p>Let me show you why with actual data.</p><hr><h2 id="the-supposed-optimization" tabindex="-1"><a class="header-anchor" href="#the-supposed-optimization"><span>The Supposed &quot;Optimization&quot;</span></a></h2><p>The article shows two queries. Here is the &quot;bad&quot; version:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users u</span>
<span class="line"><span class="token keyword">JOIN</span> orders o </span>
<span class="line"><span class="token keyword">ON</span> u<span class="token punctuation">.</span>id <span class="token operator">=</span> o<span class="token punctuation">.</span>user_id</span>
<span class="line"><span class="token keyword">WHERE</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span></span>
<span class="line"><span class="token operator">AND</span> o<span class="token punctuation">.</span>total <span class="token operator">&gt;</span> <span class="token number">500</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>And the &quot;optimized&quot; version:</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code class="language-sql"><span class="line"><span class="token keyword">SELECT</span> <span class="token operator">*</span></span>
<span class="line"><span class="token keyword">FROM</span> <span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> orders <span class="token keyword">WHERE</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span> <span class="token operator">AND</span> total <span class="token operator">&gt;</span> <span class="token number">500</span></span>
<span class="line"><span class="token punctuation">)</span> o</span>
<span class="line"><span class="token keyword">JOIN</span> users u <span class="token keyword">ON</span> u<span class="token punctuation">.</span>id <span class="token operator">=</span> o<span class="token punctuation">.</span>user_id<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The claim is that the second query is faster because it ‚Äúfilters first, then joins.&quot;</p><p>Sounds logical, right? <strong>Wrong.</strong></p><hr><h2 id="testing-with-real-data" tabindex="-1"><a class="header-anchor" href="#testing-with-real-data"><span>Testing with Real Data</span></a></h2><p>I tested both queries on a PostgreSQL database with:</p><ul><li>10,000 users</li><li>5,000,000 orders (500 per user)</li><li>Filtering for orders &gt; $500</li></ul><p>Let me run <code>EXPLAIN ANALYZE</code> on both queries to see what actually happens.</p><hr><h2 id="the-results" tabindex="-1"><a class="header-anchor" href="#the-results"><span>The Results</span></a></h2><p>Here are the execution plans for both queries:</p>`,25)),n(g,{data:[{id:"'Bad' Query Execution Plan"},{id:"'Optimized' Query Execution Plan:"}],active:0},{title0:s(({value:r,isActive:l})=>[...a[6]||(a[6]=[t("'Bad' Query Execution Plan",-1)])]),title1:s(({value:r,isActive:l})=>[...a[7]||(a[7]=[t("'Optimized' Query Execution Plan:",-1)])]),tab0:s(({value:r,isActive:l})=>[...a[8]||(a[8]=[e("div",{class:"language-plaintext line-numbers-mode","data-highlighter":"prismjs","data-ext":"plaintext"},[e("pre",null,[e("code",{class:"language-plaintext"},[e("span",{class:"line"},"Hash Join  (cost=280.00..96321.92 rows=2480444 width=27) (actual time=1.014..641.202 rows=2499245 loops=1)"),t(`
`),e("span",{class:"line"},"  Hash Cond: (o.user_id = u.id)"),t(`
`),e("span",{class:"line"},"  ->  Seq Scan on orders o  (cost=0.00..89528.00 rows=2480444 width=14) (actual time=0.006..368.857 rows=2499245 loops=1)"),t(`
`),e("span",{class:"line"},"        Filter: (total > '500'::numeric)"),t(`
`),e("span",{class:"line"},"        Rows Removed by Filter: 2500755"),t(`
`),e("span",{class:"line"},"  ->  Hash  (cost=155.00..155.00 rows=10000 width=13) (actual time=0.998..0.999 rows=10000 loops=1)"),t(`
`),e("span",{class:"line"},"        Buckets: 16384  Batches: 1  Memory Usage: 577kB"),t(`
`),e("span",{class:"line"},"        ->  Seq Scan on users u  (cost=0.00..155.00 rows=10000 width=13) (actual time=0.002..0.341 rows=10000 loops=1)"),t(`
`),e("span",{class:"line"},"Planning Time: 0.121 ms"),t(`
`),e("span",{class:"line"},"Execution Time: 685.818 ms"),t(`
`),e("span",{class:"line"})])]),e("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1)])]),tab1:s(({value:r,isActive:l})=>[...a[9]||(a[9]=[e("div",{class:"language-plaintext line-numbers-mode","data-highlighter":"prismjs","data-ext":"plaintext"},[e("pre",null,[e("code",{class:"language-plaintext"},[e("span",{class:"line"},"Hash Join  (cost=280.00..96321.92 rows=2480444 width=27) (actual time=1.019..640.613 rows=2499245 loops=1)"),t(`
`),e("span",{class:"line"},"  Hash Cond: (orders.user_id = u.id)"),t(`
`),e("span",{class:"line"},"  ->  Seq Scan on orders  (cost=0.00..89528.00 rows=2480444 width=14) (actual time=0.005..368.260 rows=2499245 loops=1)"),t(`
`),e("span",{class:"line"},"        Filter: (total > '500'::numeric)"),t(`
`),e("span",{class:"line"},"        Rows Removed by Filter: 2500755"),t(`
`),e("span",{class:"line"},"  ->  Hash  (cost=155.00..155.00 rows=10000 width=13) (actual time=1.004..1.005 rows=10000 loops=1)"),t(`
`),e("span",{class:"line"},"        Buckets: 16384  Batches: 1  Memory Usage: 577kB"),t(`
`),e("span",{class:"line"},"        ->  Seq Scan on users u  (cost=0.00..155.00 rows=10000 width=13) (actual time=0.003..0.348 rows=10000 loops=1)"),t(`
`),e("span",{class:"line"},"Planning Time: 0.118 ms"),t(`
`),e("span",{class:"line"},"Execution Time: 685.275 ms"),t(`
`),e("span",{class:"line"})])]),e("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1)])]),_:1}),a[12]||(a[12]=c(`<p><strong>The execution plans are identical.</strong></p><p>Both queries took ~685ms. The &quot;optimization&quot; did absolutely nothing.</p><p>Here&#39;s the simplified execution plan, where I removed some details:</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">Hash Join</span>
<span class="line">  Hash Cond: (o.user_id = u.id)</span>
<span class="line">  -&gt;  Seq Scan on orders o</span>
<span class="line">        Filter: (total &gt; &#39;500&#39;::numeric)</span>
<span class="line">        Rows Removed by Filter</span>
<span class="line">  -&gt;  Hash</span>
<span class="line">        -&gt;  Seq Scan on users u</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The core operations are:</p><ol><li>Sequential Scan on <code>orders</code> table with filter applied</li><li>Sequential Scan on <code>users</code> table</li><li>Hash operation to build hash table from <code>users</code></li><li>Hash Join using the hash condition on <code>user_id</code></li></ol><hr><h2 id="query-optimizers-are-smarter-than-you" tabindex="-1"><a class="header-anchor" href="#query-optimizers-are-smarter-than-you"><span>Query Optimizers Are Smarter Than You</span></a></h2><p>Modern databases use <strong>cost-based optimizers</strong>. Here is what happens when you run a query:</p><ol><li><strong>Parser</strong> turns your SQL into an abstract syntax tree</li><li><strong>Optimizer</strong> rewrites your query into the most efficient form</li><li><strong>Executor</strong> runs the optimized plan</li></ol><p>The optimizer looks at your query and says: &quot;I don&#39;t care how you wrote this. I will figure out the best way to execute it.&quot;</p><p>Both of our queries get rewritten to the same optimal plan:</p><ul><li>Filter the orders table first (because that eliminates rows early)</li><li>Build a hash table from users (the smaller table)</li><li>Hash join the filtered orders with users</li></ul><p><strong>The optimizer already does the &quot;optimization&quot; automatically.</strong></p><p>Your manual subquery does not make it faster - it just makes your SQL harder to read.</p><hr><h2 id="how-cost-based-optimization-works" tabindex="-1"><a class="header-anchor" href="#how-cost-based-optimization-works"><span>How Cost-Based Optimization Works</span></a></h2><p>The query optimizer has statistics about your tables:</p><ul><li>Row counts</li><li>Data distribution</li><li>Index availability</li><li>Column selectivity</li></ul><p>It uses these stats to estimate the cost of different execution strategies:</p><ul><li>Which table to scan first</li><li>Which join algorithm to use (hash, nested loop, merge)</li><li>When to apply filters</li><li>Which indexes to use</li></ul><p>Then it picks the cheapest plan. Your well-intentioned manual &quot;optimization&quot; gets ignored because the optimizer knows better.</p><hr><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>The ‚ÄúFilter Early, JOIN Later&quot; advice is a relic from ancient database systems that did not have sophisticated optimizers.</p><p>Modern databases like PostgreSQL, MySQL, and SQL Server already do predicate pushdown and join reordering automatically. Your manual &quot;optimizations&quot; are pointless and make code harder to maintain.</p><p>Write clear, readable SQL. Let the optimizer do its job.</p><p><strong>The real lesson?</strong> Stop believing every performance tip you read online. Use <code>EXPLAIN ANALYZE</code> to understand what your database is actually doing.</p><hr>`,29)),y(" TODO: add ARTICLE CARD "),n(p,u(d({title:"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth",desc:"That viral SQL performance tip about filtering before joining? It is complete nonsense. Here is why query optimizers make it irrelevant.",link:"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/debunking-the-filter-early-join-later-sql-performance-myth.html",logo:"https://milanjovanovic.tech/profile_favicon.png",background:"rgba(79,70,229,0.2)"})),null,16)])}const j=b(w,[["render",T]]),z=JSON.parse('{"path":"/milanjovanovic.tech/debunking-the-filter-early-join-later-sql-performance-myth.html","title":"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth","lang":"en-US","frontmatter":{"lang":"en-US","title":"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth","description":"Article(s) > Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth","icon":"fas fa-database","category":["Data Science","Article(s)"],"tag":["blog","milanjovanovic.tech","data-science"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth\\",\\"image\\":[\\"https://milanjovanovic.tech/blogs/mnw_145/sql_performance_tip.png?imwidth=1920\\"],\\"datePublished\\":\\"2025-06-07T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Milan Jovanoviƒá\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/debunking-the-filter-early-join-later-sql-performance-myth.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth"}],["meta",{"property":"og:description","content":"Article(s) > Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://milanjovanovic.tech/blog-covers/mnw_145.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://milanjovanovic.tech/blog-covers/mnw_145.png"}],["meta",{"name":"twitter:image:alt","content":"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth"}],["meta",{"property":"article:author","content":"Milan Jovanoviƒá"}],["meta",{"property":"article:tag","content":"data-science"}],["meta",{"property":"article:tag","content":"milanjovanovic.tech"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-06-07T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth"},{"property":"og:description","content":"Debunking the ‚ÄúFilter Early, JOIN Later‚Äù SQL Performance Myth"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/debunking-the-filter-early-join-later-sql-performance-myth.html"}]],"prev":"/data-science/articles/README.md","date":"2025-06-07T00:00:00.000Z","isOriginal":false,"author":"Milan Jovanoviƒá","cover":"https://milanjovanovic.tech/blog-covers/mnw_145.png"},"git":{},"readingTime":{"minutes":3.43,"words":1028},"filePathRelative":"milanjovanovic.tech/debunking-the-filter-early-join-later-sql-performance-myth.md","copyright":{"author":"Milan Jovanoviƒá"}}');export{j as comp,z as data};
