import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as f,d as n,f as t,b as c,a as g,t as k,n as p,g as l,w as s,e as o,r as i,o as y}from"./app-BItykJLQ.js";const b={},v={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},w={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},x={class:"table-of-contents"},M={href:"https://reactjs.org/docs/hooks-reference.html#usememo",target:"_blank",rel:"noopener noreferrer"};function R(d,e){const r=i("VPCard"),a=i("router-link"),u=i("SiteInfo"),m=i("VPIcon");return y(),f("div",null,[n("h1",v,[n("a",w,[n("span",null,k(d.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),t(r,p(l({title:"React.js > Article(s)",desc:"Article(s)",link:"/programming/js-react/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",x,[n("ul",null,[n("li",null,[t(a,{to:"#introduction"},{default:s(()=>[...e[0]||(e[0]=[o("Introduction",-1)])]),_:1})]),n("li",null,[t(a,{to:"#referential-equality-and-expensive-operations"},{default:s(()=>[...e[1]||(e[1]=[o("Referential Equality and Expensive Operations",-1)])]),_:1})]),n("li",null,[t(a,{to:"#understanding-memoization"},{default:s(()=>[...e[2]||(e[2]=[o("Understanding Memoization",-1)])]),_:1})]),n("li",null,[t(a,{to:"#creating-a-usememo-example"},{default:s(()=>[...e[3]||(e[3]=[o("Creating a useMemo Example",-1)])]),_:1})]),n("li",null,[t(a,{to:"#when-to-use-usememo"},{default:s(()=>[...e[4]||(e[4]=[o("When to Use useMemo",-1)])]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#using-the-right-hook-for-the-job"},{default:s(()=>[...e[5]||(e[5]=[o("Using the Right Hook for the Job",-1)])]),_:1})])])]),n("li",null,[t(a,{to:"#conclusion"},{default:s(()=>[...e[6]||(e[6]=[o("Conclusion",-1)])]),_:1})])])]),e[12]||(e[12]=n("hr",null,null,-1)),t(u,{name:"Understanding the React useMemo Hook",desc:"This article will explore how re-rendering works in React, why that is an important consideration for React applications, and how the useMemo hook can leve‚Ä¶ ",url:"https://digitalocean.com/community/tutorials/react-usememo",logo:"https://digitalocean.com/_next/static/media/favicon.594d6067.ico",preview:"https://digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg"}),e[13]||(e[13]=c('<h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><p>With the release of React 16.8, there are many useful hooks you can now use in your React applications. One of the built-in Hooks that was introduced in 16.8 is <code>useMemo</code>. This hook has the potential to improve performance in your application.</p><p>This article will explore how re-rendering works in React, why that is an important consideration for React applications, and how the <code>useMemo</code> hook can leverage it to create a performance boost in your applications. You will also learn when <code>useMemo</code> can cause performance issues.</p><div class="hint-container note"><p class="hint-container-title">Prerequisites</p><p>To complete this tutorial, you will need:</p><ul><li>A basic understanding of React before starting this tutorial. You can learn more about React by following the <a href="/community/tutorial-series/how-to-code-in-react-js" target="_blank" rel="noopener noreferrer">How to Code in React.js</a> series.</li></ul></div><hr><h2 id="referential-equality-and-expensive-operations" tabindex="-1"><a class="header-anchor" href="#referential-equality-and-expensive-operations"><span>Referential Equality and Expensive Operations</span></a></h2><p>There are two problems that <code>useMemo</code> seeks to address:</p><ul><li>referential equality</li><li>computationally expensive operations</li></ul><p>In the lifecycle of a component, React re-renders the component when an update is made. When React checks for any changes in a component, it may detect an unintended or unexpected change due to how JavaScript handles equality and shallow comparisons. This change in the React application will cause it to re-render unnecessarily.</p><p>Additionally, if that re-rendering is an expensive operation, like a long <code>for loop</code>, it can hurt performance. Expensive operations can be costly in either time, memory, or processing. In addition to potential technical issues, this may lead to poor user experience.</p><p>If one part re-renders, it re-renders the entire component tree.</p><p>Thus, React released the <code>memo</code> idea to fix this.</p><hr><h2 id="understanding-memoization" tabindex="-1"><a class="header-anchor" href="#understanding-memoization"><span>Understanding Memoization</span></a></h2><p><em>Memoization</em> is an optimization technique that passes a complex function to be memoized. In memoization, the result is ‚Äúremembered‚Äù when the same parameters are passed-in subsequently.</p><p>If we have a function compute <code>1 + 1</code>, it will return <code>2</code>. But if it uses memoization, the next time we run <code>1</code>‚Äôs through the function, it won‚Äôt add them up; it will just remember the answer is <code>2</code> without executing the adding function.</p>',16)),n("p",null,[e[8]||(e[8]=o("From the official ",-1)),n("a",M,[t(m,{icon:"fa-brands fa-react"}),e[7]||(e[7]=o("React documentation",-1))]),e[9]||(e[9]=o(", ",-1)),e[10]||(e[10]=n("code",null,"useMemo",-1)),e[11]||(e[11]=o("‚Äôs signature looks like this:",-1))]),e[14]||(e[14]=c(`<div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">const</span> memoizedValue <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">computeExpensiveValue</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><code>useMemo</code> takes in a function and an array of dependencies.</p><p>The dependencies act similar to arguments in a function. The dependency‚Äôs list are the elements <code>useMemo</code> watches: if there are no changes, the function result will stay the same. Otherwise, it will re-run the function. If they don‚Äôt change, it doesn‚Äôt matter if our entire component re-renders, the function won‚Äôt re-run but instead return the stored result. This can be optimal if the wrapped function is large and expensive. That is the primary use for <code>useMemo</code>.</p><hr><h2 id="creating-a-usememo-example" tabindex="-1"><a class="header-anchor" href="#creating-a-usememo-example"><span>Creating a <code>useMemo</code> Example</span></a></h2><p>Here is an abstract example of using <code>useMemo</code> for an array of items that uses two computationally expensive functions:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">const</span> List <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> </span>
<span class="line">  listOfItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token operator">...</span>item<span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">itemProp1</span><span class="token operator">:</span> <span class="token function">expensiveFunction</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>first<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">itemProp2</span><span class="token operator">:</span> <span class="token function">anotherPriceyFunction</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>second<span class="token punctuation">)</span> </span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>listOfItems<span class="token punctuation">]</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the above example, the <code>useMemo</code> function would run on the first render. It would block the thread until the expensive functions complete, as <code>useMemo</code> runs in the first render.</p><p>Initially, this will not look as clean as <code>useEffect</code>, since <code>useEffect</code> can render a loading spinner until the expensive functions finish and the effects fire off.</p><p>However, in subsequent renders, the expensive functions would not need to run again as long as <code>listOfItems</code> never changed. <code>useMemo</code> would ‚Äúremember‚Äù the return value of each function.</p><p>It would make these expensive functions appear to render instantaneous. This is ideal if you have an expensive, synchronous function or two.</p><hr><h2 id="when-to-use-usememo" tabindex="-1"><a class="header-anchor" href="#when-to-use-usememo"><span>When to Use <code>useMemo</code></span></a></h2><p>Write the code first and then revisit it to see if you can optimize it. If you implement <code>useMemo</code> too often in an application, it can harm the performance.</p><p>When looking to implement <code>useMemo</code>, you can check with profiling tools to identify expensive performance issues. <em>Expensive</em> means it is using up a lot of resources (like memory). If you are defining a good number of variables in a function at render, it makes sense to memoize with <code>useMemo</code>.</p><h3 id="using-the-right-hook-for-the-job" tabindex="-1"><a class="header-anchor" href="#using-the-right-hook-for-the-job"><span>Using the Right Hook for the Job</span></a></h3><p>In addition to <code>useMemo</code>, there is also <code>useCallback</code>, <code>useRef</code>, and <code>useEffect</code>.</p><p>The <code>useCallback</code> hook is similar to <code>useMemo</code>, but it returns a memoized function, while <code>useMemo</code> has a function that returns a value.</p><p>If your dependencies array is not provided, there is no possibility of memoization, and it will compute a new value on every render. You could use the <code>useRef</code> hook in that instance. The advantage <code>useMemo</code> offers over <code>useRef</code> is a re-memoizing if the dependencies change.</p><p>You won‚Äôt want to have <code>useMemo</code> fire off any side effects or any asynchronous calls. In those instances, you should use <code>useEffect</code>.</p><hr><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>This article explored the <code>useMemo</code> hook and when it is appropriate to use it in a React application.</p><p><code>useMemo</code> can help the performance of an application by ‚Äúremembering‚Äù expensive functions and preventing a re-render every time there is a change in the application.</p><p>While performance can be improved by using this hook, it can also slow down your application if you overuse it. The more you use the hook, the more your application has to allocate memory.</p><p>To learn more about React‚Äôs best practices, follow the full <a href="/community/tutorial-series/how-to-code-in-react-js" target="_blank" rel="noopener noreferrer">How To Code in React.js</a> series on DigitalOcean.</p>`,26)),g(" TODO: add ARTICLE CARD "),t(r,p(l({title:"Understanding the React useMemo Hook",desc:"This article will explore how re-rendering works in React, why that is an important consideration for React applications, and how the useMemo hook can leve‚Ä¶ ",link:"https://chanhi2000.github.io/bookshelf/digitalocean.com/react-usememo.html",logo:"https://digitalocean.com/_next/static/media/favicon.594d6067.ico",background:"rgba(44,103,246,0.2)"})),null,16)])}const I=h(b,[["render",R]]),H=JSON.parse('{"path":"/digitalocean.com/react-usememo.html","title":"Understanding the React useMemo Hook","lang":"en-US","frontmatter":{"lang":"en-US","title":"Understanding the React useMemo Hook","description":"Article(s) > Understanding the React useMemo Hook","icon":"fa-brands fa-react","category":["Node.js","React.js","Article(s)"],"tag":["blog","digitalocean.com","node","nodejs","node-js","react","reactjs","react-js"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Understanding the React useMemo Hook\\",\\"image\\":[\\"https://digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg\\"],\\"datePublished\\":\\"2019-12-06T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Stephen Hartfield\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/digitalocean.com/react-usememo.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Understanding the React useMemo Hook"}],["meta",{"property":"og:description","content":"Article(s) > Understanding the React useMemo Hook"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg"}],["meta",{"name":"twitter:image:alt","content":"Understanding the React useMemo Hook"}],["meta",{"property":"article:author","content":"Stephen Hartfield"}],["meta",{"property":"article:tag","content":"react-js"}],["meta",{"property":"article:tag","content":"reactjs"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"node-js"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:tag","content":"digitalocean.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2019-12-06T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Understanding the React useMemo Hook"},{"property":"og:description","content":"Understanding the React useMemo Hook"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/digitalocean.com/react-usememo.html"}]],"prev":"/programming/js-react/articles/README.md","date":"2019-12-06T00:00:00.000Z","isOriginal":false,"author":"Stephen Hartfield","cover":"https://digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg"},"git":{},"readingTime":{"minutes":3.72,"words":1117},"filePathRelative":"digitalocean.com/react-usememo.md","copyright":{"author":"Stephen Hartfield"}}');export{I as comp,H as data};
