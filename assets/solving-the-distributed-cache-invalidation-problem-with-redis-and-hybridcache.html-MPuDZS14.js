import{_ as v}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as b,d as s,f as e,b as o,a as r,t as g,n as u,g as d,w as t,e as a,r as l,o as y}from"./app-BItykJLQ.js";const f={},w={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},C={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},I={class:"table-of-contents"},S={href:"https://github.com/dotnet/extensions/issues/5517",target:"_blank",rel:"noopener noreferrer"},R={href:"https://github.com/ZiggyCreatures/FusionCache",target:"_blank",rel:"noopener noreferrer"};function A(k,n){const c=l("VPCard"),i=l("router-link"),m=l("SiteInfo"),p=l("RouteLink"),h=l("VPIcon");return y(),b("div",null,[s("h1",w,[s("a",C,[s("span",null,g(k.$frontmatter.title)+" ê´€ë ¨",1)])]),e(c,u(d({title:"C# > Article(s)",desc:"Article(s)",link:"/programming/cs/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e(c,u(d({title:"Redis > Article(s)",desc:"Article(s)",link:"/data-science/redis/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",I,[s("ul",null,[s("li",null,[e(i,{to:"#the-distributed-caching-dilemma"},{default:t(()=>[...n[0]||(n[0]=[a("The Distributed Caching Dilemma",-1)])]),_:1})]),s("li",null,[e(i,{to:"#the-solution-redis-pub-sub-backplane"},{default:t(()=>[...n[1]||(n[1]=[a("The Solution: Redis Pub/Sub Backplane",-1)])]),_:1})]),s("li",null,[e(i,{to:"#implementing-the-solution"},{default:t(()=>[...n[2]||(n[2]=[a("Implementing the Solution",-1)])]),_:1}),s("ul",null,[s("li",null,[e(i,{to:"#the-background-listener"},{default:t(()=>[...n[3]||(n[3]=[a("The Background Listener",-1)])]),_:1})]),s("li",null,[e(i,{to:"#wiring-it-all-together"},{default:t(()=>[...n[4]||(n[4]=[a("Wiring It All Together",-1)])]),_:1})])])]),s("li",null,[e(i,{to:"#a-better-way-fusioncache"},{default:t(()=>[...n[5]||(n[5]=[a("A Better Way: FusionCache",-1)])]),_:1})]),s("li",null,[e(i,{to:"#summary"},{default:t(()=>[...n[6]||(n[6]=[a("Summary",-1)])]),_:1})])])]),n[34]||(n[34]=s("hr",null,null,-1)),e(m,{name:"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache",desc:"Learn how to solve the distributed cache invalidation problem in .NET 9 by implementing a Redis Pub/Sub backplane to synchronize HybridCache instances across multiple nodes.",url:"https://milanjovanovic.tech/blog/solving-the-distributed-cache-invalidation-problem-with-redis-and-hybridcache",logo:"https://milanjovanovic.tech/profile_favicon.png",preview:"https://milanjovanovic.tech/blog-covers/mnw_177.png"}),n[35]||(n[35]=s("p",null,[a("Distributed systems are great for scalability, but they introduce a whole new class of problems. One of the hardest problems to solve is "),s("strong",null,"cache invalidation"),a(".")],-1)),s("p",null,[n[8]||(n[8]=a("In .NET 9, ",-1)),e(p,{to:"/milanjovanovic.tech/hybrid-cache-in-aspnetcore-new-caching-library.html"},{default:t(()=>[...n[7]||(n[7]=[s("strong",null,[a("Microsoft introduced "),s("code",null,"HybridCache")],-1)])]),_:1}),n[9]||(n[9]=a(` to simplify caching. It's a fantastic library that combines the speed of in-memory caching (L1) with the durability of distributed caching (L2) like Redis. It also handles "cache stampede" protection out of the box.`,-1))]),n[36]||(n[36]=s("p",null,"However, there is a catch.",-1)),n[37]||(n[37]=s("p",null,[a("When you run multiple instances of your application, "),s("code",null,"HybridCache"),a(" doesn't automatically synchronize the local L1 cache across all nodes. If you update data on "),s("strong",null,"Node A"),a(", "),s("strong",null,"Node B"),a(" will continue serving stale data from its in-memory cache until the entry expires.")],-1)),s("p",null,[n[13]||(n[13]=a("While HybridCache is a massive step forward, the lack of a built-in backplane for invalidation is a known limitation. In fact, there is an active discussion on the ",-1)),s("a",S,[n[10]||(n[10]=a("dotnet/extensions GitHub repository (",-1)),e(h,{icon:"iconfont icon-github"}),n[11]||(n[11]=s("code",null,"dotnet/extensions",-1)),n[12]||(n[12]=a(")",-1))]),n[14]||(n[14]=a(" tracking this exact feature request. Until that ships, we have to roll our own solution.",-1))]),n[38]||(n[38]=o('<p>In this week&#39;s newsletter, we&#39;ll explore:</p><ul><li>The distributed caching dilemma</li><li>Why <code>HybridCache</code> doesn&#39;t solve this alone</li><li>Using Redis Pub/Sub as a backplane</li><li>Implementing real-time cache invalidation</li></ul><p>Let&#39;s dive in.</p><hr><h2 id="the-distributed-caching-dilemma" tabindex="-1"><a class="header-anchor" href="#the-distributed-caching-dilemma"><span>The Distributed Caching Dilemma</span></a></h2><p>Let&#39;s imagine a typical production scenario. You have an API running on multiple servers (or pods) behind a load balancer.</p>',6)),s("p",null,[n[16]||(n[16]=a("To improve performance, you introduce ",-1)),e(p,{to:"/milanjovanovic.tech/caching-in-aspnetcore-improving-application-performance.html"},{default:t(()=>[...n[15]||(n[15]=[s("strong",null,"caching",-1)])]),_:1}),n[17]||(n[17]=a(". You want the speed of local memory, so you use ",-1)),n[18]||(n[18]=s("code",null,"HybridCache",-1)),n[19]||(n[19]=a(".",-1))]),n[39]||(n[39]=o('<p>Here is the failure scenario:</p><ol><li><strong>User A</strong> updates their profile on <strong>Server 1</strong>.</li><li><strong>Server 1</strong> updates the database and clears its local cache.</li><li><strong>User A</strong> (or User B) hits <strong>Server 2</strong>.</li><li><strong>Server 2</strong> still holds the <em>old</em> profile data in its local <code>HybridCache</code>.</li><li>The user sees outdated information, since the local cache hasn&#39;t been invalidated.</li></ol><figure><img src="https://milanjovanovic.tech/blogs/mnw_177/hybridcache_out_of_sync_scenario.png?imwidth=3840" alt="A sequence diagram showing two servers with HybridCache out of sync after a user update." tabindex="0" loading="lazy"><figcaption>A sequence diagram showing two servers with HybridCache out of sync after a user update.</figcaption></figure>',3)),r(" TODO: mermaidí™” "),n[40]||(n[40]=o('<p><strong>Why Not Just Shorten the Cache Duration?</strong></p><p>A common &quot;hack&quot; to solve this is to simply reduce the L1 cache duration (TTL). For example, setting the local cache to expire every 10 seconds.</p><p>While this reduces the window of inconsistency, it doesn&#39;t solve the problem. It just masks it.</p><p>This approach introduces two new issues:</p><ul><li><strong>Increased Latency</strong>: You are now forcing your application to reach out to the distributed L2 cache (Redis) or the database much more frequently.</li><li><strong>Lost Efficiency</strong>: The main benefit of L1 caching is avoiding network requests entirely. If you expire data too fast, you lose the performance gain for the majority of your traffic.</li></ul><p>For things like user permissions, feature flags, or pricing, &quot;mostly correct&quot; is often not good enough. You need immediate consistency.</p><hr><h2 id="the-solution-redis-pub-sub-backplane" tabindex="-1"><a class="header-anchor" href="#the-solution-redis-pub-sub-backplane"><span>The Solution: Redis Pub/Sub Backplane</span></a></h2><p>To solve this, we need a <strong>backplane</strong>. It&#39;s a communication channel that connects all our application nodes.</p><p>When a cache entry is removed or updated on one node, we publish a message to the backplane. All other nodes subscribe to this channel and, upon receiving the message, remove the corresponding key from their local cache.</p>',10)),s("p",null,[n[21]||(n[21]=a("Redis is already a popular choice for the L2 cache, so it makes perfect sense to use its ",-1)),e(p,{to:"/milanjovanovic.tech/simple-messaging-in-dotnet-with-redis-pubsub.html"},{default:t(()=>[...n[20]||(n[20]=[s("strong",null,"Pub/Sub feature",-1)])]),_:1}),n[22]||(n[22]=a(" for this signaling mechanism.",-1))]),n[41]||(n[41]=o('<p>It works like this:</p><ol><li><strong>Publisher:</strong> The node that modifies data publishes a <code>cache-invalidation</code> message with the cache key.</li><li><strong>Subscriber:</strong> All nodes listen to this channel.</li><li><strong>Action:</strong> When a message arrives, they call <code>HybridCache.RemoveAsync(key)</code>.</li></ol><figure><img src="https://milanjovanovic.tech/blogs/mnw_177/cache_invalidation_message_fanout.png?imwidth=3840" alt="A sequence diagram showing cache invalidation messages being published and received by multiple servers." tabindex="0" loading="lazy"><figcaption>A sequence diagram showing cache invalidation messages being published and received by multiple servers.</figcaption></figure>',3)),r(" TODO: mermaidí™” "),n[42]||(n[42]=o(`<hr><h2 id="implementing-the-solution" tabindex="-1"><a class="header-anchor" href="#implementing-the-solution"><span>Implementing the Solution</span></a></h2><p>We will need the <code>StackExchange.Redis</code> library to handle the messaging.</p><p>Let&#39;s start by defining a simple service to handle the publishing. This service will be responsible for notifying the rest of the system that a key has changed.</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ICacheInvalidator</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token return-type class-name">Task</span> <span class="token function">InvalidateAsync</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> key<span class="token punctuation">,</span> <span class="token class-name">CancellationToken</span> cancellationToken <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisCacheInvalidator</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">IConnectionMultiplexer</span> connectionMultiplexer<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">ILogger<span class="token punctuation">&lt;</span>RedisCacheInvalidator<span class="token punctuation">&gt;</span></span> logger<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">:</span> ICacheInvalidator</span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token class-name">RedisChannel</span> Channel <span class="token operator">=</span> RedisChannel<span class="token punctuation">.</span><span class="token function">Literal</span><span class="token punctuation">(</span><span class="token string">&quot;cache-invalidation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">InvalidateAsync</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> key<span class="token punctuation">,</span> <span class="token class-name">CancellationToken</span> cancellationToken <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name"><span class="token keyword">var</span></span> subscriber <span class="token operator">=</span> connectionMultiplexer<span class="token punctuation">.</span><span class="token function">GetSubscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">await</span> subscriber<span class="token punctuation">.</span><span class="token function">PublishAsync</span><span class="token punctuation">(</span>Channel<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">RedisValue</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        logger<span class="token punctuation">.</span><span class="token function">LogInformation</span><span class="token punctuation">(</span><span class="token string">&quot;Published invalidation for key: {Key}&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, whenever you update an entity in your Command Handler or Service, you just call <code>ICacheInvalidator.InvalidateAsync</code>.</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UpdateUserProfileHandler</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">AppDbContext</span> dbContext<span class="token punctuation">,</span></span>
<span class="line highlighted">    <span class="token class-name">ICacheInvalidator</span> cacheInvalidator<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">ILogger<span class="token punctuation">&lt;</span>UpdateUserProfileHandler<span class="token punctuation">&gt;</span></span> logger<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">Handle</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> userId<span class="token punctuation">,</span> <span class="token class-name"><span class="token keyword">string</span></span> newName<span class="token punctuation">,</span> <span class="token class-name">CancellationToken</span> ct<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 1. Update the database</span></span>
<span class="line">        <span class="token class-name"><span class="token keyword">var</span></span> user <span class="token operator">=</span> <span class="token keyword">await</span> dbContext<span class="token punctuation">.</span>Users<span class="token punctuation">.</span><span class="token function">FindAsync</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token attribute"><span class="token class-name">userId</span></span><span class="token punctuation">]</span><span class="token punctuation">,</span> ct<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token keyword">is</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">             <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        user<span class="token punctuation">.</span>Name <span class="token operator">=</span> newName<span class="token punctuation">;</span></span>
<span class="line">        <span class="token keyword">await</span> dbContext<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 2. Invalidate the cache (Distributed)</span></span>
<span class="line">        <span class="token class-name"><span class="token keyword">var</span></span> cacheKey <span class="token operator">=</span> <span class="token interpolation-string"><span class="token string">$&quot;user:</span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">userId</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">;</span></span>
<span class="line highlighted">        <span class="token keyword">await</span> cacheInvalidator<span class="token punctuation">.</span><span class="token function">InvalidateAsync</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">,</span> ct<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        logger<span class="token punctuation">.</span><span class="token function">LogInformation</span><span class="token punctuation">(</span><span class="token string">&quot;Updated user and invalidated cache for {UserId}&quot;</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="the-background-listener" tabindex="-1"><a class="header-anchor" href="#the-background-listener"><span>The Background Listener</span></a></h3>`,8)),s("p",null,[n[24]||(n[24]=a("Next, we need a ",-1)),e(p,{to:"/milanjovanovic.tech/running-background-tasks-in-asp-net-core.html"},{default:t(()=>[...n[23]||(n[23]=[s("strong",null,"background service",-1)])]),_:1}),n[25]||(n[25]=a(" that runs on every node. It will subscribe to the Redis channel and evict keys from the local ",-1)),n[26]||(n[26]=s("code",null,"HybridCache",-1)),n[27]||(n[27]=a(".",-1))]),n[43]||(n[43]=o(`<p><strong>A quick note on self-publishing</strong>: Because Redis Pub/Sub broadcasts to everyone subscribed, the node that published the invalidation will also receive the message. In this implementation, we simply remove the key again. It&#39;s redundant but harmless, and it keeps the code simple.</p><p>Note that we are injecting <code>HybridCache</code> directly into our background service. An alternative is using <code>IMemoryCache</code>, since that is the L1 cache inside <code>HybridCache</code>.</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheInvalidationService</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">IConnectionMultiplexer</span> connectionMultiplexer<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">HybridCache</span> hybridCache<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">ILogger<span class="token punctuation">&lt;</span>CacheInvalidationService<span class="token punctuation">&gt;</span></span> logger<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">:</span> BackgroundService</span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">const</span> <span class="token class-name">RedisChannel</span> Channel <span class="token operator">=</span> RedisChannel<span class="token punctuation">.</span><span class="token function">Literal</span><span class="token punctuation">(</span><span class="token string">&quot;cache-invalidation&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ExecuteAsync</span><span class="token punctuation">(</span><span class="token class-name">CancellationToken</span> stoppingToken<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name"><span class="token keyword">var</span></span> subscriber <span class="token operator">=</span> connectionMultiplexer<span class="token punctuation">.</span><span class="token function">GetSubscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">await</span> subscriber<span class="token punctuation">.</span><span class="token function">SubscribeAsync</span><span class="token punctuation">(</span>Channel<span class="token punctuation">,</span> <span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name"><span class="token keyword">string</span></span> key <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            logger<span class="token punctuation">.</span><span class="token function">LogInformation</span><span class="token punctuation">(</span><span class="token string">&quot;Invalidating local cache for: {Key}&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// This removes the item from the local L1 cache</span></span>
<span class="line">            <span class="token class-name"><span class="token keyword">var</span></span> task <span class="token operator">=</span> hybridCache<span class="token punctuation">.</span><span class="token function">RemoveAsync</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> stoppingToken<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>task<span class="token punctuation">.</span>IsCompleted<span class="token punctuation">)</span></span>
<span class="line">            <span class="token punctuation">{</span></span>
<span class="line">                task<span class="token punctuation">.</span><span class="token function">GetAwaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="wiring-it-all-together" tabindex="-1"><a class="header-anchor" href="#wiring-it-all-together"><span>Wiring It All Together</span></a></h3><p>Finally, we need to register these services in our DI container.</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line">builder<span class="token punctuation">.</span>Services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>IConnectionMultiplexer<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span>sp <span class="token operator">=&gt;</span></span>
<span class="line">    ConnectionMultiplexer<span class="token punctuation">.</span><span class="token function">Connect</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;REDIS_CONNECTION_STRING&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Register HybridCache (defaults generally work fine for L1)</span></span>
<span class="line">builder<span class="token punctuation">.</span>Services<span class="token punctuation">.</span><span class="token function">AddHybridCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Register our invalidation services</span></span>
<span class="line">builder<span class="token punctuation">.</span>Services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>ICacheInvalidator<span class="token punctuation">,</span> RedisCacheInvalidator<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">builder<span class="token punctuation">.</span>Services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddHostedService</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>CacheInvalidationService<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, when <strong>Node A</strong> calls <code>InvalidateAsync(&quot;user:123&quot;)</code>, Redis pushes that message to <strong>Node B</strong>, <strong>Node C</strong>, and so on. They all trigger <code>hybridCache.RemoveAsync(&quot;user:123&quot;)</code>, ensuring the next request fetches fresh data from the source (or the shared L2).</p><hr><h2 id="a-better-way-fusioncache" tabindex="-1"><a class="header-anchor" href="#a-better-way-fusioncache"><span>A Better Way: FusionCache</span></a></h2>`,9)),s("p",null,[n[32]||(n[32]=a("If building your own backplane feels like reinventing the wheel, you should look at ",-1)),s("a",R,[n[28]||(n[28]=s("strong",null,"FusionCache",-1)),n[29]||(n[29]=a(" (",-1)),e(h,{icon:"iconfont icon-github"}),n[30]||(n[30]=s("code",null,"ZiggyCreatures/FusionCache",-1)),n[31]||(n[31]=a(")",-1))]),n[33]||(n[33]=a(".",-1))]),n[44]||(n[44]=o(`<p>FusionCache is a mature, battle-tested library that has solved this exact problem for years. It has a built-in backplane feature that automatically handles the Pub/Sub messaging for you.</p><p>Even better, FusionCache recently added an implementation of the HybridCache abstract class. This means you can swap it in without changing much of your existing code.</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token comment">// Using FusionCache&#39;s implementation of HybridCache</span></span>
<span class="line">builder<span class="token punctuation">.</span>Services<span class="token punctuation">.</span><span class="token function">AddFusionCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">WithBackplane</span><span class="token punctuation">(</span></span>
<span class="line">        <span class="token keyword">new</span> <span class="token constructor-invocation class-name">RedisBackplane</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">RedisBackplaneOptions</span> <span class="token punctuation">{</span> Configuration <span class="token operator">=</span> <span class="token string">&quot;&lt;REDIS_CONNECTION_STRING&gt;&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">AsHybridCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p><code>HybridCache</code> is a powerful addition to the .NET ecosystem, effectively merging the benefits of <code>IMemoryCache</code> and <code>IDistributedCache</code>. However, for multi-node setups requiring high consistency, you still need a mechanism to synchronize the local caches.</p><p>Redis Pub/Sub offers a lightweight, effective solution to this problem.</p><p>By implementing a simple &quot;bus&quot; for invalidation messages, you get the best of both worlds: the extreme performance of local caching and the data consistency of a distributed system.</p>`,8)),r(" TODO: add ARTICLE CARD "),e(c,u(d({title:"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache",desc:"Learn how to solve the distributed cache invalidation problem in .NET 9 by implementing a Redis Pub/Sub backplane to synchronize HybridCache instances across multiple nodes.",link:"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/solving-the-distributed-cache-invalidation-problem-with-redis-and-hybridcache.html",logo:"https://milanjovanovic.tech/profile_favicon.png",background:"rgba(79,70,229,0.2)"})),null,16)])}const H=v(f,[["render",A]]),q=JSON.parse('{"path":"/milanjovanovic.tech/solving-the-distributed-cache-invalidation-problem-with-redis-and-hybridcache.html","title":"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache","lang":"en-US","frontmatter":{"lang":"en-US","title":"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache","description":"Article(s) > Solving the Distributed Cache Invalidation Problem with Redis and HybridCache","icon":"iconfont icon-csharp","category":["C#","DotNet","Data Science","Redis","Article(s)"],"tag":["blog","milanjovanovic.tech","cs","c#","csharp","dotnet","data-science","redis"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache\\",\\"image\\":[\\"https://milanjovanovic.tech/blogs/mnw_177/hybridcache_out_of_sync_scenario.png?imwidth=3840\\",\\"https://milanjovanovic.tech/blogs/mnw_177/cache_invalidation_message_fanout.png?imwidth=3840\\"],\\"datePublished\\":\\"2026-01-17T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Milan JovanoviÄ‡\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/solving-the-distributed-cache-invalidation-problem-with-redis-and-hybridcache.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache"}],["meta",{"property":"og:description","content":"Article(s) > Solving the Distributed Cache Invalidation Problem with Redis and HybridCache"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://milanjovanovic.tech/blog-covers/mnw_177.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://milanjovanovic.tech/blog-covers/mnw_177.png"}],["meta",{"name":"twitter:image:alt","content":"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache"}],["meta",{"property":"article:author","content":"Milan JovanoviÄ‡"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:tag","content":"data-science"}],["meta",{"property":"article:tag","content":"dotnet"}],["meta",{"property":"article:tag","content":"csharp"}],["meta",{"property":"article:tag","content":"c#"}],["meta",{"property":"article:tag","content":"cs"}],["meta",{"property":"article:tag","content":"milanjovanovic.tech"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2026-01-17T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Solving the Distributed Cache Invalidation Problem with Redis and HybridCache"},{"property":"og:description","content":"Solving the Distributed Cache Invalidation Problem with Redis and HybridCache"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/solving-the-distributed-cache-invalidation-problem-with-redis-and-hybridcache.html"}]],"prev":"/programming/cs/articles/README.md","date":"2026-01-17T00:00:00.000Z","isOriginal":false,"author":"Milan JovanoviÄ‡","cover":"https://milanjovanovic.tech/blog-covers/mnw_177.png"},"git":{},"readingTime":{"minutes":5.05,"words":1515},"filePathRelative":"milanjovanovic.tech/solving-the-distributed-cache-invalidation-problem-with-redis-and-hybridcache.md","copyright":{"author":"Milan JovanoviÄ‡"}}');export{H as comp,q as data};
