import{_ as k}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as m,d as n,f as e,b as l,t as y,n as c,g as r,w as p,e as a,r as u,o as h}from"./app-BVguHYKu.js";const v={},f={id:"frontmatter-title-관련",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-관련"},b={class:"table-of-contents"},w={href:"https://en.cppreference.com/w/cpp/utility/any",target:"_blank",rel:"noopener noreferrer"},x={href:"https://en.cppreference.com/w/cpp/utility/functional/function",target:"_blank",rel:"noopener noreferrer"},q={href:"https://www.boost.org/doc/libs/1_84_0/doc/html/any.html",target:"_blank",rel:"noopener noreferrer"},S={href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",target:"_blank",rel:"noopener noreferrer"},T={href:"https://en.wikipedia.org/wiki/Expression_templates",target:"_blank",rel:"noopener noreferrer"};function I(d,s){const i=u("VPCard"),t=u("router-link"),o=u("VPIcon");return h(),m("div",null,[n("h1",f,[n("a",g,[n("span",null,y(d.$frontmatter.title)+" 관련",1)])]),e(i,c(r({title:"Swift > Article(s)",desc:"Article(s)",link:"/programming/swift/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e(i,c(r({title:"C++ > Article(s)",desc:"Article(s)",link:"/programming/cpp/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",b,[n("ul",null,[n("li",null,[e(t,{to:"#the-basics-of-type-erasure"},{default:p(()=>s[0]||(s[0]=[a("The basics of type erasure")])),_:1,__:[0]})]),n("li",null,[e(t,{to:"#dynamic-casting"},{default:p(()=>s[1]||(s[1]=[a("Dynamic casting")])),_:1,__:[1]})]),n("li",null,[e(t,{to:"#metatypes"},{default:p(()=>s[2]||(s[2]=[a("Metatypes")])),_:1,__:[2]}),n("ul",null,[n("li",null,[e(t,{to:"#class-metatypes"},{default:p(()=>s[3]||(s[3]=[a("Class metatypes")])),_:1,__:[3]})]),n("li",null,[e(t,{to:"#any-metatypes"},{default:p(()=>s[4]||(s[4]=[a("any metatypes")])),_:1,__:[4]})]),n("li",null,[e(t,{to:"#explicitly-specified-generic-function-arguments"},{default:p(()=>s[5]||(s[5]=[a("Explicitly-specified generic function arguments")])),_:1,__:[5]})])])]),n("li",null,[e(t,{to:"#associated-types"},{default:p(()=>s[6]||(s[6]=[a("Associated types")])),_:1,__:[6]}),n("ul",null,[n("li",null,[e(t,{to:"#erasure-of-associated-types"},{default:p(()=>s[7]||(s[7]=[a("Erasure of associated types")])),_:1,__:[7]})]),n("li",null,[e(t,{to:"#equality-of-types"},{default:p(()=>s[8]||(s[8]=[a("Equality of types")])),_:1,__:[8]})]),n("li",null,[e(t,{to:"#opening-any-types"},{default:p(()=>s[9]||(s[9]=[a("Opening any types")])),_:1,__:[9]})]),n("li",null,[e(t,{to:"#primary-associated-types"},{default:p(()=>s[10]||(s[10]=[a("Primary associated types")])),_:1,__:[10]})])])]),n("li",null,[e(t,{to:"#when-to-type-erase"},{default:p(()=>s[11]||(s[11]=[a("When to type-erase?")])),_:1,__:[11]})]),n("li",null,[e(t,{to:"#implementation-hiding-with-opaque-types"},{default:p(()=>s[12]||(s[12]=[a("Implementation hiding with opaque types")])),_:1,__:[12]}),n("ul",null,[n("li",null,[e(t,{to:"#some-vs-any"},{default:p(()=>s[13]||(s[13]=[a("some vs. any")])),_:1,__:[13]})]),n("li",null,[e(t,{to:"#hiding-complicated-result-types"},{default:p(()=>s[14]||(s[14]=[a("Hiding complicated result types")])),_:1,__:[14]})])])]),n("li",null,[e(t,{to:"#wrap-up"},{default:p(()=>s[15]||(s[15]=[a("Wrap up")])),_:1,__:[15]})])])]),s[58]||(s[58]=n("hr",null,null,-1)),e(i,c(r({title:"Swift for C++ Practitioners, Part 5: Type erasure & metatypes | Doug's Compiler Corner",desc:"Swift for C++ Practitioners, Part 5: Type erasure & metatypes",link:"https://www.douggregor.net/posts/swift-for-cxx-practitioners-type-erasure/",background:"rgba(22,22,22,0.2)"})),null,16),n("p",null,[s[18]||(s[18]=a("What do you do in C++ when you want to support different types, but don't want to have one template instantiation per type? Yes, you can introduce a class hierarchy with virtual functions, but more often a better answer is to use ")),s[19]||(s[19]=n("em",null,"type erasure",-1)),s[20]||(s[20]=a(". Type erasure is a mechanism for ")),s[21]||(s[21]=n("em",null,"runtime polymorphism",-1)),s[22]||(s[22]=a(", allowing you to provide different types at runtime while using the same code expressed with a single, concrete type. The C++ standard library contains two type-erased utility types: ")),n("a",w,[e(o,{icon:"iconfont icon-cpp"}),s[16]||(s[16]=n("code",null,"std::any",-1))]),s[23]||(s[23]=a(" and ")),n("a",x,[e(o,{icon:"iconfont icon-cpp"}),s[17]||(s[17]=n("code",null,"std::function",-1))]),s[24]||(s[24]=a(". In both cases, you can have a concrete value whose underlying type can change:"))]),s[59]||(s[59]=l(`<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">std<span class="token double-colon punctuation">::</span>any a <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>              <span class="token comment">// okay, stores an int</span></span>
<span class="line">a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// now it stores a std::string!</span></span>
<span class="line"></span>
<span class="line">std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> op <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// okay, it adds integers</span></span>
<span class="line">op <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span>                               <span class="token comment">// now it multiplies them!</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),n("p",null,[s[26]||(s[26]=a("Type erasure in C++ has been around for a long time, and it's a useful technique. ")),n("a",q,[e(o,{icon:"fas fa-globe"}),s[25]||(s[25]=a("Boost.Any"))]),s[27]||(s[27]=a(" popularized the idea, and now there are numerous blog posts describing implementation techniques and C++ libraries implementing them. In Swift, it's part of the language, and you can type-erase any protocol using the keyword ")),s[28]||(s[28]=n("code",null,"any",-1)),s[29]||(s[29]=a(". In this post, we're going to dive into how Swift handles type erasure, and explore related features like ")),s[30]||(s[30]=n("em",null,"metatypes",-1)),s[31]||(s[31]=a(" and ")),s[32]||(s[32]=n("em",null,"opaque types",-1)),s[33]||(s[33]=a("."))]),s[60]||(s[60]=l(`<hr><h2 id="the-basics-of-type-erasure" tabindex="-1"><a class="header-anchor" href="#the-basics-of-type-erasure"><span>The basics of type erasure</span></a></h2><p>For example, let&#39;s bring back that the <code>Quantifiable</code> protocol from the last post. It looked like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Quantifiable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">func</span> <span class="token function-definition function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Double</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>One can conform types to <code>Quantifiable</code> and write generic algorithms using <code>Quantifiable</code> as a constraint. If we want to use runtime polymorphism to store a value of any <code>Quantifiable</code> type, we can do so with <code>any Quantifiable</code> like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> q<span class="token punctuation">:</span> any <span class="token class-name">Quantifiable</span> <span class="token operator">=</span> <span class="token number">1</span>   <span class="token comment">// okay, Int conforms to Quantifiable</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment">// can use the members of the Quantifiable protocol</span></span>
<span class="line"></span>
<span class="line">q <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span>                   <span class="token comment">// okay, String conforms to Quantifiable</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You can think of the type of <code>q</code> as being &quot;anything that is <code>Quantifiable</code>&quot;: the actual type isn&#39;t known until runtime, and can change by reassigning the variable to another value with a different type. One can compose multiple protocols together using the <code>&amp;</code> sign. For example, a value of type <code>any Quantifiable &amp; Describable</code> can hold a value of any type that conforms to both <code>Quantifiable</code> and <code>Describable</code>, and you can use any operations that are available to a <code>Describable</code> type or <code>Quantifiable</code> type:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> dq<span class="token punctuation">:</span> any <span class="token class-name">Quantifiable</span> <span class="token operator">&amp;</span> <span class="token class-name">Describable</span> <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line">dq<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">dq<span class="token punctuation">.</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The Swift equivalent to <code>std::any</code> is called, simply, <code>Any</code>: it is effectively an <code>any</code> type with no protocols listed, so it can store a value of any type in it. Now, just like with <code>std::any</code>, you can&#39;t do much with a value of type <code>Any</code> other than copy it around, because there are aren&#39;t many operations that work on all types.</p><hr><h2 id="dynamic-casting" tabindex="-1"><a class="header-anchor" href="#dynamic-casting"><span>Dynamic casting</span></a></h2><p>One thing you can do with values of <code>Any</code> type is to perform a runtime check of the actual stored type. This is accomplished with the same <code>as?</code> cast we introduced for downcasting to a subclass. For example, here&#39;s a function that checks whether a value of type <code>Any</code> is actually an <code>Int</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">maybeIntValue</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token keyword">let</span> integer <span class="token operator">=</span> value <span class="token keyword">as</span><span class="token operator">?</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> integer</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">return</span> <span class="token nil constant">nil</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The same works for <code>switch</code> statements, where a <code>case</code> can use the <code>as</code> operator to apply only when a dynamic cast to the type succeeds. Here&#39;s a <code>switch</code> to identify a number of concrete types:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">whatAmI</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">switch</span> value <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token keyword">let</span> bool <span class="token keyword">as</span> <span class="token class-name">Bool</span><span class="token punctuation">:</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Bool </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">bool</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token keyword">let</span> integer <span class="token keyword">as</span> <span class="token class-name">Int</span><span class="token punctuation">:</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Integer </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">integer</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token keyword">let</span> double <span class="token keyword">as</span> <span class="token class-name">Double</span><span class="token punctuation">:</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Double </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">double</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">case</span> <span class="token keyword">let</span> string <span class="token keyword">as</span> <span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;String </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">string</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;I don&#39;t know what this is&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Such a <code>switch</code> must have a <code>default</code> clause, because there&#39;s no way to enumerate every type. The Swift compiler will produce an error <code>switch must be exhaustive</code> if you forget. One particularly important aspect of dynamic casting is that you can cast to an <code>any</code> type, which lets you discover the capabilities of a value at runtime. For example, one can cast to <code>any Quantifiable</code> to determine whether a value conforms to <code>Quantifiable</code>.</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> value<span class="token punctuation">:</span> <span class="token keyword">Any</span> <span class="token operator">=</span> <span class="token number">1</span></span>
<span class="line"><span class="token keyword">if</span> <span class="token keyword">let</span> q <span class="token operator">=</span> value <span class="token keyword">as</span><span class="token operator">?</span> any <span class="token class-name">Quantifiable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;Cost is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">q<span class="token punctuation">.</span><span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Dynamic casting allows one to rediscover type information that has been removed by type erasure. It&#39;s common in very dynamic programs where values are dynamically produced in one place, such as via a global registry or deserialization, and consumed elsewhere. To build something like that, which dynamically creates values of potentially unknown type, we need one more Swift feature: metatypes.</p><hr><h2 id="metatypes" tabindex="-1"><a class="header-anchor" href="#metatypes"><span>Metatypes</span></a></h2><p>In the prior post on generics, I noted that Swift doesn&#39;t have an equivalent to the <code>decltype</code> type in C++. Swift does, however, have a function named <code>type(of:)</code>, which produces the type of its argument. However, it&#39;s not producing a type, but a value representing the type, i.e., a <em>metatype</em>. Metatypes in Swift are spelled with the <code>.Type</code> suffix, so if we have a type <code>Point</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> x<span class="token punctuation">:</span> <span class="token class-name">Double</span></span>
<span class="line">  <span class="token keyword">var</span> y<span class="token punctuation">:</span> <span class="token class-name">Double</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">var</span> origin<span class="token punctuation">:</span> <span class="token class-name">Point</span> <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The metatype of <code>Point</code> has the type <code>Point.Type</code>. One can form a value of this type with the expression <code>Point.self</code>.</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> pointType<span class="token punctuation">:</span> <span class="token class-name">Point</span><span class="token punctuation">.</span><span class="token keyword">Type</span> <span class="token operator">=</span> <span class="token class-name">Point</span><span class="token punctuation">.</span><span class="token keyword">self</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>What can you do with a metatype? For one thing, you can access static methods and properties, or call an initializer of that type to produce a new value, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> point <span class="token operator">=</span> pointType<span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">let</span> origin <span class="token operator">=</span> pointType<span class="token punctuation">.</span>origin</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Technically, when you write <code>Point(x: 0.0, y: 0.0)</code>, you&#39;re using syntactic sugar for <code>PointType.self.init(x: 0.0, y: 0.0)</code>. The <code>type(of:)</code> operation has this generic signature:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">type</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>of value<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">T</span><span class="token punctuation">.</span><span class="token keyword">Type</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>So if we pass an instance of <code>Point</code> to <code>type(of:)</code>, we get back a <code>Point.Type</code> instance.</p><h3 id="class-metatypes" tabindex="-1"><a class="header-anchor" href="#class-metatypes"><span>Class metatypes</span></a></h3><p>Metatypes of structs and enums, by themselves, aren&#39;t very interesting, because you could generally just refer to the type. With classes, metatypes become a lot more interesting because an instance of class type could actually store one of its subclasses. Let&#39;s build a small class hierarchy:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">required</span> <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">class</span> <span class="token keyword">var</span> serializedTypeName<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token string-literal"><span class="token string">&quot;PERSON&quot;</span></span><span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Programmer</span><span class="token punctuation">:</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> favoriteLanguage<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token nil constant">nil</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">required</span> <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> name<span class="token punctuation">,</span> favoriteLanguage<span class="token punctuation">:</span> <span class="token nil constant">nil</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> favoriteLanguage<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">self</span><span class="token punctuation">.</span>favoriteLanguage <span class="token operator">=</span> favoriteLanguage</span>
<span class="line">    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> name<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">class</span> <span class="token keyword">var</span> serializedTypeName<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token string-literal"><span class="token string">&quot;PROGRAMMER&quot;</span></span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Please ignore the <code>required</code> and <code>class var</code> for the moment---we&#39;ll get there shortly. First, let&#39;s imagine that we have a <code>person</code> instance, and we ask for its type via <code>type(of: person)</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> person<span class="token punctuation">:</span> <span class="token class-name">Person</span> <span class="token operator">=</span> <span class="token comment">/*build some kind of person */</span></span>
<span class="line"><span class="token keyword">var</span> personType<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">Type</span> <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> person<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Statically, the type of <code>person</code> can only be expressed as <code>Person.Type</code>. But dynamically, the <code>person</code> instance can store a <code>Person</code> object, or a <code>Programmer</code> object, or any instance of any other subclass of <code>Person</code>. The <code>type(of:)</code> operation produces a value of (static) type <code>Person.Type</code>, which dynamically could be <code>Person.self</code>, <code>Programmer.self</code>, or any other subclass&#39;s metatype. It&#39;s obvious, and a little mind-bending, but then it&#39;s obvious again. What can we do with a metatype? For one, we can use <code>class</code> methods and properties, which are the overridable equivalent of <code>static</code> methods and properties. (Within a class, <code>static</code> is a synonym for <code>class final</code>). For example, the following:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token function">print</span><span class="token punctuation">(</span>personType<span class="token punctuation">.</span>serializecClassName<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>If <code>person</code> dynamically stores a <code>Person</code> instance, the metatype in <code>personType</code> will be <code>Person.self</code>, and it&#39;ll print <code>PERSON</code>. If <code>person</code> dynamically stores a <code>Programmer</code> instance, the metatype in <code>personType</code> will be <code>Programmer.self</code> and it&#39;ll print <code>PROGRAMMER</code>. We can also initialize a new object by calling <code>personType.init(name:)</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> newPerson <span class="token operator">=</span> personType<span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&quot;Doug&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>and <code>newPerson</code> will have the same type as <code>person</code>. Note that this needs the initializer to be marked <code>required</code>: a <code>required</code> initializer must be implemented by every subclass. They&#39;re also needed to satisfy <code>init</code> requirements of a protocol to which the class conforms. For example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">InitByName</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">Person</span><span class="token punctuation">:</span> <span class="token class-name">InitByName</span> <span class="token punctuation">{</span> </span>
<span class="line">  <span class="token comment">// okay, because init(name:) is a required initializer</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,40)),n("p",null,[s[35]||(s[35]=a("Why do we need ")),s[36]||(s[36]=n("code",null,"required",-1)),s[37]||(s[37]=a("? Making ")),s[38]||(s[38]=n("code",null,"Person",-1)),s[39]||(s[39]=a(" conform to ")),s[40]||(s[40]=n("code",null,"InitByName",-1)),s[41]||(s[41]=a(" implies that every subclass of ")),s[42]||(s[42]=n("code",null,"Person",-1)),s[43]||(s[43]=a(" also conforms to ")),s[44]||(s[44]=n("code",null,"InitByName",-1)),s[45]||(s[45]=a(", because one should always be able to substitute an instance of a subclass where the superclass was expected (this is the ")),n("a",S,[e(o,{icon:"fa-brands fa-wikipedia-w"}),s[34]||(s[34]=a("Liskov Substitution Principle"))]),s[46]||(s[46]=a("). That means you need to be able to create an instance of any subclass by calling ")),s[47]||(s[47]=n("code",null,"init(name:)",-1)),s[48]||(s[48]=a(". Making an initializer ")),s[49]||(s[49]=n("code",null,"required",-1)),s[50]||(s[50]=a(" ensures that all subclasses (and subclasses of subclasses, and so on) implement it. At this point, we could build a simple registry mapping from the serialized class names to actual ")),s[51]||(s[51]=n("code",null,"Person",-1)),s[52]||(s[52]=a(" types:"))]),s[61]||(s[61]=l(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> knownPersonTypes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>type<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">addPersonType</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> personType<span class="token punctuation">:</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  knownPersonTypes<span class="token punctuation">[</span>personType<span class="token punctuation">.</span>serializedTypeName<span class="token punctuation">]</span> <span class="token operator">=</span> personType</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token function">addPersonType</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token function">addPersonType</span><span class="token punctuation">(</span><span class="token class-name">Programmer</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Then we can build a <code>Person</code> instance based on the serialized name and the <code>name</code> field:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">instantiatePerson</span><span class="token punctuation">(</span>className<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Person</span><span class="token operator">?</span> <span class="token punctuation">{</span></span>
<span class="line">  knownPersonTypes<span class="token punctuation">[</span>className<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> name<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="any-metatypes" tabindex="-1"><a class="header-anchor" href="#any-metatypes"><span><code>any</code> metatypes</span></a></h3><p>Class metatypes opened up the ability to use dynamic dispatch via subclassing, but there&#39;s a more general way: metatypes work with <code>any</code>, so we can express the &quot;type of a some type that conforms to a protocol.&quot; For example, a value of type <code>any InitByName.Type</code> stores the metatype for some type that conforms to <code>InitByName</code>. That can be <code>Person</code> (or any of its subclasses), or some <code>struct</code> or <code>enum</code> that conforms to the protocol:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">struct</span> <span class="token class-name">Fruit</span><span class="token punctuation">:</span> <span class="token class-name">InitByName</span> <span class="token punctuation">{</span></span>
<span class="line">	<span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">var</span> serializedTypeName<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token string-literal"><span class="token string">&quot;FRUIT&quot;</span></span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The same registry code from before works just as well when we generalize <code>Person</code> to <code>any InitByName</code>. Here it is:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> knownTypes<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> any <span class="token class-name">InitByName</span><span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">addInitByNameType</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> type<span class="token punctuation">:</span> any <span class="token class-name">InitByName</span><span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  knownTypes<span class="token punctuation">[</span>type<span class="token punctuation">.</span>serializedTypeName<span class="token punctuation">]</span> <span class="token operator">=</span> type</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token function-definition function">instantiate</span><span class="token punctuation">(</span>typeName<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>any <span class="token class-name">InitByName</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token punctuation">{</span></span>
<span class="line">  knownTypes<span class="token punctuation">[</span>typeName<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> name<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Note how the result of calling the initializer of a value of type <code>any InitByName.Type</code> is a value of type <code>any InitByName</code>. We don&#39;t know what metatype will be stored in the <code>any InitByName.Type</code> (although we could check with <code>as?</code> or a <code>case</code>), but we do know that its instance will conform to <code>InitByName</code>, so it&#39;s represented as <code>any InitByName</code>.</p><h3 id="explicitly-specified-generic-function-arguments" tabindex="-1"><a class="header-anchor" href="#explicitly-specified-generic-function-arguments"><span>Explicitly-specified generic function arguments</span></a></h3><p>C++ allows you to explicitly specify the template arguments for a function template. C++ libraries tend to make use of this feature when a type should be explicitly specified by the caller. For example, imagine a &quot;numeric cast&quot; template like this:</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">To</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">From</span><span class="token operator">&gt;</span></span>
<span class="line">To <span class="token function">numeric_cast</span><span class="token punctuation">(</span><span class="token keyword">const</span> From<span class="token operator">&amp;</span> from<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>In C++, the template argument for <code>To</code> can&#39;t be inferred by a normal call like <code>numeric_cast(d)</code>, so we explicitly specify the type at the call site, e.g.,:</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">17.0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">numeric_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, Swift is actually a bit different here. We can write essentially the same generic function:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">numericCast</span><span class="token operator">&lt;</span><span class="token class-name">To</span><span class="token punctuation">:</span> <span class="token class-name">Numeric</span><span class="token punctuation">,</span> <span class="token class-name">From</span><span class="token punctuation">:</span> <span class="token class-name">Numeric</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">From</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">To</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>but it&#39;s going to behave differently at the call site. Swift&#39;s type inference uses more contextual cues that C++&#39;s template argument deduction, so a call like this will work fine in Swift:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token function">numericCast</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>If you don&#39;t have type context to infer the type, i.e., if you just write:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token function">numericCast</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>  <span class="token comment">// type inference fails to find a \`To\` type</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>then type inference will fail to infer a <code>To</code> type. An <code>as</code> coercion can fix this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token function">numericCast</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token class-name">Int</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Given that type inference usually figures out the types for us, and Swift already has the general notion of using <code>as</code> to provide type information when it doesn&#39;t, Swift never got the ability to explicitly provide generic arguments for functions. <code>numericCast&lt;Int&gt;(d)</code> is an error in Swift.</p><p>But what if you <em>want</em> to require the type to be specified at the call site, and not rely entirely on type inference? Turns out that you can use metatypes, and the result is really nice:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">numericCast</span><span class="token operator">&lt;</span><span class="token class-name">From</span><span class="token punctuation">:</span> <span class="token class-name">Numeric</span><span class="token punctuation">,</span> <span class="token class-name">To</span><span class="token punctuation">:</span> <span class="token class-name">Numeric</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> value<span class="token punctuation">:</span> <span class="token class-name">From</span><span class="token punctuation">,</span> to type<span class="token punctuation">:</span> <span class="token class-name">To</span><span class="token punctuation">.</span><span class="token keyword">Type</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">To</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Here, we&#39;ve added a <code>to</code> parameter of the metatype of <code>To</code>. The user specifies the metatype of the type to convert to at the call site, like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">numericCast</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The type of <code>To</code> is inferred from the argument. It also reads really nicely: &quot;numeric cast <code>d</code> to <code>Int</code>&quot;.</p><p>Will Swift eventually gain the ability to explicitly specify the generic arguments of a generic function? Maybe someday, but not having this feature led to the discovery of the metatype-based solution above, and I think the end result is better for readability.</p><hr><h2 id="associated-types" tabindex="-1"><a class="header-anchor" href="#associated-types"><span>Associated types</span></a></h2><p>Associated types have some interesting interactions with type erasure. Let&#39;s explore those now, bringing back the <code>Collection</code> protocol from the prior post on Swift generics to develop these ideas further:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Collection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">Value</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">Index</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">var</span> startIndex<span class="token punctuation">:</span> <span class="token class-name">Index</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">var</span> endIndex<span class="token punctuation">:</span> <span class="token class-name">Index</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">func</span> <span class="token function-definition function">index</span><span class="token punctuation">(</span>after index<span class="token punctuation">:</span> <span class="token class-name">Index</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Index</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">subscript</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token class-name">Index</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Value</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> first<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token operator">?</span> <span class="token punctuation">{</span> </span>
<span class="line">    startIndex <span class="token operator">==</span> endIndex <span class="token operator">?</span> <span class="token nil constant">nil</span> <span class="token punctuation">:</span> <span class="token keyword">self</span><span class="token punctuation">[</span>startIndex<span class="token punctuation">]</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="erasure-of-associated-types" tabindex="-1"><a class="header-anchor" href="#erasure-of-associated-types"><span>Erasure of associated types</span></a></h3><p>Let&#39;s say we have a value <code>c</code> of type <code>any Collection</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> c<span class="token punctuation">:</span> any <span class="token class-name">Collection</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>At runtime, <code>c</code> could store an <code>[Int]</code> or a <code>[String: (any InitByName).Type]</code>, or a <code>Set&lt;String&gt;</code> or any other collection. If we ask for the <code>first</code> value in <code>c</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> f <span class="token operator">=</span> c<span class="token punctuation">.</span>first</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>what type should we expect to get? We know it&#39;s the <code>Value</code> type of the underlying collection, but since we don&#39;t know what the collection itself is, we don&#39;t know the <code>Value</code> type of it, either. Therefore, the type of the <code>first</code> is also type-erased by replacing each occurrence of an associated type (here, it&#39;s <code>Value</code>) with an <code>any</code> type based on the constraints placed on that associated type. There are no constraints on <code>Value</code>, so the type of <code>first</code> (<code>Value?</code>) is type-erased to <code>Any?</code>. For an associated type like <code>Index</code> that has constraints, we&#39;ll get a more interesting resulting type: <code>Index</code> will be type-erased to <code>any Equatable</code>, so if we grab the start and end index of our collection, we&#39;ll get <code>any Equatable</code> values:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> si <span class="token operator">=</span> c<span class="token punctuation">.</span>startIndex   <span class="token comment">// inferred type is &#39;any Equatable&#39;</span></span>
<span class="line"><span class="token keyword">let</span> ei <span class="token operator">=</span> c<span class="token punctuation">.</span>endIndex     <span class="token comment">// inferred type is &#39;any Equatable&#39;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>The type erasure for associated types happens automatically, and generally means that once you&#39;ve erased some type information, that type information stays erased until you do something explicit to bring type information back. Most of the time, that&#39;s fine, but it can be surprising.</p><h3 id="equality-of-types" tabindex="-1"><a class="header-anchor" href="#equality-of-types"><span>Equality of types</span></a></h3><p>Now that we have the start and end indices, it&#39;s completely reasonable that we&#39;d want to be able to loop over the elements of our collection <code>c</code>, perhaps like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">while</span> si <span class="token operator">!=</span> ei <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">let</span> element <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token keyword">subscript</span><span class="token punctuation">[</span>si<span class="token punctuation">]</span></span>
<span class="line">  <span class="token function">doSomething</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></span>
<span class="line">  si <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>after<span class="token punctuation">:</span> si<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, this can&#39;t work. Let&#39;s focus on the <code>si != ei</code>, which is trying to use the <code>!=</code> operator from the <code>Equatable</code> protocol:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Equatable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">!=</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Remember that <code>Self</code> is the actual, concrete type that conforms to the protocol <code>Equatable</code>. When we write <code>si != ei</code>, where each of <code>si</code> and <code>ei</code> are of type <code>any Equatable</code>, the actual type for <code>Self</code> is stored inside that <code>any Equatable</code> and can vary at runtime. Here in the call, there&#39;s no static guarantee that both <code>si</code> and <code>ei</code> have the same underlying type as run-time, so the compiler has to reject the call. Otherwise, we could end up trying to compare an <code>Int</code> to a <code>String</code>, but there&#39;s no operator for that.</p><h3 id="opening-any-types" tabindex="-1"><a class="header-anchor" href="#opening-any-types"><span>Opening <code>any</code> types</span></a></h3><p>To make this work, we&#39;re going to have to <em>dynamically</em> check that both sides have the same type, <em>then</em> use their operator. Let&#39;s build a function to check equality of two distinct <code>Equatable</code> types. To do so, we&#39;re going to use generics:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">isEqual</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span><span class="token punctuation">,</span> <span class="token class-name">U</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> lhs<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">U</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token keyword">let</span> rhsAsT <span class="token operator">=</span> rhs <span class="token keyword">as</span><span class="token operator">?</span> <span class="token class-name">T</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> lhs <span class="token operator">==</span> rhsAsT</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">if</span> <span class="token keyword">let</span> lhsAsU <span class="token operator">=</span> lhs <span class="token keyword">as</span><span class="token operator">?</span> <span class="token class-name">U</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> lhsAsU <span class="token operator">==</span> rhs</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">return</span> <span class="token boolean">false</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The types <code>T</code> and <code>U</code> could be different, so we first try to cast <code>rhs</code> to a <code>T</code>: if that succeeds, we can compare the values as <code>T</code> instances because <code>T</code> is <code>Equatable</code>. We also try in the other direction, to compare as <code>U</code> instances (via <code>U: Equatable</code>). If both fail, the types are incomparable, and we return <code>false</code>. Now, our loop condition can be</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">while</span> <span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>si<span class="token punctuation">,</span> ei<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>But how does that <em>work</em>? We passed two <code>any Equatable</code> values (which are firmly runtime-polymorphic) into a generic function (which is statically-polymorphic), and it... just... works. This is what I meant be moving between static and dynamic polymorphism in Swift.</p><p>What&#39;s happening under the hood is called &quot;opening&quot; the <code>any</code> type. Effectively, the compiler is reaching in to each <code>any Equatable</code> value to pull out the concrete type, and binding the appropriate generic parameter (<code>T</code> or <code>U</code>) to that concrete type. Swift can do this due to separate compilation of generics, so the <code>isEqual</code> function implementation can work with types that aren&#39;t known until runtime.</p><p>We could write a similar function to perform the subscript of the collection, but it would be a lot easier if we turned the whole loop into a generic function on the collection. Say, a for-each operation:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">forEach</span><span class="token operator">&lt;</span><span class="token class-name">C</span><span class="token punctuation">:</span> <span class="token class-name">Collection</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> c<span class="token punctuation">:</span> <span class="token class-name">C</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">.</span><span class="token class-name">Value</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> si <span class="token operator">=</span> c<span class="token punctuation">.</span>startIndex</span>
<span class="line">  <span class="token keyword">let</span> ei <span class="token operator">=</span> c<span class="token punctuation">.</span>endIndex</span>
<span class="line">  <span class="token keyword">while</span> si <span class="token operator">!=</span> ei <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">let</span> current <span class="token operator">=</span> c<span class="token punctuation">[</span>si<span class="token punctuation">]</span></span>
<span class="line">    <span class="token function">body</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span></span>
<span class="line">    si <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>after<span class="token punctuation">:</span> si<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This operation is generic: we have a name for the collection type (<code>C</code>), and know the relationship to its <code>Value</code> and <code>Index</code> types, so we have strong type equality. We can call this function with a value of type <code>any Collection</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token function">forEach</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span> element <span class="token keyword">in</span></span>
<span class="line">  <span class="token function">doSomething</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That call opens up the type of <code>c</code>, binding it to <code>forEach</code>&#39;s generic parameter <code>C</code>. The call itself still needs to erase the associated type, so the <code>element</code> parameter of the closure will be the type-erased <code>Value</code> type, i.e., <code>Any</code>.</p><h3 id="primary-associated-types" tabindex="-1"><a class="header-anchor" href="#primary-associated-types"><span>Primary associated types</span></a></h3><p>Sometimes, it can be useful to be able to make some of the associated types concrete even when using an <code>any</code> type. For example, we might want to be able to take any collection stores <code>String</code> values. We can do so with <em>primary</em> associated types, which use generic argument syntax to specify associated types. The primary associated types are listed in angle brackets following the protocol name:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">Value</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">Index</span><span class="token punctuation">:</span> <span class="token class-name">Equatable</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This enables <code>any</code> types to specify the <code>Value</code> type. For example, <code>any Collection&lt;String&gt;</code> is any type that conforms to <code>Collection</code> and has <code>String</code> as its value type. A value of such a type could store a <code>[String]</code>, <code>Set&lt;String&gt;</code>, or other collection:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">var</span> strings<span class="token punctuation">:</span> any <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span></span>
<span class="line">strings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">]</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span>first <span class="token operator">??</span> <span class="token string-literal"><span class="token string">&quot;Empty collection&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// &quot;Hello&quot;</span></span>
<span class="line">strings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">&quot;Hello&quot;</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">&quot;World&quot;</span></span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span>first <span class="token operator">??</span> <span class="token string-literal"><span class="token string">&quot;Empty collection&quot;</span></span><span class="token punctuation">)</span> <span class="token comment">// &quot;Hello&quot; or &quot;World&quot;; ordering in sets is not guaranteed</span></span>
<span class="line"></span>
<span class="line">strings <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token comment">// error: cannot convert value of type &#39;Int&#39; to expected element type &#39;String&#39; </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Even when there are primary associated types, one can use <code>any</code> types without mentioning them. In such cases, the associated type will be type-erased. For example, with the above protocol, <code>any Collection</code> will have its <code>Value</code> type type-erased to <code>Any</code>.</p><p>Why did we choose to make <code>Value</code> a primary associated type and not <code>Index</code>? It&#39;s all about the use cases, and here your instincts from C++ containers will serve you well: you generally care about the value type of a container because you&#39;re operating on its elements, but its iterator type is generally not interesting except as a mechanism to get at the elements. More importantly, although you generally get to choose the value type of your container, but the iterator comes with it, so only the value type makes sense as a primary associated type.</p><hr><h2 id="when-to-type-erase" tabindex="-1"><a class="header-anchor" href="#when-to-type-erase"><span>When to type-erase?</span></a></h2><p>Type erasure via <code>any</code> is not free: an instance of an <code>any</code> type has a fixed-sized buffer along with information about the (dynamically) stored type and each of the protocols that type conforms to. When the stored value is larger than that buffer, the <code>any</code> instance will be heap-allocated. Every operation on an instance of <code>any</code> goes through the equivalent of a <code>virtual</code> method dispatch, including copying and destruction. If you&#39;ve ever looked into the implementation of <code>std::any</code> or <code>std::function</code>, you&#39;ll have a good mental model for how <code>any</code> types work under the hood in Swift, and why they aren&#39;t cheap. The Swift optimizer will do some amount of specialization of <code>any</code> types, but for it to succeed it needs to see both the creation and use of the <code>any</code> type, so it&#39;s not recommended to rely heavily on this optimization.</p><p>Use <code>any</code> types when you need to store heterogeneous data that potentially accepts any number of types. If there&#39;s a small, fixed number of types that you might store (say, a choice among a few basic types), consider using an <code>enum</code> instead:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">enum</span> <span class="token class-name">StoredValue</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">integer</span><span class="token punctuation">(</span><span class="token class-name">Int</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">floating</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">case</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Operations on the <code>StoredValue</code> enum will be more efficient than operating on an <code>any Hashable</code> instance, because <code>StoredValue</code> is a concrete type.</p><p>More importantly, prefer generic operations to operations on <code>any</code> values. There is no reason to have a function that accepts a single <code>any</code> value, for example:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">operateOnAny</span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> any <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>because the same function can be expressed generically as follows:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">operateOnAny</span><span class="token operator">&lt;</span><span class="token class-name">C</span><span class="token punctuation">:</span> <span class="token class-name">Collection</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token class-name">C</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">C</span><span class="token punctuation">.</span><span class="token class-name">Value</span> <span class="token operator">==</span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Due to opening of <code>any</code> types, which we talked about earlier, the two functions above are effectively interchangeable for callers. The generic function is better for performance, however, both because calls passing a concrete type like <code>[String]</code> avoid the formation of the <code>any Collection&lt;String&gt;</code> value and because it&#39;s easier for the compiler to specialize the generic version for <code>[String]</code> when it&#39;s profitable.</p><p>This is another place where your C++ instincts are good and you shouldn&#39;t ignore them: you wouldn&#39;t write a function to take a <code>std::any</code> parameter unless you really couldn&#39;t write it as a function template taking an arbitrary <code>T</code>, so think of <code>any</code> types the same way in Swift.</p><p>It&#39;s a <em>little</em> unfortunate that the more efficient generic function is more verbose than the less-efficient one. I&#39;ve been holding off on introducing one last bit of syntactic sugar that gets rid of that advantage, because it needs a little explanation. Spoiler alert: the <code>some</code> keyword is used to introduce unnamed generic parameters with syntax parallel to that of <code>any</code> types, so the second function can be written as:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">operateOnAny</span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Each <code>some</code> type introduces an unnamed generic parameter whose constraints are listed after the <code>some</code>. Swift <code>some</code> types are also called <em>opaque</em> types, because they hide the name of the underlying type: an unnamed generic parameter can&#39;t be named (duh), so the actual collection type based into <code>operateOnAny(strings:)</code> is hidden from the function body. Opaque types are also useful in the return type of a function to hide the specific return type from the caller.</p><hr><h2 id="implementation-hiding-with-opaque-types" tabindex="-1"><a class="header-anchor" href="#implementation-hiding-with-opaque-types"><span>Implementation hiding with opaque types</span></a></h2><p><code>any</code> types effectively hide the underlying type from clients, allowing it to change dynamically at run time. These are two different things: the first is about hiding implementation details behind an abstraction barrier (e.g., we know that we have a <code>Collection</code> of <code>String</code>s, but not the specific type of the collection itself) and the other is about allowing the underlying representation to change dynamically (e.g., we can choose <code>Set&lt;String&gt;</code> or <code>[String]</code> depending on what&#39;s best for the problem at hand). Swift has a notion of <em>opaque</em> types that let you hide the implementation type behind an abstraction barrier without allowing it to change dynamically at runtime. This gives you, as the implementer, the freedom to limit your API surface area (by not exposing specific conrete types) and evolve your implementations over time, without breaking clients. For example, let&#39;s consider implementing a generic function <code>uniqued</code> on a <code>Collection</code> that produces a new collection with duplicates removed. We could have such a function return a <code>Set</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">func</span> <span class="token function-definition function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That implementation was easy, but it&#39;s perhaps not the best one. It might be better to unique into an array and return that, or return some different type entirely. The problem is that we have to decide right at the point where we create this function what the act type will be, and assess all of the tradeoffs. We could introduce a special type to capture the &quot;uniqued collection&quot;, like <code>UniquedCollection&lt;Self&gt;</code>. That&#39;s probably what we would do in C++, perhaps burying it in an <code>impl</code> or <code>detail</code> namespace to discourage users from depending on it. Opaque types let us describe the result type based on its capabilities (in terms of protocols) without stating its identity:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token comment">// okay, Set&lt;Value&gt; is a Collection&lt;Value&gt;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A user that calls <code>uniqued()</code> can&#39;t spell the type of the result, but it can be inferred and is known to be a collection containing the same value type as the collection it was applied to:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> uniquedNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// okay, type is opaque to the user</span></span>
<span class="line"><span class="token function">print</span><span class="token punctuation">(</span>uniquedNumbers<span class="token punctuation">.</span>first<span class="token punctuation">)</span>                         <span class="token comment">// prints the (1)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>If we later decide to change the type returned by <code>unique()</code>, we can, because we never exposed the type to the user. So we can change our implementation to produce an array:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// okay, unique via a set but return an array</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>or a private type of some sort:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">private</span> <span class="token keyword">struct</span> <span class="token class-name">UniquedCollection</span><span class="token operator">&lt;</span><span class="token class-name">C</span><span class="token punctuation">:</span> <span class="token class-name">Collection</span><span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">C</span><span class="token punctuation">.</span><span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token class-name">UniquedCollection</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token comment">// okay, unique via a set but return an array</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Because the type is opaque to clients, these implementation changes won&#39;t affect them at all: they&#39;re under-the-hood improvements made by the author of <code>uniqued()</code>.</p><h3 id="some-vs-any" tabindex="-1"><a class="header-anchor" href="#some-vs-any"><span><code>some</code> vs. <code>any</code></span></a></h3><p>In Swift, <code>any</code> types can be read to mean &quot;any type that satisfies these requirements&quot; whereas <code>some</code> types are read to mean &quot;some specific type that satisfied these requirements&quot;. The key point here is that <code>some</code> types maintain identity whereas <code>any</code> types do not: if I take that <code>uniquedNumbers</code> type from above, I can iterate over it directly:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> uniquedNumbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">var</span> ci <span class="token operator">=</span> uniquedNumbers<span class="token punctuation">.</span>startIndex</span>
<span class="line"><span class="token keyword">let</span> ei <span class="token operator">=</span> uniquedNumbers<span class="token punctuation">.</span>endIndex</span>
<span class="line"><span class="token keyword">while</span> ci <span class="token operator">!=</span> ei <span class="token punctuation">{</span> <span class="token comment">// okay, Index type of the opaque type of uniquedNumbers</span></span>
<span class="line">  <span class="token function">print</span><span class="token punctuation">(</span>uniquedNumbers<span class="token punctuation">[</span>ci<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">  ci <span class="token operator">=</span> uniquedNumbers<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>after<span class="token punctuation">:</span> ci<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This puts some restrictions on the body of functions returning <code>some</code> types. Specifically, every <code>return</code> statement must produce a value of the same type. This is called the <em>underlying type</em>, and the Swift compiler will detect a mismatch:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token number">66</span> <span class="token operator">|</span> <span class="token keyword">extension</span> <span class="token class-name">Collection</span> <span class="token keyword">where</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token number">67</span> <span class="token operator">|</span>   <span class="token keyword">func</span> <span class="token function-definition function">uniqued</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">   <span class="token operator">|</span>        \`<span class="token operator">-</span> error<span class="token punctuation">:</span> function declares an opaque <span class="token keyword">return</span> type &#39;<span class="token keyword">some</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span>&#39;<span class="token punctuation">,</span> but the <span class="token keyword">return</span> </span>
<span class="line">   <span class="token operator">|</span>           statements <span class="token keyword">in</span> its body <span class="token keyword">do</span> not have matching underlying types</span>
<span class="line"><span class="token number">68</span> <span class="token operator">|</span>     <span class="token keyword">if</span> isEmpty <span class="token punctuation">{</span></span>
<span class="line"><span class="token number">69</span> <span class="token operator">|</span>       <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token class-name">Element</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">   <span class="token operator">|</span>                      \`<span class="token operator">-</span> note<span class="token punctuation">:</span> <span class="token keyword">return</span> statement has underlying type &#39;<span class="token punctuation">[</span><span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Value</span><span class="token punctuation">]</span>&#39;</span>
<span class="line"><span class="token number">70</span> <span class="token operator">|</span>     <span class="token punctuation">}</span></span>
<span class="line"><span class="token number">71</span> <span class="token operator">|</span> </span>
<span class="line"><span class="token number">72</span> <span class="token operator">|</span>     <span class="token keyword">return</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Element</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span></span>
<span class="line">   <span class="token operator">|</span>                       \`<span class="token operator">-</span> note<span class="token punctuation">:</span> <span class="token keyword">return</span> statement has underlying type &#39;<span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Value</span><span class="token operator">&gt;</span>&#39;</span>
<span class="line"><span class="token number">73</span> <span class="token operator">|</span>   <span class="token punctuation">}</span></span>
<span class="line"><span class="token number">74</span> <span class="token operator">|</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Note that the identity of the underlying type is hidden from clients of the function, but it is known to the compiler, so hiding a type via an opaque type isn&#39;t a performance pessimization the way an <code>any</code> type is.</p><h3 id="hiding-complicated-result-types" tabindex="-1"><a class="header-anchor" href="#hiding-complicated-result-types"><span>Hiding complicated result types</span></a></h3>`,101)),n("p",null,[s[54]||(s[54]=a("Opaque result types really shine when they're used to hide unnecessary implementation details. To see what I mean, think about the types that are produced from a C++ library that uses ")),n("a",T,[e(o,{icon:"fa-brands fa-wikipedia-w"}),s[53]||(s[53]=a("expression templates"))]),s[55]||(s[55]=a(": every single operator introduces another wrapper type (often two of them), producing a final result whose type encodes the entire operation. For example, one might have a ")),s[56]||(s[56]=n("code",null,"parallel_array",-1)),s[57]||(s[57]=a(" type that uses expression templates, and an expression like:"))]),s[62]||(s[62]=l(`<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">auto</span> result <span class="token operator">=</span> a <span class="token operator">*</span> x <span class="token operator">+</span> b</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>would produce a type such as <code>expr&lt;add_expr&lt;expr&lt;mul_expr&lt;expr&lt;parallel_array&lt;double&gt;&gt;, expr&lt;double&gt;&gt;&gt;, expr&lt;parallel_array&lt;double&gt;&gt;&gt;</code>. Add some namespace qualifiers in there and it gets overwhelming, fast. It gets particularly bad when you have to name the result type for some reason, e.g.,</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">X</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">B</span><span class="token operator">&gt;</span></span>
<span class="line">expr<span class="token operator">&lt;</span>add_expr<span class="token operator">&lt;</span>expr<span class="token operator">&lt;</span>mul_expr<span class="token operator">&lt;</span>A<span class="token punctuation">,</span> X<span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> Y<span class="token operator">&gt;</span> <span class="token function">mul_add</span><span class="token punctuation">(</span>A a<span class="token punctuation">,</span> X x<span class="token punctuation">,</span> B b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> a <span class="token operator">*</span> x <span class="token operator">+</span> b<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Expression templates can be a useful tool in Swift for the same reasons they&#39;re useful in C++, and Swift would have exactly the same issue with an explosion in user-facing types from simple uses. However, opaque result types let us hide the information behind a <code>some</code> type. For example,</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">protocol</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">associatedtype</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token class-name">Numeric</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">struct</span> <span class="token class-name">MulScalarOp</span><span class="token operator">&lt;</span><span class="token constant">LHS</span><span class="token punctuation">:</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&gt;</span><span class="token punctuation">:</span> <span class="token class-name">ArrayExpr</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">typealias</span> <span class="token class-name">Value</span> <span class="token operator">=</span> <span class="token constant">LHS</span><span class="token punctuation">.</span><span class="token class-name">Value</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token constant">LHS</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token constant">LHS</span><span class="token punctuation">.</span><span class="token class-name">Value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token operator">*&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> </span>
<span class="line">  <span class="token class-name">MulScalarOp</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> value<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">struct</span> <span class="token class-name">AddArrayOp</span><span class="token operator">&lt;</span><span class="token constant">LHS</span><span class="token punctuation">:</span> <span class="token class-name">ArrayExpr</span><span class="token punctuation">,</span> <span class="token constant">RHS</span><span class="token punctuation">:</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&gt;</span> <span class="token keyword">where</span> <span class="token constant">LHS</span><span class="token punctuation">.</span><span class="token class-name">Value</span> <span class="token operator">==</span> <span class="token constant">RHS</span><span class="token punctuation">.</span><span class="token class-name">Value</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">typealias</span> <span class="token class-name">Value</span> <span class="token operator">=</span> <span class="token constant">LHS</span><span class="token punctuation">.</span><span class="token class-name">Value</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">init</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token constant">LHS</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token constant">RHS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">func</span> <span class="token operator">+&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> </span>
<span class="line">  <span class="token class-name">AddArrayOp</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> rhs<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, code like this:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> result <span class="token operator">=</span> a <span class="token operator">*</span> x <span class="token operator">+</span> b</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>produces an opaque type like <code>some ArrayExpr&lt;Double&gt;</code> that avoids exposing all of the implementation details of the expression templates. Add operation like the C++ <code>mul_add</code> earlier can be expressed in terms of opaque types so one never has to name the complicated types:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">func</span> <span class="token function-definition function">mulAdd</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> a<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> x<span class="token punctuation">:</span> <span class="token class-name">Value</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> b<span class="token punctuation">:</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">some</span> <span class="token class-name">ArrayExpr</span><span class="token operator">&lt;</span><span class="token class-name">Value</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  a <span class="token operator">*</span> x <span class="token operator">+</span> b</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We&#39;re still expressing the fundamental type constraints here: both <code>a</code> and <code>b</code> are array expressions of some type, whose underlying value type is <code>Value</code>, and <code>x</code> is a scalar of type <code>Value</code>. But we&#39;ve abstracted away the actual array expression types so they can be propagated behind-the-scenes.</p><p>However, the compiler can still see the underlying types, so it can optimize the expression templates in the same manner one would expect.</p><hr><h2 id="wrap-up" tabindex="-1"><a class="header-anchor" href="#wrap-up"><span>Wrap up</span></a></h2><p>Type erasure in Swift leverages the same notion of protocols and constraints as generics, but moves from the realm of static polymorphism (concrete types known at compile time) to runtime polymorphism (types only known at runtime). Type erasure makes it easy to create heterogeneous data structures, which contain values of types not known until runtime.</p><p>Because of Swift&#39;s model of separate compilation, one can move easily between static and dynamic polymorphism: a value that conforms to a protocol <code>P</code> can be type-erased into a value of type <code>any P</code>, moving from static to dynamic polymorphism. Conversely, a value of type <code>any P</code> can be passed to a generic function requiring a type conforming to <code>P</code>, moving from dynamic back to static polymorphism. So while most of the time you should probably be using generics for abstraction, because they maintain more type information and are therefore easier to optimize, you can use type erasure locally in those places where you need the runtime polymorphism.</p><p>We also discussed metatypes. Metatypes are first-class values in Swift, and are the answer to the question &quot;what&#39;s the type of this value?&quot;. Metatypes can be used to identify the types of values, construct new instances of the identified type (when there is a suitable <code>init</code> requirement), and dynamically query the capabilities of a given type with queries such as &quot;does this type conform to the protocol <code>Decodable</code>?&quot;.</p><p>Next up, we&#39;ll explore Swift&#39;s take on error handling, comparing against C++&#39;s model of exceptions.</p>`,17))])}const V=k(v,[["render",I]]),A=JSON.parse('{"path":"/douggregor.net/swift-for-cpp-practitioners-5.html","title":"Swift for C++ Practitioners, Part 5: Type erasure & metatypes","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Swift for C++ Practitioners, Part 5: Type erasure & metatypes","description":"Article(s) > Swift for C++ Practitioners, Part 5: Type erasure & metatypes","icon":"fa-brands fa-swift","category":["Swift","C++","Article(s)"],"tag":["blog","douggregor.net","swift","ios","c++","cpp"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Swift for C++ Practitioners, Part 5: Type erasure & metatypes\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/douggregor.net/swift-for-cpp-practitioners-5.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Swift for C++ Practitioners, Part 5: Type erasure & metatypes"}],["meta",{"property":"og:description","content":"Article(s) > Swift for C++ Practitioners, Part 5: Type erasure & metatypes"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:tag","content":"c++"}],["meta",{"property":"article:tag","content":"ios"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"douggregor.net"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-04-11T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Swift for C++ Practitioners, Part 5: Type erasure & metatypes"},{"property":"og:description","content":"Swift for C++ Practitioners, Part 5: Type erasure & metatypes"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/douggregor.net/swift-for-cpp-practitioners-5.html"}]],"prev":"/programming/swift/articles/README.md","date":"2024-04-11T00:00:00.000Z","isOriginal":false},"git":{},"readingTime":{"minutes":18.84,"words":5652},"filePathRelative":"douggregor.net/swift-for-cpp-practitioners-5.md"}');export{V as comp,A as data};
