import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,d as s,f as a,b as m,a as v,t as g,n as l,g as i,w as t,r as o,o as b,e as p}from"./app-BVguHYKu.js";const h={},y={id:"frontmatter-title-관련",tabindex:"-1"},f={class:"header-anchor",href:"#frontmatter-title-관련"},w={class:"table-of-contents"};function j(r,n){const c=o("VPCard"),e=o("router-link"),u=o("SiteInfo");return b(),k("div",null,[s("h1",y,[s("a",f,[s("span",null,g(r.$frontmatter.title)+" 관련",1)])]),a(c,l(i({title:"JavaScript > Article(s)",desc:"Article(s)",link:"/programming/js/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",w,[s("ul",null,[s("li",null,[a(e,{to:"#배열을-더-짧고-더-명확하게-다루는-방법"},{default:t(()=>n[0]||(n[0]=[p("배열을 더 짧고, 더 명확하게 다루는 방법")])),_:1,__:[0]}),s("ul",null,[s("li",null,[a(e,{to:"#_1-at"},{default:t(()=>n[1]||(n[1]=[p("1. .at()")])),_:1,__:[1]})]),s("li",null,[a(e,{to:"#_2-groupby"},{default:t(()=>n[2]||(n[2]=[p("2. .groupBy()")])),_:1,__:[2]})]),s("li",null,[a(e,{to:"#_3-tosorted"},{default:t(()=>n[3]||(n[3]=[p("3 .toSorted()")])),_:1,__:[3]})])])]),s("li",null,[a(e,{to:"#객체를-더-안전하게-다루는-방법"},{default:t(()=>n[4]||(n[4]=[p("객체를 더 안전하게 다루는 방법")])),_:1,__:[4]}),s("ul",null,[s("li",null,[a(e,{to:"#_1-object-hasown"},{default:t(()=>n[5]||(n[5]=[p("1. Object.hasOwn()")])),_:1,__:[5]})]),s("li",null,[a(e,{to:"#_2-object-groupby"},{default:t(()=>n[6]||(n[6]=[p("2 Object.groupBy()")])),_:1,__:[6]})])])]),s("li",null,[a(e,{to:"#비동기-흐름을-더-유연하게-다루는-방법"},{default:t(()=>n[7]||(n[7]=[p("비동기 흐름을 더 유연하게 다루는 방법")])),_:1,__:[7]}),s("ul",null,[s("li",null,[a(e,{to:"#_1-promise-withresolvers"},{default:t(()=>n[8]||(n[8]=[p("1. Promise.withResolvers()")])),_:1,__:[8]})])])]),s("li",null,[a(e,{to:"#마치며"},{default:t(()=>n[9]||(n[9]=[p("마치며")])),_:1,__:[9]})])])]),n[10]||(n[10]=s("hr",null,null,-1)),a(u,{name:"자바스크립트 최신 메서드를 소개합니다",desc:"자바스크립트를 사용하는 개발자라 해도, ECMAScript에 어떤 기능이 새로 추가되고 있는지 잘 모르는 경우가 많습니다. 눈에 띄게 화려한 기능은 아니지만, 평소 우리가 반복해서 작성하던 코드를 훨씬 더 짧고 간결하게 바꿔주는 작고 실용적인 메서드들이 최근 몇 년 사이 꾸준히 추가되고 있습니다. 이번 글에서는 자바스크립트에 최근 새롭게 추가된 배열, 객체, 프로미스(Promise) 관련 메서드들을 소개해 보겠습니다. 이 메서드들은 복잡한 기능을 추가한 것이 아니라, 우리가 자주 쓰는 코드 패턴을 더 명확하고 간결하게 만들어 주는 기능입니다.",url:"https://yozm.wishket.com/magazine/detail/3156/",logo:"https://yozm.wishket.com/favicon.ico",preview:"https://yozm.wishket.com/media/news/3156/thumbnail.png"}),n[11]||(n[11]=m(`<p>자바스크립트를 사용하는 개발자라 해도, ECMAScript에 어떤 기능이 새로 추가되고 있는지 잘 모르는 경우가 많습니다. 눈에 띄게 화려한 기능은 아니지만, 평소 우리가 반복해서 작성하던 코드를 훨씬 더 짧고 간결하게 바꿔주는 작고 실용적인 메서드들이 최근 몇 년 사이 꾸준히 추가되고 있습니다.</p><p>예를 들어, 배열에서 마지막 값을 꺼낼 때마다 arr[arr.length -1]을 사용했다면, 이제는 arr.at(-1)처럼 조금 더 직관적이고 간결한 방법이 생겼고, 객체의 속성이 존재하는지 확인할 때 매번 hasOwnProperty()를 사용했다면, 이제는 Object.hasOwn()이라는 훨씬 안전한 방식을 사용할 수 있습니다.</p><figure><img src="https://wishket.com/media/news/3156/img1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>이번 글에서는 자바스크립트에 최근 새롭게 추가된 배열, 객체, 프로미스(Promise) 관련 메서드들을 소개해 보겠습니다. 이 메서드들은 복잡한 기능을 추가한 것이 아니라, 우리가 자주 쓰는 코드 패턴을 더 명확하고 간결하게 만들어 주는 기능입니다. 프론트엔드 개발자뿐만 아니라, 이제 막 자바스크립트를 배우기 시작한 입문자에게도 많은 도움이 될 것입니다.</p><p>또한 리액트(React)나 넥스트js(Next.js)를 사용하는 개발자들도 매우 유용하게 활용할 수 있습니다. 새로운 기능이라고 해서 어렵거나 부담스러운 것이 아니라, 오히려 익숙한 문제를 더 쉽고 간단하게 해결할 수 있도록 도와주는 도구라는 점을 함께 느껴 보시면 좋겠습니다.</p><hr><h2 id="배열을-더-짧고-더-명확하게-다루는-방법" tabindex="-1"><a class="header-anchor" href="#배열을-더-짧고-더-명확하게-다루는-방법"><span>배열을 더 짧고, 더 명확하게 다루는 방법</span></a></h2><p>자바스크립트를 다루면서 가장 자주 마주하는 데이터 구조 중 하나는 바로 배열입니다. 반복문, 정렬, 필터링 등 다양한 상황에서 등장하는 만큼, 배열을 효과적으로 다루는 도구가 많을수록 생산성도 자연스럽게 높아지게 되죠. 최근 자바스크립트에서는 배열을 더 안전하고 읽기 쉽게 다룰 수 있는 새로운 메서드들이 등장했는데요. 하나씩 살펴볼게요.</p><h3 id="_1-at" tabindex="-1"><a class="header-anchor" href="#_1-at"><span>1. <code>.at()</code></span></a></h3><p>배열에서 특정 위치의 값을 가져오는 일은 매우 흔한 작업입니다. 특히 마지막 요소를 가져와야 하는 경우, 우리는 오랫동안 <code>arr[arr.length-1]</code>이라는 문법에 익숙해져 있었습니다. 하지만 이 방식은 길이 계산이 필요하고, 읽는 사람 입장에서는 즉각적으로 “마지막 요소를 가져오려는 의도”가 명확하게 드러나지 않는다는 단점이 있었죠.</p><p><code>.at()</code> 메서드는 이 문제를 간단하게 해결해 주는 도구입니다. 인덱스를 기준으로 요소를 반환하는 이 메서드는, 특히 음수 인덱스를 사용할 수 있다는 점에서 큰 차별점을 가집니다. <code>arr.at(-1)</code>이라고 작성하면 배열의 마지막 요소를 바로 얻을 수 있고, <code>arr.at(-2)</code>라고 작성하면, 뒤에서 두 번째 요소를 가져옵니다.</p><p>예를 들어, 사용자가 입력한 값들을 순서대로 배열에 저장해두고, 가장 최근 항목만 화면에 표시하고 싶을 때, <code>.at(-1)</code>을 사용하면 매우 직관적인 코드가 됩니다. 또한 배열이 비어 있는 경우에도 에러가 발생하지 않고 <code>undefined</code>를 반환하기 때문에, 조건문과 함께 쓰면 안전한 코드 작성이 가능합니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;apple&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;banana&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;grape&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// grape</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fruits<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// banana</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-groupby" tabindex="-1"><a class="header-anchor" href="#_2-groupby"><span>2. <code>.groupBy()</code></span></a></h3><p>다양한 데이터를 다룰 때 자주 하게 되는 작업 중 하나는, 특정 기준에 따라 항목들을 묶는 일입니다. 예를 들어, 게시글을 태그별로 구분하거나, 주문 목록을 결제 상태별로 나누거나, 유저 정보를 등급별로 분류하는 경우가 그렇습니다.</p><p>기존에는 이러한 분류 작업을 아래와 같이 <code>reduce()</code>로 직접 구현하거나, 외부 라이브러리를 사용해야 했습니다.</p><figure><img src="https://wishket.com/media/news/3156/img2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>물론 이 방식도 잘 동작하지만, 코드가 길어지고 의도가 눈에 잘 드러나지 않는다는 단점이 있었는데요, 이제는 ECMAScript 2024에서 새롭게 표준으로 채택된 <code>Array.prototype.groupBy()</code> 메서드를 사용하면 훨씬 간결하고 명확한 코드로 같은 작업을 수행할 수 있습니다. 이 메서드는 배열의 각 요소에 대해 분류 기준이 되는 키를 반환하는 콜백 함수를 인자로 받아, 해당 키를 기준으로 항목들을 자동으로 그룹화해 객체 형태로 반환합니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> posts <span class="token operator">=</span> <span class="token punctuation">[</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;useState 완전정복&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;js&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;클로저 쉽게 이해하기&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">&quot;useEffect 패턴&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> groupedByTag <span class="token operator">=</span> posts<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span><span class="token parameter">post</span> <span class="token operator">=&gt;</span> post<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">/*</span>
<span class="line">{</span>
<span class="line">  react: [</span>
<span class="line">    { id: 1, tag: &quot;react&quot;, title: &quot;useState 완전정복&quot; },</span>
<span class="line">    { id: 3, tag: &quot;react&quot;, title: &quot;useEffect 패턴&quot; }</span>
<span class="line">  ],</span>
<span class="line">  js: [</span>
<span class="line">    { id: 2, tag: &quot;js&quot;, title: &quot;클로저 쉽게 이해하기&quot; }</span>
<span class="line">  ]</span>
<span class="line">}</span>
<span class="line">*/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이렇게 작성하면 <code>reduce()</code>로 수동 처리하던 복잡한 로직을 단 한 줄로 대체할 수 있고, 가독성도 훨씬 좋아집니다. <code>groupBy()</code>는 특히 서버에서 받아온 데이터를 카테고리별로 묶어 리스트를 나눠 보여주는 UI를 만들 때 아주 유용합니다. 예를 들어, 날짜별로 할 일을 그룹화하거나 상태값(status)에 따라 이슈를 나누는 기능을 구현할 때, 이 메서드를 활용하면 훨씬 간결하고 직관적인 코드를 작성할 수 있습니다.</p><h3 id="_3-tosorted" tabindex="-1"><a class="header-anchor" href="#_3-tosorted"><span>3 <code>.toSorted()</code></span></a></h3><p>배열을 정렬하는 작업은 데이터 가공의 기본 중 기본이죠. 숫자를 오름차순으로 정렬하거나, 텍스트를 알파벳순으로 나열하는 등의 작업은 거의 모든 웹 애플리케이션에서 필요합니다. 그동안 자바스크립트에서는 <code>Array.prototype.sort()</code>를 사용해서 정렬해 왔었는데요. 이 메서드는 정렬 결과를 반환하는 동시에 원본 배열을 직접 수정한다는 특징을 가지고 있습니다. 이러한 특징은 의도치 않은 부작용을 일으킬 수 있어 주의해서 사용해야 했습니다.</p><p>이런 문제를 해결하기 위해 등장한 것이 바로 <code>toSorted()</code>입니다. 이 메서드는 기존 배열을 변경하지 않고, 정렬된 새로운 배열을 반환합니다. 즉, 원본을 그대로 두고 복사본을 정렬하는 방식이기 때문에 데이터의 불변성을 지켜야 하는 상황에서도 매우 유용하게 쓰입니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">const</span> sortedPrices <span class="token operator">=</span> prices<span class="token punctuation">.</span><span class="token function">toSorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sortedPrices<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1000, 3000, 4000]</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>prices<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [4000, 1000, 3000] (원본은 그대로)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>실무에서 상품 가격 목록을 오름차순으로 정렬하거나, 기록을 날짜 순으로 정렬할 때 원본 데이터를 유지하면서 정렬된 데이터를 따로 보여줘야 하는 경우가 많은데요. 이럴 때 이렇게 <code>toSorted()</code>를 활용하면 <code>slice().sort()</code>처럼 우회하지 않고도 더욱 직관적인 코드를 작성할 수 있습니다.</p><hr><h2 id="객체를-더-안전하게-다루는-방법" tabindex="-1"><a class="header-anchor" href="#객체를-더-안전하게-다루는-방법"><span>객체를 더 안전하게 다루는 방법</span></a></h2><p>자바스크립트의 객체는 매우 유연한 구조를 가지고 있습니다. 이런 유연함 덕분에 다양한 데이터 구조를 표현할 수 있지만, 동시에 예기치 않은 버그가 발생하기 쉬운 부분이기도 합니다. 최근 자바스크립트에서는 객체를 더욱 명확하고 안전하게 다룰 수 있도록 몇 가지 유용한 메서드가 새로 도입되었습니다. 그중에서도 <code>Object.hasOwn()</code>과 <code>Object.groupBy()</code>는 객체 검사 및 데이터 분류 작업에 큰 도움이 됩니다. 하나씩 살펴볼게요.</p><h3 id="_1-object-hasown" tabindex="-1"><a class="header-anchor" href="#_1-object-hasown"><span>1. <code>Object.hasOwn()</code></span></a></h3><p>객체에 특정 속성이 있는지를 확인할 때 흔히 사용하는 방식은 <code>obj.hasOwnProperty(key)</code>입니다. 하지만 이 방식은 몇 가지 문제를 가지고 있는데요. <code>hasOwnProperty()</code>는 객체가 직접 가진 메서드가 아니라 <code>Object.prototype</code>으로부터 상속받은 것이기 때문에, 객체에 해당 프로토타입을 제거했거나 속성을 덮어썼을 경우 제대로 동작하지 않을 수 있습니다.</p><p>이 문제를 해결하기 위해 등장한 것이 바로 <code>Object.hasOwn()</code>입니다. 이 메서드는 첫 번째 인자로 객체를, 두 번째 인자로 속성 키를 받아, 해당 키가 그 객체 자체에서 직접 존재하는지를 안전하게 판단합니다. 특히 <code>Object.create(null)</code>과 같이 프로토타입이 없는 순수한 객체에서도 예외 없이 안정적으로 사용할 수 있다는 점이 핵심입니다. 예를 들어, 아래의 코드를 보겠습니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> settings <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">settings<span class="token punctuation">.</span>theme <span class="token operator">=</span> <span class="token string">&quot;dark&quot;</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>settings<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></span>
<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">hasOwn</span><span class="token punctuation">(</span>settings<span class="token punctuation">,</span> <span class="token string">&quot;theme&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>여기서 <code>Object.create(null)</code>을 사용해 만든 <code>settings</code> 객체는 <code>Object.prototype</code>을 상속받지 않습니다. 즉, 일반 객체처럼 <code>.hasOwnProperty</code>라는 메서드를 내장하고 있지 않아, <code>settings.hasOwnProperty</code>를 호출하면 <code>undefined</code>가 출력되고, 만약 이를 사용하려고 하면 에러가 발생하게 됩니다.</p><p>하지만 <code>Object.hasOwn(settings, &#39;theme&#39;)</code>을 사용하면 문제없이 &#39;theme&#39;라는 속성이 <code>settings</code>에 존재하는지를 확인할 수 있습니다. 이처럼 <code>Object.hasOwn()</code>은 모든 종류의 객체에 대해 안전하게 속성 존재 여부를 확인할 수 있는 표준적인 방법이므로, 앞으로는 <code>hasOwnProperty()</code>보다 이 메서드를 우선적으로 사용하는 것이 바람직하다고 할 수 있습니다.</p><h3 id="_2-object-groupby" tabindex="-1"><a class="header-anchor" href="#_2-object-groupby"><span>2 <code>Object.groupBy()</code></span></a></h3><p>배열 데이터를 조건에 따라 나누고, 이를 객체의 형태로 정리해서 활용해야 하는 상황은 매우 흔합니다. 예를 들어, 게시글을 작성일 기준으로 묶거나, 고객 데이터를 등급별로 구분하거나, 이벤트 로그를 레벨별로 분류하는 등의 작업이 있죠.</p><p>이러한 작업은 <code>Object.groupBy()</code>를 사용하면 편하게 처리할 수 있습니다. 이 메서드는 <code>Array.prototype.groupBy()</code>와 유사한 동작을 하지만, Object 객체의 정적 메서드로 정의되어 있다는 점이 다릅니다. 두 메서드 모두 결과를 일반 객체 형태로 반환하며, 그룹화된 키는 문자열로 변환되기 때문에 JSON 직렬화에 유리하고, UI 렌더링이나 조건 분기에도 쉽게 활용할 수 있습니다. 예를 들어, 학생 데이터를 학년(<code>grade</code>) 기준으로 그룹화하고 싶을 때 다음과 같이 사용할 수 있습니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> students <span class="token operator">=</span> <span class="token punctuation">[</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;혜진&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">grade</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;민수&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">grade</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;수지&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">grade</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;지훈&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">grade</span><span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> groupedByGrade <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">groupBy</span><span class="token punctuation">(</span>students<span class="token punctuation">,</span> <span class="token parameter">student</span> <span class="token operator">=&gt;</span> student<span class="token punctuation">.</span>grade<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">/*</span>
<span class="line">{</span>
<span class="line">  1: [</span>
<span class="line">    { name: &quot;혜진&quot;, grade: 1 },</span>
<span class="line">    { name: &quot;수지&quot;, grade: 1 }</span>
<span class="line">  ],</span>
<span class="line">  2: [</span>
<span class="line">    { name: &quot;민수&quot;, grade: 2 }</span>
<span class="line">  ],</span>
<span class="line">  3: [</span>
<span class="line">    { name: &quot;지훈&quot;, grade: 3 }</span>
<span class="line">  ]</span>
<span class="line">}</span>
<span class="line">*/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이 메서드는 사용자 목록을 역할별로 분류하거나, 상품 데이터를 카테고리별로 정리해야 할 때처럼, 프론트엔드에서 자주 마주치는 UI 구조를 손쉽게 뒷받침하는 도구로 매우 효과적입니다. 기존에는 <code>reduce()</code>를 이용해 비교적 복잡한 코드를 작성해야 했다면, 이제는 <code>Object.groupBy()</code> 하나로 의도가 명확한 코드를 작성할 수 있습니다.</p><hr><h2 id="비동기-흐름을-더-유연하게-다루는-방법" tabindex="-1"><a class="header-anchor" href="#비동기-흐름을-더-유연하게-다루는-방법"><span>비동기 흐름을 더 유연하게 다루는 방법</span></a></h2><p>자바스크립트는 비동기 처리를 기본으로 하는 언어입니다. 네트워크 요청, 타이머, 사용자 인터랙션 등 대부분의 작업이 비동기 흐름 안에서 처리되죠. 하지만 때로는 단순한 <code>fetch()</code> 호출만으로 해결되지 않는 복잡한 흐름이 필요합니다. 예를 들어, 특정 조건이 충족될 때까지 기다렸다가 처리하거나, 사용자 행동을 기다리는 구조 등입니다.</p><figure><img src="https://wishket.com/media/news/3156/img3.png" alt="출처: 작가, 냅킨AI" tabindex="0" loading="lazy"><figcaption>출처: 작가, 냅킨AI</figcaption></figure><p>기존에는 <code>new Promise()</code>를 생성하고, 외부에 <code>resolve</code>나 <code>reject</code>를 꺼내 사용하는 방식이 일반적이었지만, 이 방식은 반복적으로 사용할수록 코드가 지저분해지고, 유지보수도 어려워질 수 있는데요. 이러한 문제를 해결하기 위해 등장한 메서드를 살펴보겠습니다.</p><h3 id="_1-promise-withresolvers" tabindex="-1"><a class="header-anchor" href="#_1-promise-withresolvers"><span>1. <code>Promise.withResolvers()</code></span></a></h3><p>위에서 언급한 문제를 해결하기 위해 등장한 메서드가 바로 <code>Promise.withResolvers()</code>입니다. 이 메서드를 사용하면 <code>promise</code>, <code>resolve</code>, <code>reject</code>를 한 번에 얻을 수 있어서, 외부에서 비동기 흐름을 직접 제어하기가 훨씬 쉬워집니다. 하지만 <code>Promise.withResolvers()</code>는 현재 ECMAScript 표준에는 포함되어 있지 않으며, 아직 제안 단계에 있는 상태입니다. 일부 환경에서는 사용 가능하지만, 구 브라우저나 런타임에서는 직접 구현이 필요할 수 있다는 점을 주의해야 합니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">const</span> <span class="token punctuation">{</span> promise<span class="token punctuation">,</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">withResolvers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&quot;완료되었습니다!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;완료되었습니다!&quot;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이러한 구조는 특히 사용자 액션을 기다려야 하는 상황에서 매우 유용하게 사용됩니다. 예를 들어, 사용자가 확인 버튼을 눌러야만 다음 단계로 진행되는 모달을 생각해 볼 수 있는데요, 예제 코드를 통해 살펴보겠습니다.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">showConfirmModal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> promise<span class="token punctuation">,</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">withResolvers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">openModal</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">onConfirm</span><span class="token operator">:</span> resolve <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 확인 시 resolve 호출</span></span>
<span class="line">  <span class="token keyword">return</span> promise<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handleDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> confirmed <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">showConfirmModal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>confirmed<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">deleteItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>기존에는 콜백 지옥이 생기거나, 상태를 복잡하게 구성해야 했던 흐름도, 위의 코드와 같이 <code>Promise.withResolvers()</code>를 사용하면 훨씬 간결하고 선언적인 방식으로 구현 가능합니다.</p><hr><h2 id="마치며" tabindex="-1"><a class="header-anchor" href="#마치며"><span>마치며</span></a></h2><p>지금까지 살펴본 메서드들은 <code>.at()</code>, <code>Array.prototype.groupBy()</code>, <code>.toSorted()</code>, <code>Object.hasOwn()</code>, <code>Object.groupBy()</code>, <code>Promise.withResolvers()</code>처럼 크고 복잡한 기능이 아닙니다. 하지만 우리가 매일 반복하는 코드, 즉 배열에서 값을 꺼내고, 데이터를 그룹화하고, 객체 속성을 확인하고, 비동기 흐름을 다루는 작업을 더 안전하고 읽기 좋게 바꿔주는 작지만 강력한 도구라고 할 수 있습니다.</p><p>이 글에서 소개한 메서드들을 사용하면 기존보다 더 짧고 명확하게 코드를 작성할 수 있습니다. 또한 버그를 줄일 수 있고, 협업에서도 의도를 더욱 쉽게 전달할 수 있습니다. 특히 React나 Next.js를 사용하는 프로젝트에서는 상태 불변성과 조건 분기가 많아, 이 메서드들이 주는 장점이 더 크게 느껴질 겁니다. 최신 문법이라고 해서 무조건 어렵거나 무거운 것은 아닙니다. 오히려 지금까지 복잡하게 풀던 문제를 더 단순하고, 쉽게 해결할 수 있는 방법을 알게 되는 쪽에 가깝습니다. 이제 여러분의 프로젝트에도 하나씩 적용해 보며, 기능들을 익혀보시길 추천합니다.</p>`,54)),v(" TODO: add ARTICLE CARD "),a(c,l(i({title:"자바스크립트 최신 메서드를 소개합니다",desc:"자바스크립트를 사용하는 개발자라 해도, ECMAScript에 어떤 기능이 새로 추가되고 있는지 잘 모르는 경우가 많습니다. 눈에 띄게 화려한 기능은 아니지만, 평소 우리가 반복해서 작성하던 코드를 훨씬 더 짧고 간결하게 바꿔주는 작고 실용적인 메서드들이 최근 몇 년 사이 꾸준히 추가되고 있습니다. 이번 글에서는 자바스크립트에 최근 새롭게 추가된 배열, 객체, 프로미스(Promise) 관련 메서드들을 소개해 보겠습니다. 이 메서드들은 복잡한 기능을 추가한 것이 아니라, 우리가 자주 쓰는 코드 패턴을 더 명확하고 간결하게 만들어 주는 기능입니다.",link:"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3156.html",logo:"https://yozm.wishket.com/favicon.ico",background:"rgba(84,7,224,0.2)"})),null,16)])}const O=d(h,[["render",j]]),x=JSON.parse('{"path":"/yozm.wishket.com/3156.html","title":"자바스크립트 최신 메서드를 소개합니다","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"자바스크립트 최신 메서드를 소개합니다","description":"Article(s) > 자바스크립트 최신 메서드를 소개합니다","icon":"fa-brands fa-js","category":["JavaScript","Article(s)"],"tag":["blog","yozm.wishket.com","js","javascript"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"자바스크립트 최신 메서드를 소개합니다\\",\\"image\\":[\\"https://wishket.com/media/news/3156/img1.png\\",\\"https://wishket.com/media/news/3156/img2.png\\",\\"https://wishket.com/media/news/3156/img3.png\\"],\\"datePublished\\":\\"2025-05-29T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"효빈\\",\\"url\\":\\"https://yozm.wishket.com/magazine/@hbin12212/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3156.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"자바스크립트 최신 메서드를 소개합니다"}],["meta",{"property":"og:description","content":"Article(s) > 자바스크립트 최신 메서드를 소개합니다"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yozm.wishket.com/media/news/3156/thumbnail.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://yozm.wishket.com/media/news/3156/thumbnail.png"}],["meta",{"name":"twitter:image:alt","content":"자바스크립트 최신 메서드를 소개합니다"}],["meta",{"property":"article:author","content":"효빈"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"yozm.wishket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-05-29T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > 자바스크립트 최신 메서드를 소개합니다"},{"property":"og:description","content":"자바스크립트 최신 메서드를 소개합니다"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3156.html"}]],"prev":"/programming/js/articles/README.md","date":"2025-05-29T00:00:00.000Z","isOriginal":false,"author":[{"name":"효빈","url":"https://yozm.wishket.com/magazine/@hbin12212/"}],"cover":"https://yozm.wishket.com/media/news/3156/thumbnail.png"},"git":{},"readingTime":{"minutes":1.64,"words":491},"filePathRelative":"yozm.wishket.com/3156.md","copyright":{"author":"효빈"}}');export{O as comp,x as data};
