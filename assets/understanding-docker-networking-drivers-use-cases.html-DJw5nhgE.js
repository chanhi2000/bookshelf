import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,d as n,f as t,b as v,a as m,t as g,n as d,g as l,w as o,e as r,r as a,o as w}from"./app-BItykJLQ.js";const b={},f={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},y={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},D={class:"table-of-contents"},C={href:"https://github.com/docker/libnetwork/blob/master/docs/design.md",target:"_blank",rel:"noopener noreferrer"},N={href:"https://success.docker.com/Datacenter/Apply/Docker_Reference_Architecture%3A_Designing_Scalable%2C_Portable_Docker_Container_Networks",target:"_blank",rel:"noopener noreferrer"};function A(p,e){const i=a("VPCard"),s=a("router-link"),h=a("SiteInfo"),c=a("VPIcon");return w(),k("div",null,[n("h1",f,[n("a",y,[n("span",null,g(p.$frontmatter.title)+" ê´€ë ¨",1)])]),t(i,d(l({title:"Docker > Article(s)",desc:"Article(s)",link:"/devops/docker/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",D,[n("ul",null,[n("li",null,[t(s,{to:"#bridge-network-driver"},{default:o(()=>[...e[0]||(e[0]=[r("Bridge Network Driver",-1)])]),_:1})]),n("li",null,[t(s,{to:"#overlay-network-driver"},{default:o(()=>[...e[1]||(e[1]=[r("Overlay Network Driver",-1)])]),_:1})]),n("li",null,[t(s,{to:"#macvlan-driver"},{default:o(()=>[...e[2]||(e[2]=[r("MACVLAN Driver",-1)])]),_:1})])])]),e[10]||(e[10]=n("hr",null,null,-1)),t(h,{name:"Docker Networking Drivers - Details and Use Cases",desc:"Learn the details and proper use of Docker Network Drivers including Bridge, Overlay and MACVLan drivers to increase app portability and security.",url:"https://docker.com/blog/understanding-docker-networking-drivers-use-cases",logo:"https://docker.com/app/uploads/2024/02/cropped-docker-logo-favicon-192x192.png",preview:"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-3.png"}),n("p",null,[e[6]||(e[6]=r("Applications requirements and networking environments are diverse and sometimes opposing forces. In between applications and the network sits Docker networking, affectionately called the ",-1)),n("a",C,[e[3]||(e[3]=r("Container Network Model (",-1)),t(c,{icon:"iconfont icon-github"}),e[4]||(e[4]=n("code",null,"docker/libnetwork",-1)),e[5]||(e[5]=r(")",-1))]),e[7]||(e[7]=r(" or CNM. Itâ€™s CNM that brokers connectivity for your Docker containers and also what abstracts away the diversity and complexity so common in networking. The result is portability and it comes from CNMâ€™s powerful network drivers. These are pluggable interfaces for the Docker Engine, Swarm, and UCP that provide special capabilities like multi-host networking, network layer encryption, and service discovery.",-1))]),n("p",null,[e[9]||(e[9]=r("Naturally, the next question is which network driver should I use? Each driver offers tradeoffs and has different advantages depending on the use case. There are built-in network drivers that come included with Docker Engine and there are also plug-in network drivers offered by networking vendors and the community. The most commonly used built-in network drivers are bridge, overlay and macvlan. Together they cover a very broad list of networking use cases and environments. For a more in depth comparison and discussion of even more network drivers, check out the ",-1)),n("a",N,[t(c,{icon:"fa-brands fa-docker"}),e[8]||(e[8]=r("Docker Network Reference Architecture.",-1))])]),e[11]||(e[11]=v(`<hr><h2 id="bridge-network-driver" tabindex="-1"><a class="header-anchor" href="#bridge-network-driver"><span>Bridge Network Driver</span></a></h2><p>The <code>bridge</code> networking driver is the first driver on our list. Itâ€™s simple to understand, simple to use, and simple to troubleshoot, which makes it a good networking choice for developers and those new to Docker. The <code>bridge</code> driver creates a private network internal to the host so containers on this network can communicate. External access is granted by exposing ports to containers. Docker secures the network by managing rules that block connectivity between different Docker networks.</p><p>Behind the scenes, the Docker Engine creates the necessary Linux bridges, internal interfaces, iptables rules, and host routes to make this connectivity possible. In the example highlighted below, a Docker bridge network is created and two containers are attached to it. With no extra configuration the Docker Engine does the necessary wiring, provides service discovery for the containers, and configures security rules to prevent communication to other networks. A built-in IPAM driver provides the container interfaces with private IP addresses from the subnet of the bridge network.</p><p>In the following examples, we use a fictitious app called <code>pets</code> comprised of a <code>web</code> and <code>db</code> container. Feel free to try it out on your own UCP or Swarm cluster. Your app will be accessible on <code> \`&lt;host-ip&gt;:8000\`.</code></p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">docker</span> network create <span class="token parameter variable">-d</span> bridge mybridge</span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--net</span> mybridge <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--name</span> db <span class="token punctuation">\\</span></span>
<span class="line">redis</span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--net</span> mybridge <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">-e</span> <span class="token assign-left variable">DB</span><span class="token operator">=</span>db <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">-p</span> <span class="token number">8000</span>:5000 <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--name</span> web <span class="token punctuation">\\</span></span>
<span class="line">chrch/web</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-3.png" alt="Docker Bridge Network Driver" tabindex="0" loading="lazy"><figcaption>Docker Bridge Network Driver</figcaption></figure><p>Our application is now being served on our host at port 8000. The Docker bridge is allowing <code>web</code> to communicate with <code>db</code> by its container name. The bridge driver does the service discovery for us automatically because they are on the same network. All of the port mappings, security rules, and pipework between Linux bridges is handled for us by the networking driver as containers are scheduled and rescheduled across a cluster.</p><p>The bridge driver is a local scope driver, which means it only provides service discovery, IPAM, and connectivity on a single host. Multi-host service discovery requires an external solution that can map containers to their host location. This is exactly what makes the <code>overlay</code> driver so great.</p><hr><h2 id="overlay-network-driver" tabindex="-1"><a class="header-anchor" href="#overlay-network-driver"><span>Overlay Network Driver</span></a></h2><p>The built-in Docker <code>overlay</code> network driver radically simplifies many of the complexities in multi-host networking. It is a swarm scope driver, which means that it operates across an entire Swarm or UCP cluster rather than individual hosts. With the <code>overlay</code> driver, multi-host networks are first-class citizens inside Docker without external provisioning or components. IPAM, service discovery, multi-host connectivity, encryption, and load balancing are built right in. For control, the <code>overlay</code> driver uses the encrypted Swarm control plane to manage large scale clusters at low convergence times.</p><p>The <code>overlay</code> driver utilizes an industry-standard VXLAN data plane that decouples the container network from the underlying physical network (the underlay). This has the advantage of providing maximum portability across various cloud and on-premises networks. Network policy, visibility, and security is controlled centrally through the Docker Universal Control Plane (UCP).</p><figure><img src="https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-1.png" alt="Docker Overlay Network driver" tabindex="0" loading="lazy"><figcaption>Docker Overlay Network driver</figcaption></figure><p>In this example we create an overlay network in UCP so we can connect our <code>web</code> and <code>db</code> containers when they are living on different hosts. Native DNS-based service discovery for services &amp; containers within an overlay network will ensure that <code>web</code> can resolve to <code>db</code> and vice-versa. We turned on encryption so that communication between our containers is secure by default. Furthermore, visibility and use of the network in UCP is restricted by the permissions label we use.</p><p>UCP will schedule services across the cluster and UCP will dynamically program the overlay network to provide connectivity to the containers wherever they are. When services are backed by multiple containers, VIP-based load balancing will distribute traffic across all of the containers.</p><p>Feel free to run this example against your UCP cluster with the following CLI commands:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">docker</span> network create <span class="token parameter variable">-d</span> overlay <span class="token parameter variable">--opt</span> encrypted pets-overlay </span>
<span class="line"><span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--network</span> pets-overlay <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--name</span> db <span class="token punctuation">\\</span></span>
<span class="line">redis </span>
<span class="line"><span class="token function">docker</span> <span class="token function">service</span> create <span class="token parameter variable">--network</span> pets-overlay <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">-p</span> <span class="token number">8000</span>:5000 <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">-e</span> <span class="token assign-left variable">DB</span><span class="token operator">=</span>db <span class="token punctuation">\\</span></span>
<span class="line"><span class="token parameter variable">--name</span> web <span class="token punctuation">\\</span></span>
<span class="line">chrch/web</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-4.png" alt="Docker networking" tabindex="0" loading="lazy"><figcaption>Docker networking</figcaption></figure><p>In this example we are still serving our web app on port 8000 but now we have deployed our application across different hosts. If we wanted to scale our <code>web</code> containers, Swarm &amp; UCP networking would load balance the traffic for us automatically.</p><p>The <code>overlay</code> driver is a feature-rich driver that handles much of the complexity and integration that organizations struggle with when crafting piecemeal solutions. It provides an out-of-the-box solution for many networking challenges and does so at scale.</p><hr><h2 id="macvlan-driver" tabindex="-1"><a class="header-anchor" href="#macvlan-driver"><span>MACVLAN Driver</span></a></h2><p>The <code>macvlan</code> driver is the newest built-in network driver and offers several unique characteristics. Itâ€™s a very lightweight driver, because rather than using any Linux bridging or port mapping, it connects container interfaces directly to host interfaces. Containers are addressed with routable IP addresses that are on the subnet of the external network.</p><p>As a result of routable IP addresses, containers communicate directly with resources that exist outside a Swarm cluster without the use of NAT and port mapping. This can aid in network visibility and troubleshooting. Additionally, the direct traffic path between containers and the host interface helps reduce latency. <code>macvlan</code> is a local scope network driver which is configured per-host. As a result, there are stricter dependencies between MACVLAN and external networks, which is both a constraint and an advantage that is different from <code>overlay</code> or <code>bridge</code>.</p><p>The <code>macvlan</code> driver uses the concept of a parent interface. This interface can be a host interface such as <code>eth0</code>, a sub-interface, or even a bonded host adaptor which bundles Ethernet interfaces into a single logical interface. A gateway address from the external network is required during MACVLAN network configuration, as a MACVLAN network is a L2 segment from the container to the network gateway. Like all Docker networks, MACVLAN networks are segmented from each other - providing access within a network, but not between networks.</p><p>The <code>macvlan</code> driver can be configured in different ways to achieve different results. In the below example we create two MACVLAN networks joined to different subinterfaces. This type of configuration can be used to extend multiple L2 VLANs through the host interface directly to containers. The VLAN default gateway exists in the external network.</p><figure><img src="https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-2.png" alt="Docker and macvlan" tabindex="0" loading="lazy"><figcaption>Docker and macvlan</figcaption></figure><p>The <code>db</code> and <code>web</code> containers are connected to different MACVLAN networks in this example. Each container resides on its respective external network with an external IP provided from that network. Using this design an operator can control network policy outside of the host and segment containers at L2. The containers could have also been placed in the same VLAN by configuring them on the same MACVLAN network. This just shows the amount of flexibility offered by each network driver.</p><p>Portability and choice are important tenants in the Docker philosophy. The Docker Container Network Model provides an open interface for vendors and the community to build network drivers. The complementary evolution of Docker and SDN technologies is providing more options and capabilities every day.</p>`,30)),m(" TODO: add ARTICLE CARD "),t(i,d(l({title:"Docker Networking Drivers - Details and Use Cases",desc:"Learn the details and proper use of Docker Network Drivers including Bridge, Overlay and MACVLan drivers to increase app portability and security.",link:"https://chanhi2000.github.io/bookshelf/docker.com/understanding-docker-networking-drivers-use-cases.html",logo:"https://docker.com/app/uploads/2024/02/cropped-docker-logo-favicon-192x192.png",background:"rgba(29,99,237,0.2)"})),null,16)])}const P=u(b,[["render",A]]),I=JSON.parse('{"path":"/docker.com/understanding-docker-networking-drivers-use-cases.html","title":"Docker Networking Drivers - Details and Use Cases","lang":"en-US","frontmatter":{"lang":"en-US","title":"Docker Networking Drivers - Details and Use Cases","description":"Article(s) > Docker Networking Drivers - Details and Use Cases","icon":"fa-brands fa-docker","category":["DevOps","Docker","Article(s)"],"tag":["blog","docker.com","devops","docker"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker Networking Drivers - Details and Use Cases\\",\\"image\\":[\\"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-3.png\\",\\"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-1.png\\",\\"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-4.png\\",\\"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-2.png\\"],\\"datePublished\\":\\"2016-12-20T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mark Church\\",\\"url\\":\\"https://docker.com/author/mark-church/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/docker.com/understanding-docker-networking-drivers-use-cases.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Docker Networking Drivers - Details and Use Cases"}],["meta",{"property":"og:description","content":"Article(s) > Docker Networking Drivers - Details and Use Cases"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-3.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-3.png"}],["meta",{"name":"twitter:image:alt","content":"Docker Networking Drivers - Details and Use Cases"}],["meta",{"property":"article:author","content":"Mark Church"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"docker.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2016-12-20T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Docker Networking Drivers - Details and Use Cases"},{"property":"og:description","content":"Docker Networking Drivers - Details and Use Cases"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/docker.com/understanding-docker-networking-drivers-use-cases.html"}]],"prev":"/devops/docker/articles/README.md","date":"2016-12-20T00:00:00.000Z","isOriginal":false,"author":[{"name":"Mark Church","url":"https://docker.com/author/mark-church/"}],"cover":"https://docker.com/app/uploads/2022/12/networking-drivers-use-cases-3.png"},"git":{},"readingTime":{"minutes":5.48,"words":1644},"filePathRelative":"docker.com/understanding-docker-networking-drivers-use-cases.md","copyright":{"author":"Mark Church"}}');export{P as comp,I as data};
