import{_ as k}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,d as s,f as a,b as r,a as v,t as y,n as u,g as d,w as t,e,r as p,o as b}from"./app-BItykJLQ.js";const f={},w={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},C={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},I={class:"table-of-contents"},T={href:"https://en.wikipedia.org/wiki/Two_Generals%27_Problem",target:"_blank",rel:"noopener noreferrer"};function x(m,n){const c=p("VPCard"),o=p("router-link"),h=p("SiteInfo"),l=p("VPIcon"),i=p("RouteLink");return b(),g("div",null,[s("h1",w,[s("a",C,[s("span",null,y(m.$frontmatter.title)+" ê´€ë ¨",1)])]),a(c,u(d({title:"C# > Article(s)",desc:"Article(s)",link:"/programming/cs/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",I,[s("ul",null,[s("li",null,[a(o,{to:"#what-can-go-wrong-when-publishing"},{default:t(()=>[...n[0]||(n[0]=[e("What Can Go Wrong When Publishing",-1)])]),_:1})]),s("li",null,[a(o,{to:"#publisher-side-idempotency-let-the-broker-handle-it"},{default:t(()=>[...n[1]||(n[1]=[e("Publisher-Side Idempotency (Let the Broker Handle It)",-1)])]),_:1})]),s("li",null,[a(o,{to:"#implementing-an-idempotent-consumer-in-net"},{default:t(()=>[...n[2]||(n[2]=[e("Implementing an Idempotent Consumer in .NET",-1)])]),_:1}),s("ul",null,[s("li",null,[a(o,{to:"#_1-the-idempotency-key"},{default:t(()=>[...n[3]||(n[3]=[e("1. The Idempotency Key",-1)])]),_:1})]),s("li",null,[a(o,{to:"#_2-atomic-side-effects-idempotency-record"},{default:t(()=>[...n[4]||(n[4]=[e("2. Atomic Side Effects + Idempotency Record",-1)])]),_:1})]),s("li",null,[a(o,{to:"#_3-handling-at-least-once-delivery"},{default:t(()=>[...n[5]||(n[5]=[e("3. Handling At-Least-Once Delivery",-1)])]),_:1})])])]),s("li",null,[a(o,{to:"#deterministic-vs-non-deterministic-handlers"},{default:t(()=>[...n[6]||(n[6]=[e("Deterministic vs Non-Deterministic Handlers",-1)])]),_:1}),s("ul",null,[s("li",null,[a(o,{to:"#_1-use-an-idempotency-key-in-the-external-call"},{default:t(()=>[...n[7]||(n[7]=[e("1. Use an Idempotency Key in the External Call",-1)])]),_:1})]),s("li",null,[a(o,{to:"#_2-store-the-intent-locally"},{default:t(()=>[...n[8]||(n[8]=[e("2. Store the Intent Locally",-1)])]),_:1})])])]),s("li",null,[a(o,{to:"#when-idempotent-consumer-isn-t-needed"},{default:t(()=>[...n[9]||(n[9]=[e("When Idempotent Consumer Isn't Needed",-1)])]),_:1})]),s("li",null,[a(o,{to:"#takeaway"},{default:t(()=>[...n[10]||(n[10]=[e("Takeaway",-1)])]),_:1})])])]),n[43]||(n[43]=s("hr",null,null,-1)),a(h,{name:"The Idempotent Consumer Pattern in .NET (And Why You Need It)",desc:"Distributed systems don't fail cleanly: they retry, duplicate, and occasionally fail. This article shows how to design resilient message handlers in .NET using broker-level idempotency and the Idempotent Consumer pattern, so your system stays consistent no matter how many times a message is delivered.",url:"https://milanjovanovic.tech/blog/the-idempotent-consumer-pattern-in-dotnet-and-why-you-need-it",logo:"https://milanjovanovic.tech/profile_favicon.png",preview:"https://milanjovanovic.tech/blog-covers/mnw_167.png"}),n[44]||(n[44]=s("p",null,"Distributed systems are unreliable by nature.",-1)),s("p",null,[n[11]||(n[11]=e("I always recommend reading about the ",-1)),a(l,{icon:"fa-brands fa-wikipedia-w"}),n[12]||(n[12]=s("a",{href:"https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing",target:"_blank",rel:"noopener noreferrer"},"Fallacies of Distributed Computing",-1)),n[13]||(n[13]=e(" to understand the common pitfalls.",-1))]),s("p",null,[n[15]||(n[15]=e("One of the key challenges is ensuring that messages are processed ",-1)),n[16]||(n[16]=s("strong",null,"exactly once",-1)),n[17]||(n[17]=e(". Theoretically, that's impossible to guarantee in most systems. I won't dive into the ",-1)),a(l,{icon:"fa-brands fa-wikipedia-w"}),n[18]||(n[18]=s("a",{href:"https://en.wikipedia.org/wiki/CAP_theorem",target:"_blank",rel:"noopener noreferrer"},"CAP theorem",-1)),n[19]||(n[19]=e(" or the ",-1)),s("a",T,[a(l,{icon:"fa-brands fa-wikipedia-w"}),n[14]||(n[14]=e("Two Generals Problem",-1))]),n[20]||(n[20]=e(" here, but suffice to say:",-1))]),n[45]||(n[45]=s("ul",null,[s("li",null,"Messages can arrive out of order"),s("li",null,"Messages can be duplicated"),s("li",null,"Deliveries can be delayed")],-1)),n[46]||(n[46]=s("p",null,"If you design your system assuming every message will be processed exactly once, you're setting yourself up for subtle data corruption.",-1)),s("p",null,[n[22]||(n[22]=e("But we can design our system to apply side effects ",-1)),n[23]||(n[23]=s("strong",null,"exactly once",-1)),n[24]||(n[24]=e(" using the ",-1)),a(i,{to:"/milanjovanovic.tech/idempotent-consumer-handling-duplicate-messages.html"},{default:t(()=>[...n[21]||(n[21]=[s("strong",null,"Idempotent Consumer",-1)])]),_:1}),n[25]||(n[25]=e(" pattern.",-1))]),n[47]||(n[47]=r(`<p>Let&#39;s unpack what can go wrong, how brokers help with idempotency, and how you can build an idempotent consumer in .NET.</p><hr><h2 id="what-can-go-wrong-when-publishing" tabindex="-1"><a class="header-anchor" href="#what-can-go-wrong-when-publishing"><span>What Can Go Wrong When Publishing</span></a></h2><p>Let&#39;s say your service publishes an event when a new note is created:</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">await</span> publisher<span class="token punctuation">.</span><span class="token function">PublishAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">NoteCreated</span><span class="token punctuation">(</span>note<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> note<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> note<span class="token punctuation">.</span>Content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>We don&#39;t have to worry about the specific implementation of <code>publisher</code> or the message broker here. It could be RabbitMQ, SQS, Azure Service Bus, etc.</p><p>Now imagine:</p><ul><li>The publisher sends the message to the broker</li><li>The broker stores it and sends an ACK</li><li><strong>Network glitch</strong>: the ACK never reaches the producer</li><li>Producer times out and <strong>retries</strong> the publish</li><li>The broker now has two <code>NoteCreated</code> events</li></ul><p>From the producer&#39;s perspective, it &quot;fixed&quot; a timeout. But from the consumer&#39;s perspective, it received two events for the same note creation.</p><figure><img src="https://milanjovanovic.tech/blogs/mnw_167/distributed_messaging_with_error.png?imwidth=3840" alt="Distributed messaging with network error causing duplicate messages." tabindex="0" loading="lazy"><figcaption>Distributed messaging with network error causing duplicate messages.</figcaption></figure><p>And that&#39;s just one failure path. You can also get duplicates from:</p><ul><li>Broker redeliveries</li><li>Consumer failures + retries</li></ul><p>So even if you do everything &quot;right&quot; on the publisher, the <strong>consumer still has to be defensive</strong>.</p><hr><h2 id="publisher-side-idempotency-let-the-broker-handle-it" tabindex="-1"><a class="header-anchor" href="#publisher-side-idempotency-let-the-broker-handle-it"><span>Publisher-Side Idempotency (Let the Broker Handle It)</span></a></h2>`,15)),s("p",null,[n[28]||(n[28]=e("Many message brokers already support idempotent publishing via message deduplication if you include a unique message ID. ",-1)),a(i,{to:"/milanjovanovic.tech/messaging-made-easy-with-azure-service-bus.html"},{default:t(()=>[...n[26]||(n[26]=[s("strong",null,"Azure Service Bus",-1)])]),_:1}),n[29]||(n[29]=e(", for instance, can detect duplicates and ignore re-publishes for the same message ID within a configured window. ",-1)),a(i,{to:"/milanjovanovic.tech/complete-guide-to-amazon-sqs-and-amazon-sns-with-masstransit.html"},{default:t(()=>[...n[27]||(n[27]=[s("strong",null,"Amazon SQS",-1)])]),_:1}),n[30]||(n[30]=e(" and other brokers also offer similar guarantees.",-1))]),n[48]||(n[48]=r(`<p>You don&#39;t need to reinvent this logic in your application. The key is to assign each message a stable identifier that uniquely represents the logical event you&#39;re sending.</p><p>For example, when publishing a <code>NoteCreated</code> event:</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token class-name"><span class="token keyword">var</span></span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">NoteCreated</span><span class="token punctuation">(</span>note<span class="token punctuation">.</span>Id<span class="token punctuation">,</span> note<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> note<span class="token punctuation">.</span>Content<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    MessageId <span class="token operator">=</span> Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// or you can use note.Id</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">await</span> publisher<span class="token punctuation">.</span><span class="token function">PublishAsync</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If the network drops after you send the message, your app might retry. But when the broker sees the same <code>MessageId</code>, it knows this is a duplicate and safely discards it. You get deduplication without any custom tracking tables or extra state in your service.</p><p>This broker-level idempotency solves a large class of <strong>producer-side issues</strong>: network retries, transient failures, and duplicated publishes.</p><p>What it doesn&#39;t handle are <strong>consumer retries</strong>, which happen when messages are redelivered or your service crashes mid-processing.</p><p>That&#39;s where the idempotent consumer pattern comes in.</p><hr><h2 id="implementing-an-idempotent-consumer-in-net" tabindex="-1"><a class="header-anchor" href="#implementing-an-idempotent-consumer-in-net"><span>Implementing an Idempotent Consumer in .NET</span></a></h2><p>Here&#39;s an example of an idempotent consumer for a <code>NoteCreated</code> event:.</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">NoteCreatedConsumer</span><span class="token punctuation">(</span></span>
<span class="line">    <span class="token class-name">TagsDbContext</span> dbContext<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">HybridCache</span> hybridCache<span class="token punctuation">,</span></span>
<span class="line">    <span class="token class-name">ILogger<span class="token punctuation">&lt;</span>Program<span class="token punctuation">&gt;</span></span> logger<span class="token punctuation">)</span> <span class="token punctuation">:</span> IConsumer<span class="token operator">&lt;</span>NoteCreated<span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token return-type class-name">Task</span> <span class="token function">ConsumeAsync</span><span class="token punctuation">(</span><span class="token class-name">ConsumeContext<span class="token punctuation">&lt;</span>NoteCreated<span class="token punctuation">&gt;</span></span> context<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 1. Check if we&#39;ve already processed this message for this consumer</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">await</span> dbContext<span class="token punctuation">.</span>MessageConsumers<span class="token punctuation">.</span><span class="token function">AnyAsync</span><span class="token punctuation">(</span>c <span class="token operator">=&gt;</span></span>
<span class="line">                c<span class="token punctuation">.</span>MessageId <span class="token operator">==</span> context<span class="token punctuation">.</span>MessageId <span class="token operator">&amp;&amp;</span></span>
<span class="line">                c<span class="token punctuation">.</span>ConsumerName <span class="token operator">==</span> <span class="token keyword">nameof</span><span class="token punctuation">(</span>NoteCreatedConsumer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">        <span class="token class-name"><span class="token keyword">var</span></span> request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">AnalyzeNoteRequest</span><span class="token punctuation">(</span></span>
<span class="line">            context<span class="token punctuation">.</span>Message<span class="token punctuation">.</span>NoteId<span class="token punctuation">,</span></span>
<span class="line">            context<span class="token punctuation">.</span>Message<span class="token punctuation">.</span>Title<span class="token punctuation">,</span></span>
<span class="line">            context<span class="token punctuation">.</span>Message<span class="token punctuation">.</span>Content<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token keyword">try</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">using</span> <span class="token class-name"><span class="token keyword">var</span></span> transaction <span class="token operator">=</span> <span class="token keyword">await</span> dbContext<span class="token punctuation">.</span>Database<span class="token punctuation">.</span><span class="token function">BeginTransactionAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 2. Deterministic processing: derive tags from note content</span></span>
<span class="line">            <span class="token class-name"><span class="token keyword">var</span></span> tags <span class="token operator">=</span> <span class="token function">AnalyzeContentForTags</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>Title<span class="token punctuation">,</span> request<span class="token punctuation">.</span>Content<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 3. Persist tags</span></span>
<span class="line">            <span class="token class-name"><span class="token keyword">var</span></span> tagEntities <span class="token operator">=</span> tags<span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span><span class="token function">ProjectToTagEntity</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span>NoteId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            dbContext<span class="token punctuation">.</span>Tags<span class="token punctuation">.</span><span class="token function">AddRange</span><span class="token punctuation">(</span>tagEntities<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 4. Record that this message was processed</span></span>
<span class="line">            dbContext<span class="token punctuation">.</span>MessageConsumers<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">MessageConsumer</span></span>
<span class="line">            <span class="token punctuation">{</span></span>
<span class="line">                MessageId <span class="token operator">=</span> context<span class="token punctuation">.</span>MessageId<span class="token punctuation">,</span></span>
<span class="line">                ConsumerName <span class="token operator">=</span> <span class="token keyword">nameof</span><span class="token punctuation">(</span>NoteCreatedConsumer<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">                ConsumedAtUtc <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>UtcNow</span>
<span class="line">            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token keyword">await</span> dbContext<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">await</span> transaction<span class="token punctuation">.</span><span class="token function">CommitAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment">// 5. Update cache</span></span>
<span class="line">            <span class="token keyword">await</span> <span class="token function">CacheNoteTags</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> tags<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            logger<span class="token punctuation">.</span><span class="token function">LogError</span><span class="token punctuation">(</span>ex<span class="token punctuation">,</span> <span class="token string">&quot;Error analyzing note {NoteId}&quot;</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>NoteId<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">throw</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is a typical idempotent consumer with a few important details.</p><h3 id="_1-the-idempotency-key" tabindex="-1"><a class="header-anchor" href="#_1-the-idempotency-key"><span>1. The Idempotency Key</span></a></h3><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">await</span> dbContext<span class="token punctuation">.</span>MessageConsumers<span class="token punctuation">.</span><span class="token function">AnyAsync</span><span class="token punctuation">(</span>c <span class="token operator">=&gt;</span></span>
<span class="line">        c<span class="token punctuation">.</span>MessageId <span class="token operator">==</span> context<span class="token punctuation">.</span>MessageId <span class="token operator">&amp;&amp;</span></span>
<span class="line">        c<span class="token punctuation">.</span>ConsumerName <span class="token operator">==</span> <span class="token keyword">nameof</span><span class="token punctuation">(</span>NoteCreatedConsumer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You use:</p><ul><li><code>MessageId</code> from the transport (<code>context.MessageId</code>)</li><li><code>ConsumerName</code> (so multiple consumers can safely process the same message)</li></ul><p>If a duplicate message arrives, you short-circuit and do nothing.</p>`,17)),s("p",null,[n[32]||(n[32]=e("What's also important here is having a ",-1)),n[33]||(n[33]=s("strong",null,"unique constraint",-1)),n[34]||(n[34]=e(" on ",-1)),n[35]||(n[35]=s("code",null,"(MessageId, ConsumerName)",-1)),n[36]||(n[36]=e(" in the ",-1)),n[37]||(n[37]=s("code",null,"MessageConsumers",-1)),n[38]||(n[38]=e(" table to prevent ",-1)),a(i,{to:"/milanjovanovic.tech/solving-race-conditions-with-ef-core-optimistic-locking.html"},{default:t(()=>[...n[31]||(n[31]=[s("strong",null,"race conditions",-1)])]),_:1}),n[39]||(n[39]=e(". So even if you have concurrent processing of the same message, only one will succeed in inserting the record.",-1))]),n[49]||(n[49]=r(`<h3 id="_2-atomic-side-effects-idempotency-record" tabindex="-1"><a class="header-anchor" href="#_2-atomic-side-effects-idempotency-record"><span>2. Atomic Side Effects + Idempotency Record</span></a></h3><p>The processing and storing the message consumer record happen <strong>in the same transaction</strong>:</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">using</span> <span class="token class-name"><span class="token keyword">var</span></span> transaction <span class="token operator">=</span> <span class="token keyword">await</span> dbContext<span class="token punctuation">.</span>Database<span class="token punctuation">.</span><span class="token function">BeginTransactionAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// write tags</span></span>
<span class="line">dbContext<span class="token punctuation">.</span>Tags<span class="token punctuation">.</span><span class="token function">AddRange</span><span class="token punctuation">(</span>tagEntities<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// write message-consumer record</span></span>
<span class="line">dbContext<span class="token punctuation">.</span>MessageConsumers<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">MessageConsumer</span> <span class="token punctuation">{</span> <span class="token range operator">..</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">await</span> dbContext<span class="token punctuation">.</span><span class="token function">SaveChangesAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">await</span> transaction<span class="token punctuation">.</span><span class="token function">CommitAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container important"><p class="hint-container-title">Why this matters:</p><ul><li>If processing fails, there is no entry in <code>MessageConsumers</code>, so the message can be retried</li><li>If processing succeeds, both the tags and the <code>MessageConsumer</code> row are committed together</li><li>You never end up in a state where the work is done but the message is not marked as processed, or vice versa</li></ul></div><p>This is the core of idempotency:</p><blockquote><p>Do this work exactly once per message ID, even under retries.</p></blockquote><h3 id="_3-handling-at-least-once-delivery" tabindex="-1"><a class="header-anchor" href="#_3-handling-at-least-once-delivery"><span>3. Handling At-Least-Once Delivery</span></a></h3><p>Most realistic setups are <strong>at-least-once</strong>:</p><ul><li>Consumer processes message</li><li>ACK fails / times out</li><li>Broker redelivers</li><li>Your code runs again</li></ul><p>With this pattern, the second run hits the <code>MessageConsumers</code> table and returns early.</p><p>No duplicate side effects.</p><p>This works, except for one caveat...</p><hr><h2 id="deterministic-vs-non-deterministic-handlers" tabindex="-1"><a class="header-anchor" href="#deterministic-vs-non-deterministic-handlers"><span>Deterministic vs Non-Deterministic Handlers</span></a></h2><p>What happens when your handler calls something <em>outside</em> the database? An email API, a payment gateway, or a background job queue?</p><p>These are all common side effects that need to be idempotent too.</p><p>Those calls sit outside your transaction boundary. Your database might commit successfully, but if the network hiccups before the external service responds, you can&#39;t tell if the action happened or not. On retry, your consumer might send another email or charge the credit card twice.</p><p>You&#39;ve now crossed into the messy territory of non-deterministic handlers: operations that can&#39;t be repeated safely.</p><p>There are two main strategies to deal with this.</p><h3 id="_1-use-an-idempotency-key-in-the-external-call" tabindex="-1"><a class="header-anchor" href="#_1-use-an-idempotency-key-in-the-external-call"><span>1. Use an Idempotency Key in the External Call</span></a></h3><p>If the external service supports it, pass a stable identifier, like the message&#39;s <code>MessageId</code> with every request. Many APIs, including payment processors and email platforms, let you specify an idempotency key header. The service ensures that identical requests with the same key only execute once.</p><div class="hint-container tip"><p class="hint-container-title">For example:</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token keyword">await</span> emailService<span class="token punctuation">.</span><span class="token function">SendAsync</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token constructor-invocation class-name">SendEmailRequest</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    To <span class="token operator">=</span> user<span class="token punctuation">.</span>Email<span class="token punctuation">,</span></span>
<span class="line">    Subject <span class="token operator">=</span> <span class="token string">&quot;Welcome!&quot;</span><span class="token punctuation">,</span></span>
<span class="line">    Body <span class="token operator">=</span> <span class="token string">&quot;Thanks for signing up.&quot;</span><span class="token punctuation">,</span></span>
<span class="line">    IdempotencyKey <span class="token operator">=</span> context<span class="token punctuation">.</span>MessageId</span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>Even if the request is retried, the provider will recognize the key and skip the duplicate. This is the simplest and most reliable approach, if your external dependency supports it.</p><h3 id="_2-store-the-intent-locally" tabindex="-1"><a class="header-anchor" href="#_2-store-the-intent-locally"><span>2. Store the Intent Locally</span></a></h3><p>If the external service doesn&#39;t support idempotency keys, you can simulate it. Store a <strong>record of the intended action</strong> in your database before calling the external system. For example, create a <code>PendingEmails</code> table that records which messages should be sent, keyed by message ID or user ID.</p><p>A background process can later read these pending records and perform the action once. This makes the process deterministic, but at the cost of more complexity, extra tables, and background workers. It&#39;s often overengineering unless the side effect is critical or irreversible, like payments or account provisioning.</p><p>The trade-off comes down to confidence. If repeating the action has real consequences, introduce idempotency explicitly. If not, retrying the operation might be acceptable.</p><hr><h2 id="when-idempotent-consumer-isn-t-needed" tabindex="-1"><a class="header-anchor" href="#when-idempotent-consumer-isn-t-needed"><span>When Idempotent Consumer Isn&#39;t Needed</span></a></h2><p>Not every consumer needs the overhead of idempotency checks. If your operation is already naturally idempotent, you can often skip the extra table and transaction logic.</p><p>Updating a projection, setting a status flag, or refreshing a cache are all examples of deterministic actions that can safely run multiple times. For instance, &quot;set user&#39;s status to Active&quot; or &quot;rebuild the read model&quot; are operations that overwrite state rather than append to it.</p><p>Some handlers also use precondition checks to avoid duplication. If the handler updates an entity, it can first check whether that entity is already in the desired state and return early. That simple guard clause can be enough.</p><p>Don&#39;t blindly apply the <strong>Idempotent Consumer</strong> pattern everywhere. Apply it where it protects you from real harm, where duplicate processing causes financial or data inconsistencies.</p><p>For everything else, <strong>simpler is better</strong>.</p><hr><h2 id="takeaway" tabindex="-1"><a class="header-anchor" href="#takeaway"><span>Takeaway</span></a></h2><p>Distributed systems are unpredictable. Retries, duplicates, and partial failures are part of normal operation. You can&#39;t avoid them, but you can design your system so they don&#39;t impact you as much.</p><p>Use your broker&#39;s built-in <strong>message deduplication</strong> to prevent duplicates from the producer side. For the consumer side, apply the <strong>Idempotent Consumer</strong> pattern to ensure side effects happen once, even under retries. Keep the record of processed messages and the actual side effect in the same transaction.</p><p>Not every message handler needs this. If your consumer is naturally idempotent or can short-circuit with a simple precondition, skip the extra complexity. But for anything that modifies persistent state or calls external systems, idempotency isn&#39;t optional, it&#39;s the only way to keep your system consistent.</p><p>Build your consumers to tolerate retries. And your distributed system will be that much more reliable. The interesting part is that once you understand this principle, you start seeing it everywhere in real-world systems.</p>`,40)),s("p",null,[n[41]||(n[41]=e("If you want to dive deeper into messaging patterns and learn how this is implemented in a production-grade system, check out my ",-1)),a(i,{to:"/milanjovanovic.tech/modular-monolith-architecture/"},{default:t(()=>[...n[40]||(n[40]=[s("strong",null,"Modular Monolith Architecture",-1)])]),_:1}),n[42]||(n[42]=e(" course. We'll build a full-featured application with distributed messaging, CQRS, and DDD patterns from scratch.",-1))]),n[50]||(n[50]=s("p",null,"Hope this was helpful.",-1)),v(" TODO: add ARTICLE CARD "),a(c,u(d({title:"The Idempotent Consumer Pattern in .NET (And Why You Need It)",desc:"Distributed systems don't fail cleanly: they retry, duplicate, and occasionally fail. This article shows how to design resilient message handlers in .NET using broker-level idempotency and the Idempotent Consumer pattern, so your system stays consistent no matter how many times a message is delivered.",link:"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/the-idempotent-consumer-pattern-in-dotnet-and-why-you-need-it.html",logo:"https://milanjovanovic.tech/profile_favicon.png",background:"rgba(79,70,229,0.2)"})),null,16)])}const M=k(f,[["render",x]]),P=JSON.parse('{"path":"/milanjovanovic.tech/the-idempotent-consumer-pattern-in-dotnet-and-why-you-need-it.html","title":"The Idempotent Consumer Pattern in .NET (And Why You Need It)","lang":"en-US","frontmatter":{"lang":"en-US","title":"The Idempotent Consumer Pattern in .NET (And Why You Need It)","description":"Article(s) > The Idempotent Consumer Pattern in .NET (And Why You Need It)","icon":"iconfont icon-csharp","category":["C#","DotNet","Article(s)"],"tag":["blog","milanjovanovic.tech","cs","c#","csharp","dotnet"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"The Idempotent Consumer Pattern in .NET (And Why You Need It)\\",\\"image\\":[\\"https://milanjovanovic.tech/blogs/mnw_167/distributed_messaging_with_error.png?imwidth=3840\\"],\\"datePublished\\":\\"2025-11-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Milan JovanoviÄ‡\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/the-idempotent-consumer-pattern-in-dotnet-and-why-you-need-it.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"The Idempotent Consumer Pattern in .NET (And Why You Need It)"}],["meta",{"property":"og:description","content":"Article(s) > The Idempotent Consumer Pattern in .NET (And Why You Need It)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://milanjovanovic.tech/blog-covers/mnw_167.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://milanjovanovic.tech/blog-covers/mnw_167.png"}],["meta",{"name":"twitter:image:alt","content":"The Idempotent Consumer Pattern in .NET (And Why You Need It)"}],["meta",{"property":"article:author","content":"Milan JovanoviÄ‡"}],["meta",{"property":"article:tag","content":"dotnet"}],["meta",{"property":"article:tag","content":"csharp"}],["meta",{"property":"article:tag","content":"c#"}],["meta",{"property":"article:tag","content":"cs"}],["meta",{"property":"article:tag","content":"milanjovanovic.tech"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-11-08T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > The Idempotent Consumer Pattern in .NET (And Why You Need It)"},{"property":"og:description","content":"The Idempotent Consumer Pattern in .NET (And Why You Need It)"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/the-idempotent-consumer-pattern-in-dotnet-and-why-you-need-it.html"}]],"prev":"/programming/cs/articles/README.md","date":"2025-11-08T00:00:00.000Z","isOriginal":false,"author":"Milan JovanoviÄ‡","cover":"https://milanjovanovic.tech/blog-covers/mnw_167.png"},"git":{},"readingTime":{"minutes":6.61,"words":1984},"filePathRelative":"milanjovanovic.tech/the-idempotent-consumer-pattern-in-dotnet-and-why-you-need-it.md","copyright":{"author":"Milan JovanoviÄ‡"}}');export{M as comp,P as data};
