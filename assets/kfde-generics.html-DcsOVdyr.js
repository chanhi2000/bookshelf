import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,d as s,f as a,b as o,a as y,t as f,n as u,g as d,w as i,e,r as l,o as v}from"./app-BVguHYKu.js";const b={},w={id:"frontmatter-title-관련",tabindex:"-1"},T={class:"header-anchor",href:"#frontmatter-title-관련"},x={class:"table-of-contents"},I={class:"hint-container note"},A={href:"https://leanpub.com/effectivekotlin",target:"_blank",rel:"noopener noreferrer"},S={href:"https://amazon.com/Effective-Kotlin-Best-Practices-Developers-ebook/dp/B0CHBR5XPF/",target:"_blank",rel:"noopener noreferrer"};function L(k,n){const c=l("VPCard"),p=l("router-link"),m=l("SiteInfo"),r=l("VPIcon"),t=l("KotlinPlayground");return v(),g("div",null,[s("h1",w,[s("a",T,[s("span",null,f(k.$frontmatter.title)+" 관련",1)])]),a(c,u(d({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",x,[s("ul",null,[s("li",null,[a(p,{to:"#generic-functions"},{default:i(()=>n[0]||(n[0]=[e("Generic functions")])),_:1,__:[0]})]),s("li",null,[a(p,{to:"#generic-classes"},{default:i(()=>n[1]||(n[1]=[e("Generic classes")])),_:1,__:[1]})]),s("li",null,[a(p,{to:"#generic-classes-and-nullability"},{default:i(()=>n[2]||(n[2]=[e("Generic classes and nullability")])),_:1,__:[2]})]),s("li",null,[a(p,{to:"#generic-interfaces"},{default:i(()=>n[3]||(n[3]=[e("Generic interfaces")])),_:1,__:[3]})]),s("li",null,[a(p,{to:"#type-parameters-and-inheritance"},{default:i(()=>n[4]||(n[4]=[e("Type parameters and inheritance")])),_:1,__:[4]})]),s("li",null,[a(p,{to:"#type-erasure"},{default:i(()=>n[5]||(n[5]=[e("Type erasure")])),_:1,__:[5]})]),s("li",null,[a(p,{to:"#generic-constraints"},{default:i(()=>n[6]||(n[6]=[e("Generic constraints")])),_:1,__:[6]})]),s("li",null,[a(p,{to:"#star-projection"},{default:i(()=>n[7]||(n[7]=[e("Star projection")])),_:1,__:[7]})]),s("li",null,[a(p,{to:"#underscore-operator-for-type-arguments"},{default:i(()=>n[8]||(n[8]=[e("Underscore operator for type arguments")])),_:1,__:[8]})]),s("li",null,[a(p,{to:"#summary"},{default:i(()=>n[9]||(n[9]=[e("Summary")])),_:1,__:[9]})])])]),n[18]||(n[18]=s("hr",null,null,-1)),a(m,{name:"Generics in Kotlin",desc:"The essence of how generics work in Kotlin.",url:"https://kt.academy/article/kfde-generics",logo:"https://kt.academy/logo.png",preview:"https://marcinmoskala.com/kotlin_essentials_book/promotion/generics.jpg"}),s("div",I,[n[17]||(n[17]=s("p",{class:"hint-container-title"},"Note",-1)),s("p",null,[n[12]||(n[12]=e("This is a chapter from the book ")),n[13]||(n[13]=s("a",{href:"/book/effectivekotlin",target:"_blank",rel:"noopener noreferrer"},"Effective Kotlin",-1)),n[14]||(n[14]=e(". You can find it on ")),s("a",A,[a(r,{icon:"fas fa-globe"}),n[10]||(n[10]=e("LeanPub"))]),n[15]||(n[15]=e(" or ")),s("a",S,[a(r,{icon:"fa-brands fa-amazon"}),n[11]||(n[11]=e("Amazon"))]),n[16]||(n[16]=e("."))])]),n[19]||(n[19]=o(`<p>In the early days of Java, it was designed such that all lists had the same type <code>List</code>, instead of specific lists with specific parameter types, like <code>List&lt;String&gt;</code> or <code>List&lt;Int&gt;</code>. The <code>List</code> type in Java accepts all kinds of values; when you ask for a value at a certain position, the result type is <code>Object</code> (which, in Java, is the supertype of all the types).</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java"><pre><code class="language-java"><span class="line"><span class="token comment">// Java</span></span>
<span class="line"><span class="token class-name">List</span> names <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Alex&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Ben&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">names<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this is incorrect, but compiles</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> names<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> names<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// exception at i==2</span></span>
<span class="line">  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Such lists are hard to use. We much prefer to have a list with specified types of elements. Only then can we be sure that our list contains elements of the correct type, and only then do we not need to explicitly cast these elements when we get them from a list. This was one of the main reasons Java introduced generics in version 5. In Kotlin, we do not have this problem because it was designed with generics support from the beginning, and all lists are generic, so they must specify what kinds of elements they accept. Generics are an important feature of most modern programming languages; so, in this chapter, we will discuss what they are and how we use them in Kotlin.</p><p>In Kotlin, we have three kinds of generic elements:</p><ul><li>generic functions,</li><li>generic classes,</li><li>generic interfaces.</li></ul><p>Let&#39;s discuss them one by one.</p><hr><h2 id="generic-functions" tabindex="-1"><a class="header-anchor" href="#generic-functions"><span>Generic functions</span></a></h2><p>Just as we can pass an argument value to a parameter, we can pass a type as a <strong>type argument</strong>. For this, a function needs to define one or more type parameters inside angle brackets immediately after the <code>fun</code> keyword. By convention, type parameter names are capitalized. When a function defines a type parameter, we have to specify the type arguments when calling this function. The type parameter is a placeholder for a concrete type; the type argument is the actual type that is used when a function is called. To specify type arguments explicitly, we also use angle brackets.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// T is type parameter</span></span>
<span class="line">a<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Int is used here as a type argument</span></span>
<span class="line">a<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// String is used here as a type argument</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There is a popular practice that a single type argument is called <code>T</code> (from &quot;type&quot;); if there are multiple type arguments, they are called <code>T</code> with consecutive numbers. However, this practice is not a fixed rule, and there are many other conventions for naming type parameters.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">&gt;</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>When we call a generic function, all its type arguments must be clear for the Kotlin compiler. We can either specify them explicitly, or their values can be inferred from the compiler.</p>`,13)),a(t,{title:"Generic%20functions%20(1)",key:"2be01f4c",settings:"%7B%7D",files:"eJx9UMFqg0AQ/ZWHpxWkUY/BCrahECjkUG/dHlZdk4XNrOhaGkr/vbsqASHJaXfevDfz5n0G7UjIyhyChfj94zTXSYQyzVGtwBw1s1uUN4gNE67hiso96VokWehAPKM87A4s5DS3zkKRH88J2GxQXjoJ0R/HsyQ7YOhkrVolG8ifTqtaWX3xTJHtyeZ+iv9/2F7RcSmrbGfGSssIryfRX8E3bYSN8G6uxGXjnlrZ926DXa323ZolcTi5OkmoFc+07hY1OLX1zIbxoCgKHkRI4qd4mn9Xl3jh7DmCoGYCUw/Ozr34W2jILV6M0VKQS83F99jJQuXkMg++/gHuOI/2"}),n[20]||(n[20]=s("p",null,"So, how are these type parameters useful? We use them primarily to specify the relationship between the arguments and the result type. For instance, we can express that the result type is the same as an argument type or that we expect two arguments of the same type.",-1)),a(t,{title:"Generic%20functions%20(2)",key:"51ae4cd6",settings:"%7B%7D",files:"eJx9j01PhDAQhv/KG06QEFYOXoxrwt72oolysx4KDGsjnZJ+GI3xv1sgoGuih6btdJ53nj4mSo/GerwYPygurOTO6OJ+3gQL3u1QPxMsuTB4+PeRoBx8LDmpCXI5S3sKmnhpENwHxnV9A9Wlr3IIdIU6iwt7zNf/c9vBOHIeLoxk5wfTbwPcd/iietenMkbnaLYhggHVI10+UTC9+YMxA0lOswwSNDhCM0lMUVqqWMfHREW7+L6fvMuLDNHxyD1ZS10sr45H9mtvs/SKpKoqkZwDzQY8eKv4tDJtZDb1SIokh0gOv/H2D7z7iZc5yuLyHOw28DbohqzgT8HJ0xfk0aAy"}),n[21]||(n[21]=o('<p>Type parameters for functions are useful for the compiler since they allow it to check and correctly infer types; this makes our programs safer and makes programming more pleasurable for developers. Better parameter types and type suggestions protect us from using illegal operations and let our IDE give us better suggestions.</p><p>In the next book, <em>Functional Kotlin</em>, you will see plenty of generic function examples, especially for collection processing. Such functions are really important and useful. But, for now, let&#39;s get back to the initial motivation for introducing generics: let&#39;s talk about generic classes.</p><hr><h2 id="generic-classes" tabindex="-1"><a class="header-anchor" href="#generic-classes"><span>Generic classes</span></a></h2><p>We can make classes generic by adding a type parameter after the class name. Such a type parameter can be used all over the class body, especially to specify properties, parameters, and result types. A type parameter is specified when we define an instance, after which it remains unchanged. Thanks to that, when you declare <code>ValueWithHistory&lt;String&gt;</code> and then call <code>setValue</code> in the example below, you must use an object of type <code>String</code>; when you call <code>currentValue</code>, the result object will be typed as <code>String</code>; and when you call <code>history</code>, its result is of type <code>List&lt;String&gt;</code>. It’s the same for all other possible type arguments.</p>',5)),a(t,{title:"Generic%20classes%20(1)",key:"d5f18e04",settings:"%7B%7D",files:"eJxtkTFPwzAQhf/KKVMioBWwVQWpnRiQGIhgqDtEwcGW3EvkXIoqxH/nfHGaEDoktnzvfb573iWlK9oW3grX6XdL5sm2VPvTOn9MFQI03h4L0nAsPH+sWUGuMIPvedH0vhU884bd8ACOdy9VKrZMYXBUHUKrSW7rC8yLNABiyEJO2S3r5DxeAFeT0k/4Ddyy815jZGfMnUIGUaSE+thoPFTIPIVBdigsprEvZoDTRNqz9F9Or+QtfnJYyUYlPCXAcgm50UCnRkNdDVZ7IePoDaZetThno5LtiJsXb+/uM1jfSC7wVXfuA7AmKOtDY52MKz2HJ+idf6MJSJp2GJrre4mviuQwdSLcDjgz4s4hzkkmkCTXyWgDz4hcqd3mmqlqL3En+1+2Pthl"}),n[22]||(n[22]=o(`<p>The constructor type argument can be inferred. In the above example, we specified it explicitly, but we did not need to. This type can be inferred from the argument type.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> letter <span class="token operator">=</span> <span class="token function">ValueWithHistory</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;A&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// The type of letter is ValueWithHistory&lt;String&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Type arguments can also be inferred from variable types. Let&#39;s say that we want to use <code>Any</code> as a type argument. We can specify this by specifying the type of variable <code>letter</code> as <code>ValueWithHistory&lt;Any&gt;</code>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> letter<span class="token operator">:</span> ValueWithHistory<span class="token operator">&lt;</span>Any<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ValueWithHistory</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;A&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// The type of letter is ValueWithHistory&lt;Any&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>As I mentioned in the introduction to this chapter, the most important motivation for introducing generics was to make collections with certain types of elements. Consider the <code>ArrayList</code> class from the Standard Library (stdlib). It is generic, so when we create an instance from this class we need to specify the types of elements. Thanks to that, Kotlin protects us by expecting only values with accepted types to be added to the list, and Kotlin uses this type when we operate on the elements in the list.</p>`,5)),a(t,{title:"Generic%20classes%20(2)",key:"1acdaa60",settings:"%7B%7D",files:"eJyVkMEKwjAQRH9l6CkFUT9AhXr2pjfXQ8RUA+kq6VYQ8d/dVINFT0IOYXfmZSbbou4YjfVsStyJgasNCE7ExRZzVDHa28q3MltL9HxcmDKJ3oKxPRwMFRUVJSYTyMnBxmPXOBY0XSvYO5xryO3i8PL/mpf/mVW5UWU/1W1O6lsMU+YiViu8JUTbKdEuP5UBNlk/+IteJLCxfaYqjepzhAnwnEn6Ud8UXQ8pH07oObWP2qcaJQ9jmSQPYj3Exe4J4hd/8A=="}),n[23]||(n[23]=s("hr",null,null,-1)),n[24]||(n[24]=s("h2",{id:"generic-classes-and-nullability",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#generic-classes-and-nullability"},[s("span",null,"Generic classes and nullability")])],-1)),n[25]||(n[25]=s("p",null,[e("Notice that type arguments can be nullable, so we could create "),s("code",null,"ValueWithHistory<String?>"),e(". In such a case, the "),s("code",null,"null"),e(" value is a perfectly valid option.")],-1)),a(t,{title:"Generic%20classes%20and%20nullability",key:"205e83e8",settings:"%7B%7D",files:"eJx1kMsKwjAQRX9l6CoFUezaB925cCfowrgIGk0gxpJMhSL+u3m0saW6C5mTczP3mF1rDXcmNcnhRTXAkylQHJEbWMKeqZofJIqNtPgwzWKHRurbekV0rVTu+chOLccAE5qVNPs5SU9ChLO3wLk2husWymE2AxQcsKk4PK4OlBbaWP+4cidUmqhAemenFF+liN8d24S3bd00bdJ3isBTevTaCZST6KcnDw3LsS6sNIY1AxnpLW6n7HIZ1RFvUxVpmzjs8ofJIbVI21kHzN1o1FTxr6qi19Wb6uz0AX2CqIg="}),n[26]||(n[26]=o(`<p>Another thing is that when you use generic parameters inside classes or functions, you can make them nullable by adding a question mark. See the example below. The type <code>T</code> might or might not be nullable, depending on the type argument, but the type <code>T?</code> is always nullable. We can assign <code>null</code> to variables of the type <code>T?</code>. Nullable generic type parameter <code>T?</code> must be unpacked before using it as <code>T</code>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> Box<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">var</span> value<span class="token operator">:</span> T<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span></span>
<span class="line">  </span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">getOrThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T <span class="token operator">=</span> value<span class="token operator">!!</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The opposite can also be expressed. Since a generic type parameter might represent a nullable type (you can have <code>List&lt;Int?&gt;</code>), we might specify a definitely non-nullable variant of this type by adding <code>&amp; Any</code> after the type parameter. In the example below, the method <code>orThrow</code> can be invoked on any value, but it unpacks nullable types into non-nullable ones.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> T<span class="token punctuation">.</span><span class="token function">orThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> T &amp; Any <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">?:</span> <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">val</span> a<span class="token operator">:</span> Int<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Random<span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">42</span> <span class="token keyword">else</span> <span class="token keyword">null</span></span>
<span class="line">  <span class="token keyword">val</span> b<span class="token operator">:</span> Int <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">orThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">val</span> c<span class="token operator">:</span> Int <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">orThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>:::</p><hr><h2 id="generic-interfaces" tabindex="-1"><a class="header-anchor" href="#generic-interfaces"><span>Generic interfaces</span></a></h2><p>Interfaces can also be generic, which has similar consequences as for classes: the specified type parameters can be used inside the interface body as types for properties, parameters, and result types. A good example is the <code>List</code> interface.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">interface</span> List<span class="token operator">&lt;</span><span class="token keyword">out</span> E<span class="token operator">&gt;</span> <span class="token operator">:</span> Collection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">val</span> size<span class="token operator">:</span> Int</span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean</span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token operator">:</span> <span class="token annotation builtin">@UnsafeVariance</span> E<span class="token punctuation">)</span><span class="token operator">:</span> Boolean</span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">containsAll</span><span class="token punctuation">(</span></span>
<span class="line">    elements<span class="token operator">:</span> Collection<span class="token operator">&lt;</span><span class="token annotation builtin">@UnsafeVariance</span> E<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">)</span><span class="token operator">:</span> Boolean</span>
<span class="line">  <span class="token keyword">operator</span> <span class="token keyword">fun</span> <span class="token keyword">get</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> E</span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>element<span class="token operator">:</span> <span class="token annotation builtin">@UnsafeVariance</span> E<span class="token punctuation">)</span><span class="token operator">:</span> Int</span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>element<span class="token operator">:</span> <span class="token annotation builtin">@UnsafeVariance</span> E<span class="token punctuation">)</span><span class="token operator">:</span> Int</span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ListIterator<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">listIterator</span><span class="token punctuation">(</span>index<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> ListIterator<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">subList</span><span class="token punctuation">(</span>fromIndex<span class="token operator">:</span> Int<span class="token punctuation">,</span> toIndex<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">Note</p><p>The <code>out</code> modifier and the <code>UnsafeVariance</code> annotation will be explained in the book <em>Advanced Kotlin</em>.</p></div><figure><img src="https://marcinmoskala.com/kotlin_essentials_book/manuscript/resources/list_str_suggestions.png&amp;w=1200&amp;q=75" alt="For  type, methods like  expect an argument of type , and methods like  declare  as the result type." tabindex="0" loading="lazy"><figcaption>For <code>List&lt;String&gt;</code> type, methods like <code>contains</code> expect an argument of type <code>String</code>, and methods like <code>get</code> declare <code>String</code> as the result type.</figcaption></figure><figure><img src="https://marcinmoskala.com/kotlin_essentials_book/manuscript/resources/list_suggestions.png&amp;w=1200&amp;q=75" alt="For , methods like  can infer  as a lambda parameter." tabindex="0" loading="lazy"><figcaption>For <code>List&lt;String&gt;</code>, methods like <code>filter</code> can infer <code>String</code> as a lambda parameter.</figcaption></figure><p>Generic interfaces are inherited by classes. Let&#39;s say that we have a class <code>Dog</code> that inherits from <code>Consumer&lt;DogFood&gt;</code>, as shown in the snippet below. The interface <code>Consumer</code> expects a method <code>consume</code> with the type parameter <code>T</code>. This means our <code>Dog</code> must override the <code>consume</code> method with an argument of type <code>DogFood</code>. It must be <code>DogFood</code> because we implement the <code>Consumer&lt;DogFood&gt;</code> type, and the parameter type in the interface <code>Consumer</code> must match the type argument <code>DogFood</code>. Now, when you have an instance of <code>Dog</code>, you can up-cast it to <code>Consumer&lt;DogFood&gt;</code>.</p>`,13)),a(t,{title:"Generic%20interfaces",key:"0efa41d8",settings:"%7B%7D",files:"eJxtjrEOwjAMRH/llCn9hYqygNjYumGGqE2risRBCemC+HeSNBIMlSwP5/O7u4mFX9pPatA4OQ7Ran/oj3gTA1NkDJsoV2WibtE3xB/iwagQcHbzxbmR+E9A++PUe6W5VXu/jHoPW53N5gSePtUyLElcE/gBmzeJFA6k+DTEGWPVwrJ+JRRGNxcYurxl8We9xvm9cl3+Kkxx/wKkd13Y"}),n[27]||(n[27]=s("hr",null,null,-1)),n[28]||(n[28]=s("h2",{id:"type-parameters-and-inheritance",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#type-parameters-and-inheritance"},[s("span",null,"Type parameters and inheritance")])],-1)),n[29]||(n[29]=s("p",null,[e("Classes can inherit from open generic classes or implement generic interfaces; however, in both cases they must explicitly specify the type argument. Consider the snippet below. Class "),s("code",null,"A"),e(" inherits from "),s("code",null,"C<Int>"),e(" and implements "),s("code",null,"I<String>"),e(".")],-1)),a(t,{title:"Type%20parameters%20and%20inheritance%20(1)",key:"2c3369fe",settings:"%7B%7D",files:"eJxFjDEKhDAURK8yWCWwJ5BdQbay3u2MxSdECegoGm3EuxuUYPneY6bOxskRtpdlwff9Lww9g5tbsQ7VxXcrkcdeMRRKv2L5hdmzi9mwXYlBPJXGbghs0kPwQal0QpvGUUuSPn9+bn8YZs0JnRYt9g=="}),n[30]||(n[30]=o(`<p>It is actually quite common that a non-generic class inherits from a generic one. Consider <code>MessageListAdapter</code> presented below, which inherits from <code>ArrayAdapter&lt;String&gt;</code>.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="MessageListAdapter.kt"><span>MessageListAdapter.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> <span class="token function">MessageListAdapter</span><span class="token punctuation">(</span></span>
<span class="line">  context<span class="token operator">:</span> Context<span class="token punctuation">,</span></span>
<span class="line">  <span class="token keyword">val</span> values<span class="token operator">:</span> List<span class="token operator">&lt;</span>ClaimMessage<span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token operator">:</span> ArrayAdapter<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span><span class="token punctuation">(</span></span>
<span class="line">  context<span class="token punctuation">,</span></span>
<span class="line">  R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>row_messages<span class="token punctuation">,</span></span>
<span class="line">  values<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>title <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">toTypedArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">getView</span><span class="token punctuation">(</span></span>
<span class="line">    position<span class="token operator">:</span> Int<span class="token punctuation">,</span></span>
<span class="line">    convertView<span class="token operator">:</span> View<span class="token operator">?</span><span class="token punctuation">,</span></span>
<span class="line">    parent<span class="token operator">:</span> ViewGroup<span class="token operator">?</span></span>
<span class="line">  <span class="token punctuation">)</span><span class="token operator">:</span> View <span class="token punctuation">{</span></span>
<span class="line">     <span class="token comment">// ...</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>An even more common case is when one generic class or interface inherits from another generic class or interface and uses its type parameter as a type argument of the class it inherits from. In the snippet below, the class <code>A</code> is generic and uses its type parameter <code>T</code> as an argument for both <code>C</code> and <code>I</code>. This means that if you create <code>A&lt;Int&gt;</code>, you will be able to up-cast it to <code>C&lt;Int&gt;</code> or <code>I&lt;Int&gt;</code>. However, if you create <code>A&lt;String&gt;</code>, you will be able to up-cast it to <code>C&lt;String&gt;</code> or to <code>I&lt;String&gt;</code>.</p>`,3)),a(t,{title:"Type%20parameters%20and%20inheritance%20(2)",key:"72888ec1",settings:"%7B%7D",files:"eJxdjDELgzAUhP/KwymBLnYUK0inzO3WdHiEWAL2WjTtUvrfjfpEcbu77/hu2evtQa7lvqdzea0sAqLvGnaezNRnVqdMxXRR+iDIovmAnhygNP0s6MstcZHOBrGikwSlBbl8NAhjGUMazWZcNGmuy0vsAh6zSvJqO4629cH5YkzA7MDfIrsPOq9IpA=="}),n[31]||(n[31]=o(`<p>A good example is the collection hierarchy. An object of type <code>MutableList&lt;Int&gt;</code> implements <code>List&lt;Int&gt;</code>, which implements <code>Collection&lt;Int&gt;</code>, which implements <code>Iterable&lt;Int&gt;</code>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">interface</span> Iterable<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">interface</span> MutableIterable<span class="token operator">&lt;</span><span class="token keyword">out</span> T<span class="token operator">&gt;</span> <span class="token operator">:</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">interface</span> Collection<span class="token operator">&lt;</span><span class="token keyword">out</span> E<span class="token operator">&gt;</span> <span class="token operator">:</span> Iterable<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">interface</span> MutableCollection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token operator">:</span> Collection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span><span class="token punctuation">,</span>MutableIterable<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">interface</span> List<span class="token operator">&lt;</span><span class="token keyword">out</span> E<span class="token operator">&gt;</span> <span class="token operator">:</span> Collection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">interface</span> MutableList<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token operator">:</span> List<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span><span class="token punctuation">,</span> MutableCollection<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, a class does not need to use its type parameter when inheriting from a generic class or implementing a generic interface. Type parameters of parent and child classes are independent of one another and should not be confused, even if they have the same name.</p>`,3)),a(t,{title:"Type%20parameters%20and%20inheritance%20(3)",key:"09aa5afe",settings:"%7B%7D",files:"eJxFjDELwjAUhP/K0SkBl65FA6JLZ92MwzOkEohXaVMX8b/7sFa3e/d9705Vf49EyDKO2K2PzjOxxKGTENF+7pltNaNRpWVxxq4UHsqQeFXDs5uImyQai6cn8JAMqRv92vfTJUeHzT8buyhBlXlRudRLnbT+zX/Jy7M6vwHvWzX+"}),n[32]||(n[32]=o(`<hr><h2 id="type-erasure" tabindex="-1"><a class="header-anchor" href="#type-erasure"><span>Type erasure</span></a></h2><p>Generic types were added to Java for developers&#39; convenience, but they were never built into the JVM platform. All type arguments are lost when we compile Kotlin to JVM bytecode<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>. Under the hood, this means that <code>List&lt;String&gt;</code> becomes <code>List</code>, and <code>emptyList&lt;Double&gt;</code> becomes <code>emptyList</code>. The process of losing type arguments is known as <strong>type erasure</strong>. Due to this process, type parameters have some limitations compared to regular types. You cannot use them for <code>is</code> checks; you cannot reference them<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>; and you cannot use them as reified type arguments<sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>typeOf</span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">example</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">val</span> check <span class="token operator">=</span> a <span class="token keyword">is</span> T <span class="token comment">// ERROR</span></span>
<span class="line">  <span class="token keyword">val</span> ref <span class="token operator">=</span> T<span class="token operator">::</span><span class="token keyword">class</span> <span class="token comment">// ERROR</span></span>
<span class="line">  <span class="token keyword">val</span> type <span class="token operator">=</span> typeOf<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ERROR</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, Kotlin can overcome these limitations thanks to the use of inline functions with reified type arguments. This topic is covered in depth in the chapter <em>Inline functions</em> in the book <em>Functional Kotlin</em>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>typeOf</span>
<span class="line"></span>
<span class="line"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T<span class="token operator">&gt;</span> <span class="token function">example</span><span class="token punctuation">(</span>a<span class="token operator">:</span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">val</span> check <span class="token operator">=</span> a <span class="token keyword">is</span> T</span>
<span class="line">  <span class="token keyword">val</span> ref <span class="token operator">=</span> T<span class="token operator">::</span><span class="token keyword">class</span></span>
<span class="line">  <span class="token keyword">val</span> type <span class="token operator">=</span> typeOf<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="generic-constraints" tabindex="-1"><a class="header-anchor" href="#generic-constraints"><span>Generic constraints</span></a></h2><p>An important feature of type parameters is that they can be constrained to be a subtype of a concrete type. We set a constraint by placing a supertype after a colon. For instance, let&#39;s say that you implement the <code>maxOf</code> function, which returns the biggest of its arguments. To find the biggest one, the arguments need to be comparable. So, next to the type parameter, we can specify that we accept only types that are a subtype of <code>Comparable&lt;T&gt;</code>.</p>`,9)),a(t,{title:"Generic%20constraints%20(1)",key:"718dc721",settings:"%7B%7D",files:"eJxVT8FqwzAM/ZVHTjaENL2WNpBt911ym3dQirNp2HJw3DIY+/c6SUvbg4R4T+9J76NgP4aY8ENnqjyl7+qFv97skT05I0aGk2DfYYfX4EeK1Du775oGnn7fB0U7dCX63HUu/BkBok2nKOABitAc0GsQrJsseiP/N09PLEqvijM5eByunvf7yhTbuqprU+gSz/B2hfUsHyNLcqK8xmaDlcrwXEdH04R2HlfzVmWr3JbVORI7ShwENsYQy0WUmRY8QUJ6TN02y/vF5wVyXF7W"}),n[33]||(n[33]=o(`<p>Type parameter constraints are also used for generic classes. Consider the <code>ListAdapter</code> class below, which expects a type argument that is a subtype of <code>ItemAdapter</code>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> ListAdapter<span class="token operator">&lt;</span>T <span class="token operator">:</span> ItemAdapter<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token comment">/*...*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/*...*/</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>An important result of having a constraint is that instances of this type can use all the methods offered by this type. In this way, when <code>T</code> is constrained as a subtype of <code>Iterable&lt;Int&gt;</code>, we know that we can iterate over an instance of type <code>T</code>, and that elements returned by the iterator will be of type <code>Int</code>. When we are constrained to <code>Comparable&lt;T&gt;</code>, we know that this type can be compared with another instance of the same type. Another popular choice for a constraint is <code>Any</code>, which means that a type can be any non-nullable type.</p><p>In rare cases in which we might need to set more than one upper bound, we can use <code>where</code> to set more constraints. We add it after the class or function name, and we use it to specify more than one generic constraint for a single type.</p>`,4)),a(t,{title:"Generic%20constraints%20(2)",key:"08589b64",settings:"%7B%7D",files:"eJx9kE0LgkAQhv/K0Ckh7B4RiERIH4bsre2w6EhbOit+1CH676lrainBHmaGd97nnT1NJOWYhsJHsEjGIoInJ4CwIAgRg6nB6cWpE22UChjGCaYYdNIE80bJqeqXbFXPRG25AGbA41KuAINFw5nV9dBOr5iNY9v3wnDyI5FlYCt1k9gzHJqpO6apDLALqecA8zmYplnVpeOPULNGleVr4MVVtegR2H8P/UuxkPTRVOH0QVPDqPTuth2XKD203f3R2VnMcQ+w9jzXm+kcMgNS+df9NWZyfgN6HZxC"}),n[34]||(n[34]=o('<hr><h2 id="star-projection" tabindex="-1"><a class="header-anchor" href="#star-projection"><span>Star projection</span></a></h2><p>In some cases, we don’t want to specify a concrete type argument for a type. In these scenarios, we can use a star projection <code>*</code>, which accepts any type. There are two situations where this is useful. The first is when you check if a variable is a list. In this case, you should use the <code>is List&lt;*&gt;</code> check. Star projection should be used in such a case because of type erasure. If you used <code>List&lt;Int&gt;</code>, it would be compiled to <code>List</code> under the hood anyway. This means a list of strings would pass the <code>is List&lt;Int&gt;</code> check. Such a check would be confusing and is illegal in Kotlin. You must use <code>is List&lt;*&gt;</code> instead.</p>',3)),a(t,{title:"Star%20projection%20(1)",key:"5f97e856",settings:"%7B%7D",files:"eJx1yj0KwkAQBtCrfEy1K0IuoIJaCYIHcCy2SGBgMxsmE5uQu+evTvWa96VmULRJNESMrMA/ZWTpHdeNTxOY7kxnMD2Y4lo6E/WsYWvS4714Od0iqgpuQ314Xur7epa2k5xciqI2K8Y6sdJvBss9LvE="}),n[35]||(n[35]=o(`<p>Star projection can also be used for properties or parameters. You can use <code>List&lt;*&gt;</code> when you want to express that you want a list, no matter what the type of its elements. When you get elements from such a list, they are of type <code>Any?</code>, which is the supertype of all the types.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">printSize</span><span class="token punctuation">(</span>list<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span>size<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">printList</span><span class="token punctuation">(</span>list<span class="token operator">:</span> List<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token keyword">in</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// the type of e is Any?</span></span>
<span class="line">    <span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Star projection should not be confused with the <code>Any?</code> type argument. To see this, let&#39;s compare <code>MutableList&lt;Any?&gt;</code> and <code>MutableList&lt;*&gt;</code>. Both of these types declare <code>Any?</code> as generic result types. However, when elements are added, <code>MutableList&lt;Any?&gt;</code> accepts anything (<code>Any?</code>), but <code>MutableList&lt;*&gt;</code> accepts <code>Nothing</code>, so it does not accept any values.</p>`,3)),a(t,{title:"Star%20projection%20(2)",key:"07dbb1ab",settings:"%7B%7D",files:"eJyFjsuqwjAURX9l05FeLlea4cUHCs58QKfGQbRpG2hPpTkRRfx3E6W+QJyevfc6axVljlApQ50uTpKAvSpRxv+YO1abUs+M5f6YjqMhBqget2XWkdFYRt1208S+UMZ/mWkse1ivBy40+LjTqLMQG4sACgPfU2nqCRNPaKv6sNNb1ilUk7tKE9/GT7O7n3j1+/kqJ4Kc+CgnXuTEm9w0SZbJb4i+mi5qLgzlbdnWod9cI6qDivNfC8WoTF4wNhrOBo6FojtN0llStL4AoYmDvA=="}),n[36]||(n[36]=s("p",null,[e("When a star projection is used as an argument, it will be treated as "),s("code",null,"Any?"),e(" in all the out-positions (result types), and it will be treated as "),s("code",null,"Nothing"),e(" in all the in-positions (parameter types).")],-1)),n[37]||(n[37]=s("hr",null,null,-1)),n[38]||(n[38]=s("h2",{id:"underscore-operator-for-type-arguments",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#underscore-operator-for-type-arguments"},[s("span",null,"Underscore operator for type arguments")])],-1)),n[39]||(n[39]=s("p",null,[e("Type arguments can be either specified explicitly or inferred from the context. However, sometimes we want to specify one type argument and let the compiler infer the other. In such a case, we can use the underscore operator "),s("code",null,"_"),e(" as a type argument. This operator specifies that we want to infer a type argument.")],-1)),a(t,{title:"Underscore%20operator%20for%20type%20arguments",key:"56394eac",settings:"%7B%7D",files:"eJxtkEFLxDAQhf/Ko6dWyi4IXmS74HERXUEoiBEJdVoH22lIUtel7H83qRu9CCEMb75h3pvnjKVnIbSTYHNbwhK3TG+ot7jTJioX21XLvSdb636induJ81oayovrhAS4UgL8cJjBfvUZabBDjRO0+0OVKInbBs2SF5jjYIBh7GgcqqCbfZtHFVCZ6IFUBj+G+qanL5WVqaW7c+fy6ldr2B8Tfk8HPI32Q2WxW8RvvcY+hPVHQ9C2mwYSD5aWrA2ZD+zf8VpiDIgz1CyXSPactw9nh4vT/4+yCeOP3rJ023zZaELte8nTeBE9zDFVFeOUiI6rZPWkJLzs5RufaIVv"}),n[40]||(n[40]=s("hr",null,null,-1)),n[41]||(n[41]=s("h2",{id:"summary",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#summary"},[s("span",null,"Summary")])],-1)),n[42]||(n[42]=s("p",null,[e("For many developers, generics seem so hard and scary, but they are actually quite simple and intuitive. We can make an element generic by specifying its type parameter (or parameters). Such a type parameter can be used inside this element. This mechanism lets us generalize algorithms and classes so that they can be used with different types. It is good to understand how generics work, which is why this chapter has presented nearly all aspects of this mechanism. However, there are a few more, and we will get back to this topic in the book "),s("em",null,"Advanced Kotlin"),e(", where we still need to discuss variance modifiers ("),s("code",null,"out"),e(" and "),s("code",null,"in"),e(").")],-1)),y(" TODO: add ARTICLE CARD "),a(c,u(d({title:"Generics in Kotlin",desc:"The essence of how generics work in Kotlin.",link:"https://chanhi2000.github.io/bookshelf/kt.academy/kfde-generics.html",logo:"https://kt.academy/logo.png",background:"rgba(243,139,49,0.2)"})),null,16),n[43]||(n[43]=o('<hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p>I use JVM as a reference because it is the most popular target for Kotlin, but also because it was the first one, so many Kotlin mechanisms were designed for it. However, regarding a lack of support for type arguments, other platforms are not better. For example, JavaScript does not support types at all. <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p>Class and type references are explained in the book <em>Advanced Kotlin</em>. <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>Reified type arguments are explained in the book <em>Functional Kotlin</em>. <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li></ol></section>',2))])}const V=h(b,[["render",L]]),J=JSON.parse('{"path":"/kt.academy/kfde-generics.html","title":"Generics in Kotlin","lang":"en-US","frontmatter":{"lang":"en-US","title":"Generics in Kotlin","description":"Article(s) > Generics in Kotlin","icon":"iconfont icon-kotlin","category":["Java","Kotlin","Article(s)"],"tag":["blog","kt.academy","java","kotlin","generic"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Generics in Kotlin\\",\\"image\\":[\\"https://marcinmoskala.com/kotlin_essentials_book/manuscript/resources/list_str_suggestions.png&w=1200&q=75\\",\\"https://marcinmoskala.com/kotlin_essentials_book/manuscript/resources/list_suggestions.png&w=1200&q=75\\"],\\"datePublished\\":\\"2024-03-18T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Marcin Moskała\\",\\"url\\":\\"https://kt.academy/user/marcinmoskala\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/kfde-generics.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Generics in Kotlin"}],["meta",{"property":"og:description","content":"Article(s) > Generics in Kotlin"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://marcinmoskala.com/kotlin_essentials_book/promotion/generics.jpg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://marcinmoskala.com/kotlin_essentials_book/promotion/generics.jpg"}],["meta",{"name":"twitter:image:alt","content":"Generics in Kotlin"}],["meta",{"property":"article:author","content":"Marcin Moskała"}],["meta",{"property":"article:tag","content":"generic"}],["meta",{"property":"article:tag","content":"kotlin"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"kt.academy"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-03-18T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Generics in Kotlin"},{"property":"og:description","content":"Generics in Kotlin"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/kfde-generics.html"}]],"prev":"/programming/java/articles/README.md","date":"2024-03-18T00:00:00.000Z","isOriginal":false,"author":[{"name":"Marcin Moskała","url":"https://kt.academy/user/marcinmoskala"}],"cover":"https://marcinmoskala.com/kotlin_essentials_book/promotion/generics.jpg"},"git":{},"readingTime":{"minutes":12.62,"words":3787},"filePathRelative":"kt.academy/kfde-generics.md","copyright":{"author":"Marcin Moskała"}}');export{V as comp,J as data};
