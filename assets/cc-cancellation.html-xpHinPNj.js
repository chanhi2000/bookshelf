import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as f,d as e,f as a,b as o,a as b,t as v,n as u,g as d,w as l,e as s,r as c,o as g}from"./app-BVguHYKu.js";const w={},y={id:"frontmatter-title-관련",tabindex:"-1"},C={class:"header-anchor",href:"#frontmatter-title-관련"},x={class:"table-of-contents"},T={class:"hint-container note"},j={href:"https://leanpub.com/effectivekotlin",target:"_blank",rel:"noopener noreferrer"},A={href:"https://amazon.com/Effective-Kotlin-Best-Practices-Developers-ebook/dp/B0CHBR5XPF/",target:"_blank",rel:"noopener noreferrer"},q={class:"footnotes"},E={class:"footnotes-list"},J={id:"footnote1",class:"footnote-item"},I={href:"https://youtu.be/BOHK_w09pVA",target:"_blank",rel:"noopener noreferrer"};function S(h,n){const r=c("VPCard"),i=c("router-link"),k=c("SiteInfo"),p=c("VPIcon"),t=c("KotlinPlayground");return g(),f("div",null,[e("h1",y,[e("a",C,[e("span",null,v(h.$frontmatter.title)+" 관련",1)])]),a(r,u(d({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e("nav",x,[e("ul",null,[e("li",null,[a(i,{to:"#basic-cancellation"},{default:l(()=>n[0]||(n[0]=[s("Basic cancellation")])),_:1,__:[0]})]),e("li",null,[a(i,{to:"#the-finally-block"},{default:l(()=>n[1]||(n[1]=[s("The finally block")])),_:1,__:[1]})]),e("li",null,[a(i,{to:"#invokeoncompletion"},{default:l(()=>n[2]||(n[2]=[s("invokeOnCompletion")])),_:1,__:[2]})]),e("li",null,[a(i,{to:"#cancellation-of-children"},{default:l(()=>n[3]||(n[3]=[s("Cancellation of children")])),_:1,__:[3]})]),e("li",null,[a(i,{to:"#cancellation-in-a-coroutine-scope"},{default:l(()=>n[4]||(n[4]=[s("Cancellation in a coroutine scope")])),_:1,__:[4]})]),e("li",null,[a(i,{to:"#just-one-more-call"},{default:l(()=>n[5]||(n[5]=[s("Just one more call")])),_:1,__:[5]})]),e("li",null,[a(i,{to:"#stopping-the-unstoppable"},{default:l(()=>n[6]||(n[6]=[s("Stopping the unstoppable")])),_:1,__:[6]})]),e("li",null,[a(i,{to:"#cancellationexception-is-special"},{default:l(()=>n[7]||(n[7]=[s("CancellationException is special")])),_:1,__:[7]})]),e("li",null,[a(i,{to:"#cancellationexception-does-not-propagate-to-its-parent"},{default:l(()=>n[8]||(n[8]=[s("CancellationException does not propagate to its parent")])),_:1,__:[8]})]),e("li",null,[a(i,{to:"#withtimeout"},{default:l(()=>n[9]||(n[9]=[s("withTimeout")])),_:1,__:[9]})]),e("li",null,[a(i,{to:"#suspendcancellablecoroutine"},{default:l(()=>n[10]||(n[10]=[s("suspendCancellableCoroutine")])),_:1,__:[10]})]),e("li",null,[a(i,{to:"#summary"},{default:l(()=>n[11]||(n[11]=[s("Summary")])),_:1,__:[11]})])])]),n[28]||(n[28]=e("hr",null,null,-1)),a(k,{name:"Cancellation in Kotlin Coroutines",desc:"Everything you need to know about the cancellation mechanism in Kotlin Coroutines.",url:"https://kt.academy/article/cc-cancellation",logo:"https://kt.academy/logo.png",preview:"https://marcinmoskala.com/coroutines_book/promotion/204_cancellation.jpg"}),e("div",T,[n[19]||(n[19]=e("p",{class:"hint-container-title"},"Note",-1)),e("p",null,[n[14]||(n[14]=s("This is a chapter from the book ")),n[15]||(n[15]=e("a",{href:"/book/effectivekotlin",target:"_blank",rel:"noopener noreferrer"},"Effective Kotlin",-1)),n[16]||(n[16]=s(". You can find it on ")),e("a",j,[a(p,{icon:"fas fa-globe"}),n[12]||(n[12]=s("LeanPub"))]),n[17]||(n[17]=s(" or ")),e("a",A,[a(p,{icon:"fa-brands fa-amazon"}),n[13]||(n[13]=s("Amazon"))]),n[18]||(n[18]=s("."))])]),n[29]||(n[29]=o('<p>One of the most important mechanisms of Kotlin Coroutines for Android developers is <em>cancellation</em> because, on Android, nearly every coroutine is associated with some view, and if this view is destroyed, its coroutines are not needed, so they should be cancelled. Other coroutines should also be cancelled when the application is finished. This is a crucial capability that used to require a lot of effort from developers in many other libraries, but Kotlin Coroutines offer a simple and safe cancellation mechanism that can also be used on the backend, especially when we deal with long connections, like WebSockets or long polling. What is more, we often don&#39;t even realize that cancellation works in other situations, such as freeing up resources and making our application more efficient.</p><p>Cancellation is so important that some classes and libraries use suspending functions primarily to support cancellation<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>. There is a good reason for this: a good cancellation mechanism is worth its weight in gold<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup>. Just killing a thread is a terrible solution as there should be an opportunity to close connections and free resources. Forcing developers to frequently check if some state is still active isn&#39;t convenient either. The problem of cancellation waited for a good solution for a very long time, but what Kotlin Coroutines offer is surprisingly simple, convenient and safe. This is the best cancellation mechanism I&#39;ve seen in my career. Let&#39;s explore it.</p><hr><h2 id="basic-cancellation" tabindex="-1"><a class="header-anchor" href="#basic-cancellation"><span>Basic cancellation</span></a></h2><p>The basic idea behind cancellation is simple: calling <code>cancel</code> from a <code>Job</code> object changes its state to &quot;Cancelling&quot;. Here are the consequences of this change:</p><ul><li>All the children of this job are also cancelled.</li><li>The job cannot be used as a parent for any new coroutines.</li><li>At the first suspension point, a <code>CancellationException</code> is thrown. If this coroutine is currently suspended, it will be resumed immediately with <code>CancellationException</code>. <code>CancellationException</code> is ignored by the coroutine builder, so it is not necessary to catch it, but it is used to complete this coroutine body as soon as possible.</li><li>Once the coroutine body is completed and all its children are completed too, it changes its state to &quot;Cancelled&quot;.</li></ul><p>Take a look at the following example:</p>',7)),a(t,{title:"Basic%20cancellation",key:"6b0f9774",settings:"%7B%7D",files:"eJx9z0tuwjAQBuCr/Iq6MIuCnXZVqd30ApUqVhgh4wxgZMZRHCMhxN1xEh4rsvBj5tOMx4siplgTV9gkxsE4FpMvzNm1+IYNTUitY/q3oSacNQNH47EP66zeJLa7IQs0VJNphVpJKSc4w+H9ZxCgIm9Oosxwz9SN49az0MVfd3O8xZvTxc0v3dFvmodapfri/PDUGrbkxS3ah25izc+Gv717qhCTtRTjJnl/6nvnlrNZtyDktEQkm5M5eswgx1CNYTmGH2P4eUf1xBd/4GJ5BdR1hus="}),n[30]||(n[30]=o('<p><code>launch</code> starts a process that prints a number every 200 ms. However, after 1100 ms, we cancel this process, therefore the coroutine changes state to &quot;Cancelling&quot;, and a <code>CancellationException</code> is thrown at the first suspension point. This exception ends our coroutine body, so the coroutine changes state to &quot;Cancelled&quot;, <code>join</code> resumes, and we see &quot;Cancelled successfully&quot;.</p><p>We might cancel with a different exception (by passing an exception as an argument to the <code>cancel</code> function) in order to specify the cause. This cause needs to be a subtype of <code>CancellationException</code> because only an exception of this type can be used to cancel a coroutine.</p><hr><h2 id="the-finally-block" tabindex="-1"><a class="header-anchor" href="#the-finally-block"><span>The <code>finally</code> block</span></a></h2><p>The cancellation mechanism is simple but very powerful. It guarantees that if we have a <code>finally</code> block, it will be executed, and all the resources will be freed. It also allows us to make an action only in case of cancellation by catching <code>CancellationException</code>. It is not necessary to rethrow this exception because it is ignored by the coroutine builder, but it is considered good practice to do so in case there is some outer scope that should know about the cancellation.</p>',5)),a(t,{title:"The%20finally%20block",key:"6688abde",settings:"%7B%7D",files:"eJx9UMtqwzAQ/JXF5KAc6ti+FALtpbSHngqlp7oURV7XCurK2FLTEPzvkew4ckzIgoRGM/uaz6i1bY1UQGkJfrkktlzDB0kDDyB0o62RhO9C1wiHnMDFH1ew1RvHK25JVOM/gGn2AfhosEZuWPqdJMkSDiDh7nHK+yhQ8T3LnGDO1I0ko4jl0Zt/SfqBhcyjma4LsAPBjRuI4RqeOAlUihup6flfYO0fboagDuVPWixgJ00FC5w0MVWjd4AD7KCUxJWarBmqvAzUJLcfrb+GJe9PSzr3YtH3ZGe81d56j67N1VohsG1LGxoMJVPvbE6uyWrlD7AkzqBF4T4dOhuX3CLTW2Q2kmkgZ4a96s1Vu+M47uWjM5epFztR9HUEt5XFvg=="}),n[31]||(n[31]=o(`<p>Notice that <code>join</code> in the example above is used to wait for the cancellation to finish before we can proceed. Without this, we would have a race condition, and we would (most likely) see &quot;Cancelled successfully&quot; before &quot;Cancelled...&quot; and &quot;Finally&quot;. This is why when we cancel a coroutine we often also add <code>join</code> to wait for the cancellation to finish. Since this is a common pattern, the kotlinx.coroutines library offers a convenient extension function with a self-descriptive name, <code>cancelAndJoin</code><sup class="footnote-ref"><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"></a></sup>.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">public</span> <span class="token keyword">suspend</span> <span class="token keyword">fun</span> Job<span class="token punctuation">.</span><span class="token function">cancelAndJoin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="invokeoncompletion" tabindex="-1"><a class="header-anchor" href="#invokeoncompletion"><span><code>invokeOnCompletion</code></span></a></h2><p>Another way to handle coroutine cancellation or completion is to use the <code>invokeOnCompletion</code> function from <code>Job</code>, which is used to set a handler to be called when the job reaches a terminal state, namely either &quot;Completed&quot; or &quot;Cancelled&quot;. It also provides an exception in its parameter that finishes a coroutine. <code>invokeOnCompletion</code> is guaranteed to be called exactly once (assuming this coroutine ever completes), even if the job had already completed when the handler was set.</p>`,5)),a(t,{title:"invokeOnCompletion",key:"45cabd51",settings:"%7B%7D",files:"eJx9UMFOwzAM/RWr4pAd6NpdkJDgMsGBC0iIE0UoS13mkTlVkw6maf9OsjatiqZFSmT7vdjP7z0BsK2tkUuoWoatJBazW3hjcnAHyjSmdcT4qkyNcCgY/NlJDRuz8riWLat1rAM0WKN0Iv/MsmwGByC4vo9Yd0rUci8WHp7W64bYaRZF8hIi4i+4oiKZsI4x6QOvISXemW985qXZ1hodGY5qqALhlyALS8kKtZYBffhVWIfAy4vtxtk9E0v4Ibf2CtwgoZ85ch+Jpdb7nnCE8Hbb3fTbBX3q1FEM+cYEg0N2bqptlUJrq3Zs3LXMg6EFexHzebggsnQBFpUv+mzwLLsE5pfARQTzEfxnx5NZnbUyTdMTPToy/TrZiZOPPxb4wv8="}),n[32]||(n[32]=o('<p>The <code>invokeOnCompletion</code> handler is called with:</p><ul><li><code>null</code> if the job finished with no exception;</li><li><code>CancellationException</code> if the coroutine was cancelled;</li><li>the exception that finished a coroutine (more about this in the next chapter).</li></ul><p><code>invokeOnCompletion</code> is called synchronously during cancellation, and we can&#39;t control the thread in which it will be running. It can be further customized with the <code>onCancelling</code><sup class="footnote-ref"><a href="#footnote4">[4]</a><a class="footnote-anchor" id="footnote-ref4"></a></sup> and <code>invokeImmediately</code><sup class="footnote-ref"><a href="#footnote5">[5]</a><a class="footnote-anchor" id="footnote-ref5"></a></sup> parameters.</p><hr><h2 id="cancellation-of-children" tabindex="-1"><a class="header-anchor" href="#cancellation-of-children"><span>Cancellation of children</span></a></h2><p>Cancellation propagates down the hierarchy of coroutines because when a job is cancelled, all its children are also cancelled. This is a very useful feature as when you cancel a process, it also cancels all its subprocesses. This is good practice as it prevents memory leaks and frees resources.</p>',6)),a(t,{title:"Cancellation%20of%20children",key:"34465a59",settings:"%7B%7D",files:"eJx9kj1PwzAQhv/KKVPKEFLYKqGKViwsDIiJMLjOhbh1zpHtlFao/x07aRL3iyGO37v3zo8/PiNR1Upb2CgrBe0SrrRqrCA0yV1GGZnG1Eg5FA1BxQTFkxl8kLDwBIP1nasa4TcjgC3TwEsh81e1moEb5s5IjZRdUsJarVxEsoZ42ZXAmQKwej8KgBwl28fTNE0nY7DWgqykOIues2iIH6AQxKQ8qQ+sPi1MiXlY002Ovx7+AvIG1sMtrMUJFmfWtYpxBktGHKVkVih62XGs/WRynXfh6lr3P8DnlB3WY4g1NlwObQ6JoK3a4BstVVVL9BRjk6Di8sjahdthuJk246426XjjQa+VfzJeBS37PYFpOEdjCvc+9sf2va2/h3kizFDgHG7d+3v/QZwmUzDIXdArWyKsUKofUDpHDZX4Lq2LQC6KAjWS7YzBG/AyPGKvg/228jqrT1ndYEbR1x+CbQYk"}),n[33]||(n[33]=o(`<hr><h2 id="cancellation-in-a-coroutine-scope" tabindex="-1"><a class="header-anchor" href="#cancellation-in-a-coroutine-scope"><span>Cancellation in a coroutine scope</span></a></h2><p>A job created using the <code>Job()</code> factory function can be cancelled in the same way. We often specify a job when we construct a coroutine scope. If we don&#39;t specify it explicitly, <code>CoroutineScope</code> creates a default job.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span></span>
<span class="line">  context<span class="token operator">:</span> CoroutineContext</span>
<span class="line"><span class="token punctuation">)</span><span class="token operator">:</span> CoroutineScope <span class="token operator">=</span> <span class="token function">ContextScope</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>context<span class="token punctuation">[</span>Job<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> context <span class="token keyword">else</span> context <span class="token operator">+</span> <span class="token function">Job</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>So when such a scope is used as a parent for coroutines, we can cancel all of them at once by cancelling the parent’s job. This can be done using the <code>cancel</code> function from <code>CoroutineScope</code>, which calls <code>cancel</code> on the job.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">fun</span> CoroutineScope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span>cause<span class="token operator">:</span> CancellationException<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">   <span class="token keyword">val</span> job <span class="token operator">=</span> coroutineContext<span class="token punctuation">[</span>Job<span class="token punctuation">]</span> <span class="token operator">?:</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;...&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">   job<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This capability is often used to cancel all the tasks started by a class. This might be useful, for instance, to complete all processes in unit testing.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="OfferUploader.kt"><span>OfferUploader.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> OfferUploader <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">upload</span><span class="token punctuation">(</span>offer<span class="token operator">:</span> Offer<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// upload</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    scope<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>However, you must remember that once a job is cancelled it cannot be used as a parent for new coroutines. So, a scope with a cancelled job is not useful anymore. This can even be dangerous because trying to start a new coroutine in such a scope will silently do nothing.</p>`,9)),a(t,{title:"Cancellation%20in%20a%20coroutine%20scope",key:"ffa9a47a",settings:"%7B%7D",files:"eJw1jrsOAiEQRX9lQsVa4BdY2dlaWIgFy6KysjOEh5ps/HcZjM0U5557M2fhl0ipwINK8PhWlhLV4tFltdGoMdccHU5wrQiL8SgHWDUCPE2AbCk62MH+3zkykAca5TCw1AVlDVoXZCdcm2lspV8WTEV7hxW2W3j5EGB04G9IyU2sA8TksQSUWpw4RiqsdNoU0Uc/fNqqmokf1NiAuHwBEcxLNg=="}),n[34]||(n[34]=o(`<p>That is why I recommend using the <code>cancelChildren</code> function from <code>CoroutineContext</code>, which cancels all the children of a job but leaves the job itself in the active state. Keeping the job active costs us nothing and gives us some extra safety. On Android, cancellation happens automatically when we use Android KTX&#39;s <code>viewModelScope</code> or <code>lifecycleScope</code>. We might also create a scope ourselves, in which case we should remember to cancel its children when this scope is no longer needed. It is good practice to use <code>SupervisorJob</code> as a parent for such a scope, as I will explain in the next chapter.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="ProfileViewModel"><span>ProfileViewModel</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> ProfileViewModel <span class="token operator">:</span> <span class="token function">ViewModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Main <span class="token operator">+</span> <span class="token function">SupervisorJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">fun</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span> <span class="token function">loadUserData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onCleared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    scope<span class="token punctuation">.</span>coroutineContext<span class="token punctuation">.</span><span class="token function">cancelChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"> <span class="token comment">// ...</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><hr><h2 id="just-one-more-call" tabindex="-1"><a class="header-anchor" href="#just-one-more-call"><span>Just one more call</span></a></h2><p>When we cancel a coroutine, it changes state to &quot;Cancelling&quot;, where it should only clean up resources and complete. However, what if cleaning up resources requires making suspending calls or starting coroutines? We cannot do that because these operations are not allowed in the &quot;Cancelling&quot; state. Calling suspending functions in this state will throw <code>CancellationException</code>, and starting a new coroutine will be ignored.</p>`,5)),a(t,{title:"Just%20one%20more%20call%201",key:"698097fe",settings:"%7B%7D",files:"eJxtUD1PwzAQ/SunTA5D6jIiMSAQQ8WGmAiDa18Vg3u2/IFaof537ERJGjWWbJ/f3Xv3fJ+VPjrrI/zYaDSdGmm9TVEThuaupZZCCg5JwSERHIUmVj/AB+kIjzCVvkvrEP5aAvgVBr7tPmd3ds/qAhmRSHYso/VQAxD9eQwBnNcUDbG2eh4FIUThI6q26hXKUmjEmd1zPiFrvIMmHbor4qVAwpjVfq9D6qrL4HWuXXTptFEeCfCEMi3dXZY2t5zztzWjBgUlB8oSzhbL1R8Tuc/kgTVSkETzRGpny+gLPKu9jCqZvNmUDbcTLCjjzRYCylyaX+OvS9xLUPX1D5PBpc0="}),n[35]||(n[35]=e("p",null,[s("For such situations, there is a special structure "),e("code",null,"withContext(NonCancellable)"),s(". "),e("strong",null,[s("We should use "),e("code",null,"withContext(NonCancellable)"),s(' for all suspending calls that should be executed even in the "Cancelling" state (so even in the case of cancellation).')]),s(),e("code",null,"NonCancellable"),s(" is a job that is always active, and it should not be used outside this particular situation, where we need to either make a suspending call or start a new coroutine even in the case of cancellation.")],-1)),a(t,{title:"Just%20one%20more%20call%202",key:"c4a32612",settings:"%7B%7D",files:"eJxtUT1PwzAQ/SunTA5DmjIiMaAghgqxICbC4DhXxeCeo9iGVIj/ju00qaPWkr+e3717d37P5KHXg4UvbZWksRB60M5KQlPc1FSTcaZHamHvCA5cEsvv4I2khXtYqK9C9wi/NQF8cwWfuvGvO92wPECKOxId82g+cQDscJyPAP0gySpidVbNgmAsHyy2dRYVwmhR8SO7LcsFuRa3lyRNlwT+BYgrdTXf0/SUZPmRtqs0WRwte9FUcRKoFG8ULt7DmEpKkZWdTqp2QAIcUbh1Gd7R+TjVtC3L8jkhJEIKObkeWk2YaJwU4haWRSYwfJsLEW0/ULvT4cM8etZ8nLV85GYTJly2PaCsLLZgUHiqv82tivyL+iI/Ya+MByBmpezjH+ZFxh8="}),n[36]||(n[36]=o(`<p>Even if you just implement a suspending function and you specify some cleanup in the <code>finally</code> block that requires a suspending call, you should use <code>withContext(NonCancellable)</code> to make sure that the cleanup will be done even in the case of cancellation.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// operation</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">withContext</span><span class="token punctuation">(</span>NonCancellable<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token comment">// cleanup that requires suspending call</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="stopping-the-unstoppable" tabindex="-1"><a class="header-anchor" href="#stopping-the-unstoppable"><span>Stopping the unstoppable</span></a></h2><p>Because cancellation happens at suspension points, it won’t happen until a suspension. To simulate such a situation, we could use <code>Thread.sleep</code> instead of <code>delay</code>, but this is a terrible practice, so please don’t do this in any real-life projects. We are just trying to simulate a case in which we are using our coroutines extensively but not suspending them. In practice, such a situation might arise if we have some complex calculations, like neural network learning (yes, we also use coroutines for such cases in order to simplify processing parallelization), or when we need to do some blocking calls (for instance, when reading files).</p><p>The example below presents a situation in which a coroutine cannot be cancelled because there is no suspension point inside it (we use <code>Thread.sleep</code> instead of <code>delay</code>). The execution needs over 3 minutes, even though it should be cancelled after 1 second.</p>`,6)),a(t,{title:"Stopping%20the%20unstoppable%201",key:"649aa5b2",settings:"%7B%7D",files:"eJxVUMlOwzAU/JVRxME9kKQ9IoGEuPWEBIgDQch1Xhoj59nyUlEh/h07LUU5eJnF47HfqpCCI+4xJMYkNYvVDV5YR9xCWW9T1ExPyjrCd8fAQRp82l1Wt3YnVoUyMrEaRWZXJw/gyZGMYv3Rtm0moXF9d1KA59GT7OtgiJzYFL1p8EqY9H6MGOWBEOxEf/YsKjs5Q1/IJbyM2nKA9fkO2WveY9CGAkbylyPOa46GRVc9ll0xXemumssCP2WZp56MPIp16VhgfkCtJCsy99xvbfmKQv+nPcyioR4hKUUhDMmY4zl4EZbjm6YMXBq0S7hews0M67qGSA7R4hxUvf8CFMiEbQ=="}),n[37]||(n[37]=e("p",null,[s("There are a few ways to deal with such situations. The first one is to use the "),e("code",null,"yield()"),s(" function from time to time. This function suspends and immediately resumes a coroutine. This gives an opportunity to do whatever is needed during suspension (or resuming), including cancellation (or changing a thread using a dispatcher).")],-1)),a(t,{title:"Stopping%20the%20unstoppable%202",key:"a76f0914",settings:"%7B%7D",files:"eJx1j09LxDAUxL/KUDykB3fb1ZOgIN72JKgnK5JN3rqR50tpGqGI392krbv0sIH8mZnwy+S1CDG0JBb7KPjSTlR5gxdxPW5hfOdj74SejG8JP40A35rx6Xcp3fqdKrPFOoo5qOSW0x2go5Z0r+r3qqqSCYfLuykBng8dabsKTNSqTcr/g8ER2wmZR9s56VlUUzzmk5MPXLimmPPfvI2LJdaDquuZlGqsjBZDfC926/OHsn2iPYwhk0WIxlAI+8g8zOAZlms3kvDrdZ44NqiWsl7KzVJeLeX1KM88L8XbH23Wfqg="}),n[38]||(n[38]=o(`<p>It is good practice to use <code>yield</code> in suspend functions between blocks of non-suspended CPU-intensive or time-intensive operations.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">cpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">withContext</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>Default<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">cpuIntensiveOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">cpuIntensiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">cpuIntensiveOperation3</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Another option is to track the state of the job. Inside a coroutine builder, <code>this</code> (the receiver) references the scope of this builder. <code>CoroutineScope</code> has a context we can reference using the <code>coroutineContext</code> property. Thus, we can access the coroutine job (using <code>coroutineContext[Job]</code> or <code>coroutineContext.job</code>) and check what its current state is. Since a job is often used to check if a coroutine is active, the Kotlin Coroutines library provides a function to simplify this:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">public</span> <span class="token keyword">val</span> CoroutineScope<span class="token punctuation">.</span>isActive<span class="token operator">:</span> Boolean</span>
<span class="line">  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> coroutineContext<span class="token punctuation">[</span>Job<span class="token punctuation">]</span><span class="token operator">?</span><span class="token punctuation">.</span>isActive <span class="token operator">?:</span> <span class="token boolean">true</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>We can use the <code>isActive</code> property to check if a job is still active and stop calculations if it is not.</p>`,5)),a(t,{title:"Stopping%20the%20unstoppable%203",key:"c19c34dc",settings:"%7B%7D",files:"eJytTrsOwjAM/JVTp3ThNSIxIDYmJGCiDCExNMg4VdOAEOLfacprYsOSLfvOvvMmCzFUJBb7KDhpJyofYy2uwQTG1z42TmhpfEW4FQKcNePody079zuVJ4h1FFOqFs2fO4D17w5YlTVp2wtMVKnRYNDdpKhqJw2LKrJF6pwciuxF3nEpHROUC1PTuDN1+D0VS6yvajh8CbWuPaPFEE/Fzn36P8Ff7VlHMlmEaAyFsI/M186p1ev3U+LzwF+GH5aSbR/F9nqG"}),n[39]||(n[39]=e("p",null,[s("Alternatively, we might use the "),e("code",null,"ensureActive()"),s(" function, which throws "),e("code",null,"CancellationException"),s(" if "),e("code",null,"Job"),s(" is not active.")],-1)),a(t,{title:"Stopping%20the%20unstoppable%204",key:"32408954",settings:"%7B%7D",files:"eJx1T8tKAzEU/ZXL4CKzsJ2prgSF4q4rQV05LtLk1kZub0IehSL+e5NMH8yigTzOg3Nyv5qQgkPWsEkMO2lYtE/wySbCMyjrbYqG8V1Zh/A3MMBeEvzadVZXdi3aQpFMrLYis+3oAfDoUEbRd12XOeC0g/uXUQL42HqUehYI0YlFdpwF5JA8LlU0exyjy3LecCQWQ/NWXoZ/4C4HDs3J8V+uemgkeRB9bq1S/tBMSVZIS9YrW0Yr9DXvtYqEGkJSCkPYJKJDDc5583nZcCntprCfwsUUPkzhY4U3+rj5PgJKCX7D"}),n[40]||(n[40]=o(`<p>The result of <code>ensureActive()</code> and <code>yield()</code> seem similar but are actually very different. The <code>ensureActive()</code> function needs to be called on a <code>CoroutineScope</code> (or <code>CoroutineContext</code>, or <code>Job</code>). All it does is throw an exception if the job is no longer active. <code>ensureActive()</code> is lighter than <code>yield()</code>. The <code>yield</code> function is a regular top-level suspension function that does not need any scope, so it can be used in regular suspending functions. Since it does suspension and resuming, it causes redispatching, which means that if there is a queue to the dispatcher, this coroutine will return the thread and wait in the queue. This is considered positive when our operations are demanding threads as it prevents other coroutines being starved. <code>yield</code> should be used in suspending functions that make multiple CPU-intensive or blocking operations.</p><hr><h2 id="cancellationexception-is-special" tabindex="-1"><a class="header-anchor" href="#cancellationexception-is-special"><span><code>CancellationException</code> is special</span></a></h2><p>Since <code>CancellationException</code> is thrown when a coroutine is cancelled, it has a special meaning for coroutines. That is why we should not catch it with other exceptions, as a rule of thumb we should always rethrow it, even if all other exceptions are caught.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// suspending operation</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> CancellationException<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">throw</span> e</span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// hanle other exceptions</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Optionally, we could also add <code>ensureActive()</code> in the catch block to ensure that the coroutine is still active (some people consider this approach safer, because it throws exceptions only if the current coroutine is active, and not when <code>CancellationException</code> is thrown for other reasons).</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// suspending operation</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Exception<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// hanle exceptions</span></span>
<span class="line">    coroutineContext<span class="token punctuation">.</span><span class="token function">ensureActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We can explicitly catch <code>CancellationException</code> if we want to do something particular in the case of cancellation, but we should always rethrow it to inform the outer scope about the cancellation.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// suspending operation</span></span>
<span class="line">  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> CancellationException<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do something</span></span>
<span class="line">    <span class="token keyword">throw</span> e</span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Beware, that <code>CancellationException</code> used by Kotlin Coroutines is not the same as <code>java.util.concurrent.CancellationException</code>. The latter is used in Java for the <code>Future</code> interface, and it is not a part of the Kotlin Coroutines library.</p><hr><h2 id="cancellationexception-does-not-propagate-to-its-parent" tabindex="-1"><a class="header-anchor" href="#cancellationexception-does-not-propagate-to-its-parent"><span>CancellationException does not propagate to its parent</span></a></h2><p>All exceptions that extend <code>CancellationException</code> are treated in a special way: they only cause cancellation of the current coroutine. <code>CancellationException</code> is an open class, so it can be extended by our own classes or objects.</p>`,13)),a(t,{title:"CancellationException%20does%20not%20propagate%20to%20its%20parent%20(1)",key:"2f55ec7d",settings:"%7B%7D",files:"eJx1j81OAyEUhV/lZFbURWc6umriyrjUmBjjQlwggy2R3kuAiW0a310QU8c2TSCQj3t+eGnsxnNI+ODkLG3nmgOPyZKJ8wtJkrRTMeJud8/0ENirlcqPq9utNj5ZJixxo0gb5zJnOnAxK+I4Rm9owPtI2Cib6RJPZBOucch51OwN9pIAp0bSa+zRtlgU8B/1FQGDcWon+q7rckpFPlhKjoRsnq1zIE54M5WaQTa/c1/1qPrFnz6tA3+e/6SYlfjLMvvjMC11NbWcVDoqdFImG+XVtmVD9IhGZ57vx+PUvH4DowiJUA=="}),n[41]||(n[41]=o("<p>In the above snippet, we start two coroutines with builders at 1 and 4. After 1 second, we throw a <code>MyNonPropagatingException</code> exception at 3, which is a subtype of <code>CancellationException</code>. This exception is caught by <code>launch</code> (started at 1). This builder cancels itself, then it also cancels its children, namely the builder defined at 2. However, the exception is not propagated to the parent (because it is of type <code>CancellationException</code>), so <code>coroutineScope</code> and its children (the coroutine started at 4) are not affected. This is why the coroutine that starts at 4 prints &quot;Will be printed&quot; after 2 seconds.</p><p>In some projects, I see a pattern of defining exceptions that extend <code>CancellationException</code>. This is a dangerous practice because it might lead to unexpected results. Consider the following code:</p>",2)),a(t,{title:"CancellationException%20does%20not%20propagate%20to%20its%20parent%20(2)",key:"20614f08",settings:"%7B%7D",files:"eJxtkUtPwzAMx7+K1VNBKBvXXXkcEQc4EQ5R6tGIzK4SV9s08d1xFh7dViVS/Pz5b+WtCZuBk8AnSwy0M54TjxIIs7m2dJKc5rwjjzE6CUzmbuI87DwOxbB6Fgt4Zk4wJOcleLyBjoFYyiN9yJZ8dDnDa8b0xPLII3V/AFjBLLi9Kug85gGpg/VIsHFBo3CwBCBpXw2AceicYGHfO3GlDeALvBPfQ4ur+ak/GFDNgSRSa5tSd1S9LpW2qSBLek91nA+sqP9olVD9ly2i5BJRzCXkNw0HKD0dRrdvb5fL5REx0VaqA30YY1SY1s7S6nBlSZ94O7+45rVXf+xsXWrevwG2FsUs"}),n[42]||(n[42]=e("p",null,[s("This code works, but well... accidentally. It works only because there are no coroutines between throwing an exception and catching it. Adding "),e("code",null,"launch"),s(" in between might change the result significantly.")],-1)),a(t,{title:"CancellationException%20does%20not%20propagate%20to%20its%20parent%20(3)",key:"c3853b44",settings:"%7B%7D",files:"eJxtkU9rwzAMxb+KyCkbI2mvhZ325zgG207zDsZRVzNXCrZCW8K+++SkhHQNMUS2nn/v2f4s/L7lKPDDEjwdK8eRO/GEqbo1dNGc95wlhyFY8UzVw2zydHTY5sLoV9fwyhyhjdaJd3gHDQOx5J/sfDLkgk0JPhLGF5Zn7qiZALCBRXB5k9GpSy1SA9uOYG+9rkJvCEDiaSwAuraxgpn9aMXmbQC/4Ky4HZS4WXY9Y0Aze5JApSmybki9zUpTjCBDOi5z/DeEe5iu7M1xiyM72I40Qj/Tq1ZpV633A6Kksanj2msS9JC3NxjsqVyvVqsh4+wIWe3pu6oqza/aRdo5Sa9vE/mwfD9jmLoeHrdcQ0KnXlrPLaj4+gPMQtXo"}),n[43]||(n[43]=o("<p>In the above example, <code>updateUser</code> throws <code>UserNotFoundException</code>, but it is caught by <code>launch</code> from <code>updateUserData</code> and only causes cancellation of this <code>launch</code>. <code>updateTweets</code> is not affected, so it prints &quot;Updating...&quot; and the exception is not caught in <code>main</code>. This behavior is different from what we would typically expect, namely propagation of the exception until it is caught. It is a trap that developers sometimes fall into.</p><p>Encountering such a situation is not common because if we used <code>async</code> with <code>await</code> instead of <code>launch</code>, then <code>await</code> would throw <code>UserNotFoundException</code>, and this exception should propagate. However, it is better to avoid doing this as it might lead to unexpected results that are hard to debug. It is safer to extend <code>Exception</code> or <code>RuntimeException</code> instead of <code>CancellationException</code>.</p>",2)),a(t,{title:"CancellationException%20does%20not%20propagate%20to%20its%20parent%20(4)",key:"5eb6ce5d",settings:"%7B%7D",files:"eJxtj09PAyEQxb/Ky55WD3S99qwePRg9iQfCTi1xdyAwpG0av7tQ/FPtJpDAzHu/efPSuTn4KHj3MjneK+ujz+KYkrrWrNlOJiU8J4oPXu595vFubymI84w1HjOLm+mn1F9VT8opEI/YZMZsXKniqBmQeGgPIIfRCFXsrRFTbcAHrBG7RU/r5YFfGCBExzJxr7uqA3vBpip110Cay/mb4//Ahvqttgjt/7QjklQrBXMJ+W7jiOoZaTKH/mYYhhPiLFtVO35TSpVgRbtIa8MLS7bR75YXL/3iXa3qPSnOVubu9RP3fqBp"}),n[44]||(n[44]=o('<hr><h2 id="withtimeout" tabindex="-1"><a class="header-anchor" href="#withtimeout"><span><code>withTimeout</code></span></a></h2><p>If you want to start a certain operation with timeout, you can use the <code>withTimeout</code> function, which behaves just like <code>coroutineScope</code> until the timeout is exceeded. Then, it cancels its children and throws <code>TimeoutCancellationException</code> (a subtype of <code>CancellationException</code>).</p>',3)),a(t,{title:"withTimeout%20(1)",key:"2a468b8c",settings:"%7B%7D",files:"eJx1kEFPwzAMhf+K6alDaG0Ru0ziBDtwHpwI0kJqaLTUiRpXa4X230nawGDSDpFe7Cf7e37NdOtsx7C3bDQNS2U727Mm9MtrQYJ87x1SDR89AaPnfLGGJ2K4h4Pm5lm3GOx5tSrLBXwJAqjRyDGvylCIX9dpYkO5yLasjQFuNO01fYpsal90P1rCq2QqCri7FXQ852mlpsjzQjoC/aJvlXU403A3ziLIiT7qIyjJqoEc15ASPEhSaIxkbWkzKHRRpER/sZIP64QWmP6FiKybgTsJPA+G2qIHsgwNGneT4uwizA7ebT3CQfrA8zM2piyK+CCvwKMKa4I+O97ULperk+EERtnbNylUm/A="}),n[45]||(n[45]=e("p",null,[s("Beware that "),e("code",null,"withTimeout"),s(" throws "),e("code",null,"TimeoutCancellationException"),s(", which is a subtype of "),e("code",null,"CancellationException"),s(" (the same exception that is thrown when a coroutine is cancelled). So, when this exception is thrown in a coroutine builder, it only cancels it and does not affect its parent.")],-1)),a(t,{title:"withTimeout%20(2)",key:"6d7c3e53",settings:"%7B%7D",files:"eJxljs1OwzAQhF9llJOLUPODuCBx4w0AccAcXGdRVzhrK3ZUqop3x4lDoULyz2p2dud7rXgIfkz48MmxfG6tH/2UWChur7RoiVMMJD3eJ8FgWNTmDs/CCfc4Wx+tD4STFsCZSeweJ9Q12lm4lLprWCOWnKMeuyM4RQQzkqTiBXpy5qi6pmk2P1IYWZITpasXdg7iE3ZUVOp1tfq+ynfgtH/igTKZauctJfhAa/CKcxnX3p7jljXL85f7pjT/wf2iPXihlSVP51PX84XqEMlmPdeLR6q3b5JSdGU="}),n[46]||(n[46]=o("<p>In the above example, <code>delay(1500)</code> takes longer than <code>withTimeout(1000)</code> expects, so <code>withTimeout</code> cancels its coroutine and throws <code>TimeoutCancellationException</code>. The exception is caught by <code>launch</code> at 1, and it cancels itself and its children (<code>launch</code> starts at 2). The <code>launch</code> that starts at 3 is not affected, so it prints &quot;Done&quot; after 2 seconds.</p><p>A less aggressive variant of <code>withTimeout</code> is <code>withTimeoutOrNull</code>, which does not throw an exception. If the timeout is exceeded, it just cancels its body and returns <code>null</code>. I find <code>withTimeoutOrNull</code> useful for wrapping functions in which waiting times that are too long signal that something has gone wrong, such as network operations: if we wait over 5 seconds for a response, it is unlikely we will ever receive it (some libraries might wait forever).</p>",2)),a(t,{title:"withTimeout%20(3)",key:"fa9002dc",settings:"%7B%7D",files:"eJxdj81OwzAQhF9lFHFIOTS59FIp4g1A4ueEOUTuhqxw1pF/Cgjx7niTUlEkW7J3Zr+dfa54mn1IePPJsXxsrQ8+JxaK22sjRqzrY8RTpFBv9B9znEkOGLJgoGTHVdovFnwZAZoG91kiBh/oSEFL7yM7Qp1Cps1qAj6Z3EGhwLeRci7hr5QUeRdus3O/A27QLThO4yNPVJKe9F3btmfyn1wn+iV66lkWonBCh/PKD9bPtEKOvUPWjbr/QVSdA0tyUptKlT2u1GqqopVZTaMX9Q6RbCmV9+qS0m+kevkBqsJ/PA=="}),n[47]||(n[47]=o(`<hr><h2 id="suspendcancellablecoroutine" tabindex="-1"><a class="header-anchor" href="#suspendcancellablecoroutine"><span><code>suspendCancellableCoroutine</code></span></a></h2><p>Here, you might remind yourself of the <code>suspendCancellableCoroutine</code> function introduced in the <em>How does suspension work?</em> chapter. It behaves like <code>suspendCoroutine</code>, but its continuation is wrapped into <code>CancellableContinuation&lt;T&gt;</code>, which provides some additional methods, the most important of which is <code>invokeOnCancellation</code>, which we use to define what should happen when a coroutine is cancelled. Most often we use it to cancel processes in a library or to free resources.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">someTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> suspendCancellableCoroutine <span class="token punctuation">{</span> cont <span class="token operator">-&gt;</span></span>
<span class="line">  <span class="token comment">// rest of the implementation</span></span>
<span class="line">  cont<span class="token punctuation">.</span><span class="token function">invokeOnCancellation</span> <span class="token punctuation">{</span> <span class="token comment">/* cleanup */</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>CancellableContinuation&lt;T&gt;</code> also lets us check the job state (using the <code>isActive</code>, <code>isCompleted</code> and <code>isCancelled</code> properties) and cancel this continuation with an optional cancellation cause.</p><hr><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2><p>Cancellation is a powerful feature. It is generally easy to use, but it can sometimes be tricky, therefore it’s important to understand how it works. From this chapter, you should remember that:</p><ul><li>When we cancel a coroutine, it changes its state to &quot;Cancelling&quot;, and cancels all its children.</li><li>A coroutine in the &quot;Cancelling&quot; state does not start child coroutines and throws <code>CancellationException</code> when we try to suspend it or if it is suspended.</li><li>It is guaranteed that the body of the <code>finally</code> block and the <code>invokeOnCompletion</code> handler will be executed.</li><li>We can invoke an operation specifically in the case of cancellation by catching <code>CancellationException</code>, but we should rethrow it to inform the outer scope about the cancellation.</li><li>To start a new coroutine or make a suspending call in the &quot;Cancelling&quot; state, we can use <code>withContext(NonCancellable)</code>.</li><li>To allow cancellation between non-suspending operations, we can use <code>yield</code> or <code>ensureActive</code>.</li><li><code>CancellationException</code> does not propagate to its parent.</li><li>We can use <code>withTimeout</code> or <code>withTimeoutOrNull</code> to start a coroutine with a timeout.</li><li>Always use <code>suspendCancellableCoroutine</code> instead of <code>suspendCoroutine</code> when you need to transform a callback-based API into a suspending function, and use <code>invokeOnCancellation</code> to define what should happen when a coroutine is cancelled.</li></ul><p>A properly used cancellation means fewer wasted resources and fewer memory leaks. This is important for our application&#39;s performance, so I hope you will use these advantages from now on.</p>`,10)),b(" TODO: add ARTICLE CARD "),a(r,u(d({title:"Cancellation in Kotlin Coroutines",desc:"Everything you need to know about the cancellation mechanism in Kotlin Coroutines.",link:"https://chanhi2000.github.io/bookshelf/kt.academy/cc-cancellation.html",logo:"https://kt.academy/logo.png",background:"rgba(243,139,49,0.2)"})),null,16),n[48]||(n[48]=e("hr",{class:"footnotes-sep"},null,-1)),e("section",q,[e("ol",E,[e("li",J,[e("p",null,[n[22]||(n[22]=s("A good example is ")),n[23]||(n[23]=e("code",null,"CoroutineWorker",-1)),n[24]||(n[24]=s(" on Android, where according to the presentation ")),e("a",I,[a(p,{icon:"fa-brands fa-youtube"}),n[20]||(n[20]=e("em",null,"Understand Kotlin Coroutines on Android",-1)),n[21]||(n[21]=s(" on Google I/O'19"))]),n[25]||(n[25]=s(" by Sean McQuillan and Yigit Boyar (both working on Android at Google), support for coroutines was added primarily to use the cancellation mechanism. ")),n[26]||(n[26]=e("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1))])]),n[27]||(n[27]=o('<li id="footnote2" class="footnote-item"><p>Actually, it&#39;s worth much more since the code is currently not very heavy (it used to be when it was stored on punched cards). <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li><li id="footnote3" class="footnote-item"><p>This function first calls <code>cancel</code> and then <code>join</code>, so it is called <code>cancelAndJoin</code>. Uncle Bob would be proud. <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p></li><li id="footnote4" class="footnote-item"><p>If true, the function is called in the &quot;Cancelling&quot; state (i.e., before &quot;Cancelled&quot;). <code>false</code> by default. <a href="#footnote-ref4" class="footnote-backref">↩︎</a></p></li><li id="footnote5" class="footnote-item"><p>This parameter determines whether the handler should be called immediately if the handler is set when a coroutine is already in the desired state. <code>true</code> by default. <a href="#footnote-ref5" class="footnote-backref">↩︎</a></p></li>',4))])])])}const K=m(w,[["render",S]]),B=JSON.parse('{"path":"/kt.academy/cc-cancellation.html","title":"Cancellation in Kotlin Coroutines","lang":"en-US","frontmatter":{"lang":"en-US","title":"Cancellation in Kotlin Coroutines","description":"Article(s) > Cancellation in Kotlin Coroutines","icon":"iconfont icon-kotlin","category":["Java","Kotlin","Coroutines","Article(s)"],"tag":["blog","kt.academy","java","kotlin","coroutines"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Cancellation in Kotlin Coroutines\\",\\"image\\":[\\"https://marcinmoskala.com/coroutines_book/promotion/204_cancellation.jpg\\"],\\"datePublished\\":\\"2024-03-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Marcin Moskała\\",\\"url\\":\\"https://kt.academy/user/marcinmoskala\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/cc-cancellation.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Cancellation in Kotlin Coroutines"}],["meta",{"property":"og:description","content":"Article(s) > Cancellation in Kotlin Coroutines"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://marcinmoskala.com/coroutines_book/promotion/204_cancellation.jpg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://marcinmoskala.com/coroutines_book/promotion/204_cancellation.jpg"}],["meta",{"name":"twitter:image:alt","content":"Cancellation in Kotlin Coroutines"}],["meta",{"property":"article:author","content":"Marcin Moskała"}],["meta",{"property":"article:tag","content":"coroutines"}],["meta",{"property":"article:tag","content":"kotlin"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"kt.academy"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-03-11T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Cancellation in Kotlin Coroutines"},{"property":"og:description","content":"Cancellation in Kotlin Coroutines"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/cc-cancellation.html"}]],"prev":"/programming/java/articles/README.md","date":"2024-03-11T00:00:00.000Z","author":[{"name":"Marcin Moskała","url":"https://kt.academy/user/marcinmoskala"}],"cover":"https://marcinmoskala.com/coroutines_book/promotion/204_cancellation.jpg"},"git":{},"readingTime":{"minutes":14.72,"words":4416},"filePathRelative":"kt.academy/cc-cancellation.md","copyright":{"author":"Marcin Moskała"}}');export{K as comp,B as data};
