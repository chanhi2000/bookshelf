import{_ as k}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,d as a,f as e,b as i,a as b,t as f,n as d,g as h,w as o,e as n,r as p,o as y}from"./app-BVguHYKu.js";const w={},v={id:"frontmatter-title-관련",tabindex:"-1"},x={class:"header-anchor",href:"#frontmatter-title-관련"},I={class:"table-of-contents"},D={href:"https://github.com/spring-projects/spring-framework/issues/33788",target:"_blank",rel:"noopener noreferrer"},M={href:"https://youtrack.jetbrains.com/issue/KTOR-6462",target:"_blank",rel:"noopener noreferrer"},T={href:"https://github.com/spring-projects/spring-framework/issues/33788",target:"_blank",rel:"noopener noreferrer"};function q(u,s){const r=p("VPCard"),t=p("router-link"),m=p("SiteInfo"),l=p("VPIcon"),c=p("KotlinPlayground");return y(),g("div",null,[a("h1",v,[a("a",x,[a("span",null,f(u.$frontmatter.title)+" 관련",1)])]),e(r,d(h({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),a("nav",I,[a("ul",null,[a("li",null,[e(t,{to:"#the-idea"},{default:o(()=>s[0]||(s[0]=[n("The idea")])),_:1,__:[0]})]),a("li",null,[e(t,{to:"#why-dispatchers-unconfined-is-not-a-good-choice"},{default:o(()=>s[1]||(s[1]=[n("Why Dispatchers.Unconfined is not a good choice")])),_:1,__:[1]})]),a("li",null,[e(t,{to:"#why-runblocking-is-not-a-good-choice"},{default:o(()=>s[2]||(s[2]=[n("Why runBlocking is not a good choice")])),_:1,__:[2]})]),a("li",null,[e(t,{to:"#why-dispatchers-default-is-not-a-good-choice"},{default:o(()=>s[3]||(s[3]=[n("Why Dispatchers.Default is not a good choice")])),_:1,__:[3]})]),a("li",null,[e(t,{to:"#why-dispatchers-io-is-not-the-best-choice"},{default:o(()=>s[4]||(s[4]=[n("Why Dispatchers.IO is not the best choice")])),_:1,__:[4]})]),a("li",null,[e(t,{to:"#why-a-dispatcher-from-an-executor-is-not-the-best-choice"},{default:o(()=>s[5]||(s[5]=[n("Why a dispatcher from an executor is not the best choice")])),_:1,__:[5]})]),a("li",null,[e(t,{to:"#why-a-dispatcher-limited-to-a-certain-number-of-threads-is-the-best-choice"},{default:o(()=>s[6]||(s[6]=[n("Why a dispatcher limited to a certain number of threads is the best choice")])),_:1,__:[6]})]),a("li",null,[e(t,{to:"#why-loom-dispatcher-is-a-perfect-choice-but-only-once-it-gets-stable"},{default:o(()=>s[7]||(s[7]=[n("Why LOOM dispatcher is a perfect choice, but only once it gets stable")])),_:1,__:[7]})]),a("li",null,[e(t,{to:"#conclusion"},{default:o(()=>s[8]||(s[8]=[n("Conclusion")])),_:1,__:[8]})])])]),s[23]||(s[23]=a("hr",null,null,-1)),e(m,{name:"The best dispatcher for a backend framework",desc:"Let's explore different dispatchers and find the best one for a backend request handlers.",url:"https://kt.academy/article/dispatcher-for-backend",logo:"https://kt.academy/logo.png",preview:"https://marcinmoskala.com/kt-academy-articles/promotion/dispatcher-for-backend.jpg"}),a("p",null,[s[12]||(s[12]=n("I recently ")),a("a",D,[s[9]||(s[9]=n("started a discussion (")),e(l,{icon:"iconfont icon-github"}),s[10]||(s[10]=a("code",null,"spring-projects/spring-framework",-1)),s[11]||(s[11]=n(")"))]),s[13]||(s[13]=n(" about the best dispatcher for Spring Boot. Here I decided to summarize all the most important points, and explain why different options are not appropriate."))]),s[24]||(s[24]=i('<hr><h2 id="the-idea" tabindex="-1"><a class="header-anchor" href="#the-idea"><span>The idea</span></a></h2><p>When a request is made to a backend application, it should start a coroutine, but this coroutine must be running on a thread. A dispatcher is a context that decides on which thread the coroutine will run. This dispatcher should create as few threads as possible, because threads are expensive, but it should also possibly avoid situations where a request waits for a thread to be available.</p><p>Before I present the right options, let&#39;s consider the wrong ones.</p><hr><h2 id="why-dispatchers-unconfined-is-not-a-good-choice" tabindex="-1"><a class="header-anchor" href="#why-dispatchers-unconfined-is-not-a-good-choice"><span>Why <code>Dispatchers.Unconfined</code> is not a good choice</span></a></h2><p>Currently, the default dispatcher used by Spring Boot for suspending controller functions is <code>Dispatchers.Unconfined</code>. This choice might be fine for many applications, but it might underutilize the potential of our CPU, and work terribly if there are any blocking operations.</p><p>There is common misconception that <code>Dispatchers.Unconfined</code> runs on the thread that was used to start it. That is true, but only until the first suspension point. After that, it runs on the thread that was used to resume it, what is dangerous, because libraries are designed to use the minimal number of threads in their suspending API, and they often use only one thread to resume coroutines, as they assume a dispatcher will change it anyway (out of all dispatchers, only <code>Dispatchers.Unconfined</code> is not changing it).</p><p>Take a look at this example from my book <em>Kotlin Coroutines: Deep Dive</em>:</p>',9)),e(c,{title:"Dispatchers.Unconfined%20is%20not%20a%20good%20choice",key:"673676a5",settings:"%7B%7D",files:"eJydUjtOxDAQvYqVyqHwfugQsEWWE8BWhMI4E8XCGVv+oEWIu2OTbIijVDvd6M37zNivheyNtp58aK8knpnQVgcvERy7qTEDI4YiWAvo17A5r8Y2IOm5RFqS7xpJrE9uSVSIM4F7qfGOVLPu/oTSPx7IA8GgVGIMLN9Z4A1F3kPE6uLlr9/VxaSbqrq4PwttgB6lM9yLDqxjJ4ymbYSakikeUHRzYipjJXqFdJBm44pDR0uWrEuy2ZCLdUZ2wRnApuIoQCn+rmDKsvRJNT9A3Ef6fOQnne76bPuc3IDiX3S33W7L61RXPsURWh6UfzqDCF7bf90YPdtg/eH2i4cbEzgFYJZJ57c6MAsu9EDTNxlnJqtM5HYQiWDx9guaTOmJ"}),s[25]||(s[25]=i(`<p>As you can see, after suspension, the coroutine runs on the thread that resumed it, and after <code>delay</code> it runs on <code>DefaultExecutor</code>. This poor thread is only supposed to be used to schedule coroutines resuming, not to run their bodies. Above all, it is one for the whole application. Consider this simplified Spring Boot controller:</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="PingController.kt"><span>PingController.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token annotation builtin">@RestController</span></span>
<span class="line"><span class="token annotation builtin">@RequestMapping</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token function">PingController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation builtin">@GetMapping</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;/ping&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ResponseEntity<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span></span>
<span class="line">        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">ResponseEntity</span><span class="token punctuation">(</span><span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;success&quot;</span></span> <span class="token keyword">to</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> HttpStatus<span class="token punctuation">.</span>OK<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>If you make 1000 requests, it will take at least <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1001</mn><mtext>seconds</mtext></mrow><annotation encoding="application/x-tex">1001 \\text{seconds}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">1001</span><span class="mord text"><span class="mord">seconds</span></span></span></span></span>, as all sleeps will happen on <code>DefaultExecutor</code>. That is no good. If we used <code>Dispatchers.IO</code>, it would need <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1000</mn><mn>64</mn></mfrac><mo>+</mo><mn>1</mn><mo>=</mo><mn>17</mn><mtext>seconds</mtext></mrow><annotation encoding="application/x-tex">\\frac{1000}{64}+1=17 \\text{seconds}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">17</span><span class="mord text"><span class="mord">seconds</span></span></span></span></span> (due to IO limit). Of course, in a real-life example, we should have some db or network request instead of <code>delay</code>, and some processing instead of sleep, but the essential problem remains the same.</p><div class="code-block-with-title"><div class="code-block-title-bar" data-title="PingController.kt"><span>PingController.kt</span></div><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token annotation builtin">@RestController</span></span>
<span class="line"><span class="token annotation builtin">@RequestMapping</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token function">PingController</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation builtin">@GetMapping</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;/ping&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">suspend</span> <span class="token keyword">fun</span> <span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> ResponseEntity<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Boolean<span class="token operator">&gt;</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> <span class="token keyword">data</span> <span class="token operator">=</span> <span class="token function">fetchData</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token function">complexProcessing</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token function">ResponseEntity</span><span class="token punctuation">(</span><span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;success&quot;</span></span> <span class="token keyword">to</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> HttpStatus<span class="token punctuation">.</span>OK<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><p>Most suspending network clients optimize to use a minimal number of threads. In Ktor Client, for instance, most engines will use only one thread to resume coroutines, so delay is actually mimicking that pretty well. Consider the following example. On my computer, it takes 30 seconds with <code>Dispatchers.Unconfined</code>, but only 5 seconds if we used <code>Dispatchers.Default</code> instead:</p>`,5)),e(c,{title:"2",key:"3ed1da1c",settings:"%7B%7D",files:"eJxtUsFOwzAM/RWrAqnlEBWOkzixI0gcthNBKGpdGi11qsQdm6b9O84yBtvwxYnz8vz8krfCDqMPDCvPztJGNT74iS1hVHeazg5V3EbGQQ1o4hRwYQd8sc7ZqElTnOKI1EI3EQzGUlnNYEmW4RGu8LADTSDxZbl/8sS44XJu42i46TFEtaTGUyci2gp2GZoi4IiGy/u6rs/qKZyZqOkvqynWxkFr2IiSDqXBXNZldY1r/DA63LwG32CMlj7LdOsCuP/dHpeS9sohy1BjsMSOSl0svF/BjWVdVAkgyEuP/kiZQco/0lt0ZptnzIWAPAU6YJJsoWucifFU0CR914bxMKnYmzx/llQ+1LXWH9ktkKfYq9hPXeewzfeSjv+nzpJOJidSNZgx09zC/ZE3Mcr/yHwirHj/Br/avgI="}),s[26]||(s[26]=a("p",null,[n("So "),a("code",null,"Dispatchers.Unconfined"),n(" can be vulnerable to thread starvation after suspension points, and it is not a good choice for a backend application.")],-1)),s[27]||(s[27]=a("hr",null,null,-1)),s[28]||(s[28]=a("h2",{id:"why-runblocking-is-not-a-good-choice",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#why-runblocking-is-not-a-good-choice"},[a("span",null,[n("Why "),a("code",null,"runBlocking"),n(" is not a good choice")])])],-1)),s[29]||(s[29]=a("p",null,[n("It seems to be a natural for backend developers to expect that the best option would be the one, that would use the same thread that started the coroutine. This is exactly what "),a("code",null,"runBlocking"),n(" does. It starts a coroutine on the current thread, and creates a dispatcher that will always resume on that thread:")],-1)),e(c,{title:"2",key:"3ed0cbd4",settings:"%7B%7D",files:"eJytUctOwzAQ/JVVTg4HN+WIgErkF+CEOZhkAaubdeQHAiH+vXaTVGmaY0e+rGY9M7v7Wpiuty7A3gYy/CMb62wMhtHLG8VnZOK4ic4hhzVu/k/xR2TotGFRwp9iSPjWDpJC6ok6GMt3UM+q+xc24XEHD8CRaPiREb4c6law7jBxqng+1ltVnHQnuMhPZJu94c8lldE7w4FYDAJyHGSoRCmzQQmbDUwGFwI++h65rTU3SKTfCetp5jW/jPm4Kb0Jl23/eVlXy9ki6V+xraqqvJJqyncWc/0et4t7jDaeEPtlnPlSdtKhjx2KfP2xJ1mlV7wdAJrMy50="}),s[30]||(s[30]=i(`<p>The problem is, what happens to this thread when the coroutine is suspended. Since this thread must always be ready to be used by the coroutine, it cannot be used for anything else, so it is blocked. That means, if we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">100,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span> requests, and each need to get suspended for a second, for a second you would need <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">100,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span> threads, which would require 100 GB of RAM memory. That is a theoretical example, but I hope you see the point: <strong>using <code>runBlocking</code> would completely neglect the benefits of using coroutines</strong>. The key idea behind coroutines is that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">100,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span> requests should start 100,000 coroutines, suspend and resume them concurrently, using only a couple of threads. For that we need to use a dispatcher, so now let&#39;s consider some popular options.</p><hr><h2 id="why-dispatchers-default-is-not-a-good-choice" tabindex="-1"><a class="header-anchor" href="#why-dispatchers-default-is-not-a-good-choice"><span>Why <code>Dispatchers.Default</code> is not a good choice</span></a></h2><p><code>Dispatchers.Default</code> is the dispatcher designed for CPU-intensive tasks. It can use as many threads, as many CPU cores you have. In theory, it should be a good choice for a backend application, but in practice, it is not. <code>Dispatchers.Default</code> is only good if you never block its threads. Even one blocking operation will make your application significantly less efficient. Let&#39;s say you have 8 CPU cores, but you blocked one thread, so now your application only uses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>7</mn><mn>8</mn></mfrac></mrow><annotation encoding="application/x-tex">\\frac{7}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1901em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> of your CPU power. That is not good.</p><p><code>Dispatchers.Default</code> is very fragile to blocking operations, and since there are many blocking APIs we use on backend, it might be hard to hunt them all. That is why <code>Dispatchers.Default</code> is not a good choice for a backend application.</p><hr><h2 id="why-dispatchers-io-is-not-the-best-choice" tabindex="-1"><a class="header-anchor" href="#why-dispatchers-io-is-not-the-best-choice"><span>Why <code>Dispatchers.IO</code> is not the best choice</span></a></h2><p>Currently, many backend frameworks, including Ktor Server, use <code>Dispatcher.IO</code> as the default dispatcher for handling requests. It is a good choice, but not the best one. <code>Dispatchers.IO</code> is supposed to be used for blocking operations, so it is not a big problem if a limited number of blocking operations are executed on it. The problem starts if there are too many blocking operations. <code>Dispatchers.IO</code> is limited to 64 threads by default. It is good there is a limit because it prevents the application from using too many threads (which drains RAM). The problem is when something as important as a request is blocked, because it waits in a queue filled with less important operations.</p><p>Consider that your application includes a weekly mailing service. Once a week you need to send over 100,000, and for that you use SendGrid, that provides a blocking API. So you made the following code:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> scope <span class="token operator">=</span> <span class="token function">CoroutineScope</span><span class="token punctuation">(</span>Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation builtin">@Cron</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">&quot;0 0 0 * * 1&quot;</span></span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">fun</span> <span class="token function">sendEmails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    scope<span class="token punctuation">.</span><span class="token function">launch</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">val</span> newsletter <span class="token operator">=</span> <span class="token function">generateNewsletterIssue</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">val</span> emails <span class="token operator">=</span> <span class="token function">getNewsletterSubscribers</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        emails<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> email \\<span class="token operator">-&gt;</span> </span>
<span class="line">            launch <span class="token punctuation">{</span></span>
<span class="line">                <span class="token function">sendEmail</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> newsletter<span class="token punctuation">)</span> <span class="token comment">// Blocking operation</span></span>
<span class="line">            <span class="token punctuation">}</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10)),a("p",null,[s[16]||(s[16]=i('Considering that sending an email takes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mtext>ms</mtext></mrow><annotation encoding="application/x-tex">100 \\text{ms}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">100</span><span class="mord text"><span class="mord">ms</span></span></span></span></span>, and you need to send <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">100,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">100</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">000</span></span></span></span> of them, and you have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">64</span></span></span></span> threads, it will take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mn>100000</mn><mo>×</mo><mn>0.1</mn></mrow><mrow><mn>64</mn><mo>×</mo><mn>60</mn></mrow></mfrac><mo>=</mo><mn>2.6</mn><mtext>minutes</mtext></mrow><annotation encoding="application/x-tex">\\frac{100000\\times0.1}{64\\times60}=2.6 \\text{minutes}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2484em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8451em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">64</span><span class="mbin mtight">×</span><span class="mord mtight">60</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100000</span><span class="mbin mtight">×</span><span class="mord mtight">0.1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord">2.6</span><span class="mord text"><span class="mord">minutes</span></span></span></span></span>. Throughout that time, all other requests will be waiting in a queue. That is not good. (That is not an abstract example, see ',9)),a("a",M,[s[14]||(s[14]=n("this issue (")),e(l,{icon:"iconfont icon-jetbrains"}),s[15]||(s[15]=n(")"))]),s[17]||(s[17]=n(", but thankfully it is possible to change dispatcher in Ktor Client)."))]),s[31]||(s[31]=i(`<p>Of course, you could argue that it should be this service responsibility to use a dispatcher that is independent of the IO dispatcher, and I do accept that. That it why I still consider <code>Dispatchers.IO</code> as a good choice, but I think it would be better to protect handler threads from waiting in a queue in the first place, and for that I think it should be started on a different dispatcher.</p><hr><h2 id="why-a-dispatcher-from-an-executor-is-not-the-best-choice" tabindex="-1"><a class="header-anchor" href="#why-a-dispatcher-from-an-executor-is-not-the-best-choice"><span>Why a dispatcher from an executor is not the best choice</span></a></h2><p>When I mentioned creating a dispatcher that is independent of the IO dispatcher, I guess that many thought about creating a dispatcher from an executor:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That would be an option, but that wouldn&#39;t be the most efficient approach. Coroutines dispatchers have a mechanism of thread reuse: basically <code>Dispatchers.Default</code>, <code>Dispatchers.IO</code>, and <code>Dispatchers.IO.limitedParallelism(n)</code> reuse threads from the same pool. That let us maintain a smaller number of threads, and limit the number of thread switches. If we used a dispatcher from an executor, we would have a separate pool of threads, so we would lose this optimization.</p><hr><h2 id="why-a-dispatcher-limited-to-a-certain-number-of-threads-is-the-best-choice" tabindex="-1"><a class="header-anchor" href="#why-a-dispatcher-limited-to-a-certain-number-of-threads-is-the-best-choice"><span>Why a dispatcher limited to a certain number of threads is the best choice</span></a></h2><p>As I introduced already, I believe that the best solution is using a dispatcher that is limited to a certain number of threads, that should be created using the following structure:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Dispatchers<span class="token punctuation">.</span>IO<span class="token punctuation">.</span><span class="token function">limitedParallelism</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Such a dispatcher would be the safest option:</p><ul><li>It would not be hurt by a limited number of blocking operations, as it has some extra threads to handle them.</li><li>It would be independent of the IO dispatcher, so they would never block each other.</li><li>It would be more efficient than a dispatcher from an executor, as it would reuse threads from the same pool.</li></ul><p>The size of thread limit should be configurable, but I think that <code>max(64, #cores)</code> is a good default value (as it is the default value for <code>Dispatchers.IO</code>).</p><p>That is the best choice, unless your application can use virtual threads from Project Loom.</p><hr><h2 id="why-loom-dispatcher-is-a-perfect-choice-but-only-once-it-gets-stable" tabindex="-1"><a class="header-anchor" href="#why-loom-dispatcher-is-a-perfect-choice-but-only-once-it-gets-stable"><span>Why LOOM dispatcher is a perfect choice, but only once it gets stable</span></a></h2><p>Project Loom is a new Java feature, that was introduced as a preview in Java 19. Its basic idea is that it allows us to create a thread, that suspends process when it gets blocked. In simpler words, on such a thread you can use blocking operations like they are suspending operations (but without support for cancellation). When Project Loom is used, be can both utilize all the benefits of coroutines (structured concurrency, simple asynchronicity, cancellation, testability, etc.), and use blocking operations without any fear of blocking the thread. So IMHO this is a sweet spot for backend applications. This is how such a dispatcher would be created:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> dispatcher <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newVirtualThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">.</span><span class="token function">asCoroutineDispatcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>Virtual threads are stable since Java 21, so it is a perfect choice for JVM 21+, and since then it can be used by default in backend frameworks.</p><hr><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>In this article, I analyzed which dispatcher is the best choice for a backend application. My conclusion is that:</p><ul><li><code>Dispatchers.Unconfined</code> is not a good choice, as it can lead to inappropriate thread usage.</li><li><code>runBlocking</code> is not a good choice, as it can create too many threads unnecessarily.</li><li><code>Dispatchers.Default</code> is not a good choice, as it is fragile to blocking operations.</li><li><code>Dispatchers.IO</code> is a good choice, but it can be problematic if it is used for too many blocking operations.</li><li>A dispatcher from an executor is not the best choice, as it would not reuse threads from the same pool.</li><li>A dispatcher limited to a certain number of threads is the best choice, as it would be the safest option.</li><li>Loom dispatcher is a perfect choice for JVM 21+.</li></ul>`,23)),a("p",null,[s[21]||(s[21]=n("I hope this article will help resolve ")),a("a",T,[s[18]||(s[18]=n("this issue in Spring Boot (")),e(l,{icon:"iconfont icon-github"}),s[19]||(s[19]=a("code",null,"spring-projects/spring-framework",-1)),s[20]||(s[20]=n(")"))]),s[22]||(s[22]=n(", and in other backend frameworks. If you have any questions or comments, please let me know."))]),b(" TODO: add ARTICLE CARD "),e(r,d(h({title:"The best dispatcher for a backend framework",desc:"Let's explore different dispatchers and find the best one for a backend request handlers.",link:"https://chanhi2000.github.io/bookshelf/kt.academy/dispatcher-for-backend.html",logo:"https://kt.academy/logo.png",background:"rgba(243,139,49,0.2)"})),null,16)])}const O=k(w,[["render",q]]),E=JSON.parse('{"path":"/kt.academy/dispatcher-for-backend.html","title":"The best dispatcher for a backend framework","lang":"en-US","frontmatter":{"lang":"en-US","title":"The best dispatcher for a backend framework","description":"Article(s) > The best dispatcher for a backend framework","icon":"iconfont icon-kotlin","category":["Java","Kotlin","Article(s)"],"tag":["blog","kt.academy","java","kotlin"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"The best dispatcher for a backend framework\\",\\"image\\":[\\"https://marcinmoskala.com/kt-academy-articles/promotion/dispatcher-for-backend.jpg\\"],\\"datePublished\\":\\"2024-11-13T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Marcin Moskała\\",\\"url\\":\\"https://kt.academy/user/marcinmoskala\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/dispatcher-for-backend.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"The best dispatcher for a backend framework"}],["meta",{"property":"og:description","content":"Article(s) > The best dispatcher for a backend framework"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://marcinmoskala.com/kt-academy-articles/promotion/dispatcher-for-backend.jpg"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://marcinmoskala.com/kt-academy-articles/promotion/dispatcher-for-backend.jpg"}],["meta",{"name":"twitter:image:alt","content":"The best dispatcher for a backend framework"}],["meta",{"property":"article:author","content":"Marcin Moskała"}],["meta",{"property":"article:tag","content":"kotlin"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"kt.academy"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-11-13T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > The best dispatcher for a backend framework"},{"property":"og:description","content":"The best dispatcher for a backend framework"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/dispatcher-for-backend.html"}]],"prev":"/programming/java/articles/README.md","date":"2024-11-13T00:00:00.000Z","isOriginal":false,"author":[{"name":"Marcin Moskała","url":"https://kt.academy/user/marcinmoskala"}],"cover":"https://marcinmoskala.com/kt-academy-articles/promotion/dispatcher-for-backend.jpg"},"git":{},"readingTime":{"minutes":7.24,"words":2173},"filePathRelative":"kt.academy/dispatcher-for-backend.md","copyright":{"author":"Marcin Moskała"}}');export{O as comp,E as data};
