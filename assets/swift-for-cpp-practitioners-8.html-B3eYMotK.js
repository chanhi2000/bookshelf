import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,d as a,f as e,b as l,t as h,n as c,g as d,w as t,e as n,r as p,o as f}from"./app-BItykJLQ.js";const b={},v={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},y={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},w={class:"table-of-contents"},z={href:"https://developer.apple.com/documentation/swift/objectidentifier",target:"_blank",rel:"noopener noreferrer"},x={href:"https://p65warnings.ca.gov",target:"_blank",rel:"noopener noreferrer"},R={href:"https://en.cppreference.com/w/cpp/language/siof",target:"_blank",rel:"noopener noreferrer"},S={href:"https://pabloariasal.github.io/2020/01/02/static-variable-initialization/",target:"_blank",rel:"noopener noreferrer"},C={href:"https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use",target:"_blank",rel:"noopener noreferrer"},T={href:"https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_once.html",target:"_blank",rel:"noopener noreferrer"},I={href:"https://en.cppreference.com/w/cpp/language/constinit",target:"_blank",rel:"noopener noreferrer"};function P(g,s){const r=p("VPCard"),i=p("router-link"),u=p("RouteLink"),o=p("VPIcon");return f(),k("div",null,[a("h1",v,[a("a",y,[a("span",null,h(g.$frontmatter.title)+" ê´€ë ¨",1)])]),e(r,c(d({title:"Swift > Article(s)",desc:"Article(s)",link:"/programming/swift/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),e(r,c(d({title:"C++ > Article(s)",desc:"Article(s)",link:"/programming/cpp/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),a("nav",w,[a("ul",null,[a("li",null,[e(i,{to:"#global-variables-static-variables"},{default:t(()=>[...s[0]||(s[0]=[n("Global variables & static variables",-1)])]),_:1})]),a("li",null,[e(i,{to:"#no-generic-static-variables"},{default:t(()=>[...s[1]||(s[1]=[n("(No) generic static variables",-1)])]),_:1})]),a("li",null,[e(i,{to:"#static-initialization-in-c"},{default:t(()=>[...s[2]||(s[2]=[n("Static initialization in C++",-1)])]),_:1})]),a("li",null,[e(i,{to:"#lazy-initialization-in-swift"},{default:t(()=>[...s[3]||(s[3]=[n("Lazy initialization in Swift",-1)])]),_:1})]),a("li",null,[e(i,{to:"#lazy-initialization-for-instance-properties"},{default:t(()=>[...s[4]||(s[4]=[n("Lazy initialization for instance properties",-1)])]),_:1})]),a("li",null,[e(i,{to:"#no-guaranteed-constant-initialization"},{default:t(()=>[...s[5]||(s[5]=[n("No guaranteed constant initialization",-1)])]),_:1})]),a("li",null,[e(i,{to:"#wrap-up"},{default:t(()=>[...s[6]||(s[6]=[n("Wrap-up",-1)])]),_:1})])])]),s[50]||(s[50]=a("hr",null,null,-1)),e(r,c(d({title:"Swift for C++ Practitioners, Part 8: Global Variables | Doug's Compiler Corner",desc:"Swift for C++ Practitioners, Part 8: Global Variables",link:"https://www.douggregor.net/posts/swift-for-cxx-practitioners-global-variables/",background:"rgba(22,22,22,0.2)"})),null,16),s[51]||(s[51]=l(`<p>At the end of part 7, I promised I was going to talk about Swift language extensibility next. That post is taking some time, and today the differences between global variables in C++ and Swift came up in a discussion. So, here&#39;s a little interlude on our way to language extensibility to talk about global variables.</p><hr><h2 id="global-variables-static-variables" tabindex="-1"><a class="header-anchor" href="#global-variables-static-variables"><span>Global variables &amp; static variables</span></a></h2><p>The basic idea of global variables is the same in Swift as in C++. In C++ you can define a variable at namespace scope, like this:</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">Registry <span class="token operator">*</span>globalRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>and it&#39;s accessible from anywhere. Swift has the same for variables declared at module scope, e.g.,</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">let</span> globalRegistry<span class="token punctuation">:</span> <span class="token class-name">Registry</span> <span class="token operator">=</span> <span class="token class-name">Registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>You can draw the same parallels between C++ and Swift static variables, so where in C++ you would write:</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">class</span> <span class="token class-name">Registry</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">public</span><span class="token operator">:</span></span>
<span class="line">  <span class="token comment">// Declaration</span></span>
<span class="line">  <span class="token keyword">static</span> Registry <span class="token operator">*</span>sharedRegistry<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Definition</span></span>
<span class="line">Registry <span class="token operator">*</span>Registry<span class="token double-colon punctuation">::</span>sharedRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>in Swift you can do the same:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">class</span> <span class="token class-name">Registry</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">let</span> sharedRegistry<span class="token punctuation">:</span> <span class="token class-name">Registry</span> <span class="token operator">=</span> <span class="token class-name">Registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Totally straightforward, no surprises here... yet.</p><hr><h2 id="no-generic-static-variables" tabindex="-1"><a class="header-anchor" href="#no-generic-static-variables"><span>(No) generic static variables</span></a></h2><p>In C++, it&#39;s fairly common to have static variables within a class template. For example, perhaps we want a &quot;registry&quot; above, but for each type <code>T</code>. One might write that in C++ as:</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Registry</span> <span class="token punctuation">{</span></span>
<span class="line"><span class="token keyword">public</span><span class="token operator">:</span></span>
<span class="line">  <span class="token comment">// Declaration</span></span>
<span class="line">  <span class="token keyword">static</span> Registry<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>sharedRegistry<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Definition</span></span>
<span class="line"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">Registry<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">*</span>Registry<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>sharedRegistry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Registry</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That&#39;s fine: we&#39;ll get a separate <code>Registry&lt;T&gt;::sharedRegistry</code> for every <code>T</code> The equivalent in Swift produces a compiler error:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">class</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// error: static stored properties not supported in generic types</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">let</span> sharedRegistry<span class="token punctuation">:</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,18)),a("p",null,[s[8]||(s[8]=n("Why does Swift ban this? As I noted back in ",-1)),e(u,{to:"/douggregor.net/swift-for-cpp-practitioners-4.html"},{default:t(()=>[...s[7]||(s[7]=[n("part 4 on generics",-1)])]),_:1}),s[9]||(s[9]=n(", Swift's generics are implemented with separate compilation. We do not know at the point where ",-1)),s[10]||(s[10]=a("code",null,"sharedRegistry",-1)),s[11]||(s[11]=n(" is defined what types it will be specialized with, and in the general case (say, ",-1)),s[12]||(s[12]=a("code",null,"Registry",-1)),s[13]||(s[13]=n(" is in a shared library), it's impossible to know what types it will be specialized with until the program runs. Therefore, we can't allocate space from global memory for every ",-1)),s[14]||(s[14]=a("code",null,"Registry<T>.sharedRegistry",-1)),s[15]||(s[15]=n(" that we might come across.",-1))]),s[52]||(s[52]=a("p",null,[n("Yes, we "),a("em",null,"could"),n(" create a hash table indexed based on the generic argument for "),a("code",null,"T"),n(", allocating new "),a("code",null,"sharedRegistry"),n(" instances on the heap each time there's a new generic argument... but this is "),a("em",null,"really"),n(' stretching the definition of "global variable", and the performance of such a feature would be surprising (to say the least). Instead, Swift prohibits static stored properties in generic types rather than provide an unsatisfying implementation.')],-1)),a("p",null,[s[17]||(s[17]=n("If you really want that hash table implementation, you can build it by following the examples in ",-1)),e(u,{to:"/douggregor.net/swift-for-cpp-practitioners-5.html"},{default:t(()=>[...s[16]||(s[16]=[n("part 5 on type erasure",-1)])]),_:1}),s[18]||(s[18]=n(", and it'll look a little bit like this:",-1))]),s[53]||(s[53]=l(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">fileprivate</span> <span class="token keyword">var</span> untypedSharedRegistry<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">ObjectIdentifier</span><span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">var</span> sharedRegistry<span class="token punctuation">:</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    untypedSharedRegistry<span class="token punctuation">[</span><span class="token class-name">ObjectIdentifier</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">.</span><span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token class-name">Registry</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[20]||(s[20]=n("Here, ",-1)),s[21]||(s[21]=a("code",null,"untypedSharedRegistry",-1)),s[22]||(s[22]=n(" maps from the metatype for ",-1)),s[23]||(s[23]=a("code",null,"T",-1)),s[24]||(s[24]=n(" (represented as an ",-1)),a("a",z,[e(o,{icon:"fa-brands fa-apple"}),s[19]||(s[19]=a("code",null,"ObjectIdentifier",-1))]),s[25]||(s[25]=l(", which is a fancy way of saying &quot;identity for something with a stable address&quot;) to a type-erased value of type <code>Any</code>. All of the <code>Any</code> instances in the dictionary are actually <code>Registry&lt;T&gt;</code> instances matching the type <code>T</code> that went into the <code>ObjectIdentifier</code>, so we force-cast (with <code>as!</code>) the element on the way out. So long as nobody fiddles with <code>untypedSharedRegistry</code>, that force-cast will never fail.",15))]),s[54]||(s[54]=a("p",null,"So far, Swift global and static variables are the same as C++ global and static variables, except that Swift static variables can't be generic. Things will start to diverge more when we get to initialization.",-1)),s[55]||(s[55]=a("hr",null,null,-1)),s[56]||(s[56]=a("h2",{id:"static-initialization-in-c",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#static-initialization-in-c"},[a("span",null,"Static initialization in C++")])],-1)),a("p",null,[s[28]||(s[28]=n("Initialization of C++ globals and statics is ",-1)),a("a",x,[e(o,{icon:"fas fa-globe"}),s[26]||(s[26]=n("known by the State of California to cause headaches and lost productivity",-1))]),s[29]||(s[29]=n(". Indeed, doing a web search for C++ static initialization order turns up a page titled ",-1)),a("a",R,[e(o,{icon:"iconfont icon-cpp"}),s[27]||(s[27]=n("Static Initialization Order Fiasco",-1))]),s[30]||(s[30]=n(" as its second hit.",-1))]),a("p",null,[s[33]||(s[33]=n("It's useful to understand why static initialization is tricky in C++, so that we can explain the path Swift took. C++ initializes global and static variables on a per-translation-unit basis, starting at the first global or static variable and proceeding to the last. However, it is unspecified in what order the different translation units in a program get to run their initializers. So if you have a global variable in translation unit ",-1)),s[34]||(s[34]=a("code",null,"x.cpp",-1)),s[35]||(s[35]=n(" that somehow depends on a global variable in ",-1)),s[36]||(s[36]=a("code",null,"y.cpp",-1)),s[37]||(s[37]=n(", you might be okay (if ",-1)),s[38]||(s[38]=a("code",null,"y.cpp",-1)),s[39]||(s[39]=n(" has its initializers run first) or your code might crash (if ",-1)),s[40]||(s[40]=a("code",null,"x.cpp",-1)),s[41]||(s[41]=n(" has its initializers run first). I don't want to go into all of the solutions for C++ here(this ",-1)),a("a",S,[e(o,{icon:"fas fa-globe"}),s[31]||(s[31]=n("blog post on C++ Initialization of Static Variables",-1))]),s[42]||(s[42]=n(" covers some). However, I will point out that the most general solution is ",-1)),a("a",C,[e(o,{icon:"fas fa-globe"}),s[32]||(s[32]=n("Initialize on First Use",-1))]),s[43]||(s[43]=n(", which uses a function-local static instead of a global variable or static class member:",-1))]),s[57]||(s[57]=l(`<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code class="language-cpp"><span class="line">Registry<span class="token operator">&amp;</span> <span class="token function">sharedRegistry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> Registry<span class="token operator">*</span> registry <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Registry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token operator">*</span>registry<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),a("p",null,[s[45]||(s[45]=n("C++ function-local statics are interesting because they are guaranteed to be initialized on first use, and for most (all?) C++ implementations that initialization uses something like ",-1)),a("a",T,[e(o,{icon:"fas fa-globe"}),s[44]||(s[44]=a("code",null,"pthread_once",-1))]),s[46]||(s[46]=n(" to ensure that the initialization is thread-safe. Such a nice model, that...",-1))]),s[58]||(s[58]=l(`<p>While we&#39;re here, there&#39;s another reason to dislike static initialization in C++: you always pay the runtime cost for running the initializers of global and static variables, even if you never use them. This cost can come at unfortunate times in your program, such as program startup and when loading a shared library. Many code bases prohibit global initializers to prevent this cost, using something like Clang&#39;s <code>-Wglobal-constructors</code> warning.</p><hr><h2 id="lazy-initialization-in-swift" tabindex="-1"><a class="header-anchor" href="#lazy-initialization-in-swift"><span>Lazy initialization in Swift</span></a></h2><p>Initialization of global and static variables in Swift applies the &quot;Initialize on First Use&quot; principle, always. There is no notion of a Swift &quot;global initializer&quot; that is run prior to <code>main</code>, or when a shared library is loaded. Rather, like function-local statics in C++, every global and static variable is protected so that its initializer runs at most once, on the first initialization, using something like <code>pthread_once</code> to make the initialization itself thread-safe.</p><p>This approach has a lot of nice properties: the Static Initialization Order Fiasco just doesn&#39;t exist in Swift, so you don&#39;t need to introduce tricks to avoid it. You only pay the cost of initializing those global variables that you actually use, and that cost is paid when you use it the first time---not at program startup. An unused global variable (say, in a library) have very little cost at all: just the space it takes up in memory. The overhead of something like <code>pthread_once</code> is fairly low for the thread-safety it brings to the model.</p><p>The only real downside I&#39;ve seen to this approach is that it can be surprising if you&#39;re expecting to use the initialization of a global for its side effects, or have some other reason to expect and want the C++ semantics.</p><hr><h2 id="lazy-initialization-for-instance-properties" tabindex="-1"><a class="header-anchor" href="#lazy-initialization-for-instance-properties"><span>Lazy initialization for instance properties</span></a></h2><p>The stored instance properties of a struct or class are initialized as part of the initializer, and will remain initialized until the struct or class is destroyed. However, one can get lazy initialization semantics for instance properties by using the <code>lazy</code> keyword. For example, let&#39;s imagine that a class has some expensive-to-initialize instance property that isn&#39;t used all that often. We could make it lazily created by using an optional as the underlying storage, and using a computed property to access the conceptual value:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// Underlying storage</span></span>
<span class="line">  <span class="token keyword">private</span> <span class="token keyword">var</span> expensiveImpl<span class="token punctuation">:</span> <span class="token class-name">Expensive</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token nil constant">nil</span></span>
<span class="line">  </span>
<span class="line">  <span class="token comment">// The property available everywhere else.</span></span>
<span class="line">  <span class="token keyword">var</span> expensive<span class="token punctuation">:</span> <span class="token class-name">Expensive</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">mutating</span> <span class="token keyword">get</span> <span class="token punctuation">{</span> </span>
<span class="line">      <span class="token comment">// If we already have a value, return it.</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token keyword">let</span> existing <span class="token operator">=</span> expensiveImpl <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">return</span> existing</span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">      </span>
<span class="line">      <span class="token comment">// Create a new value and stash it in the underlying storage for later use.</span></span>
<span class="line">      <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token class-name">Expensive</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">      expensiveImpl <span class="token operator">=</span> value</span>
<span class="line">      <span class="token keyword">return</span> value</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">set</span> <span class="token punctuation">{</span></span>
<span class="line">      expensiveImpl <span class="token operator">=</span> newValue</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>That&#39;s a lot of code, but it&#39;s mostly straightforward: <code>expensiveImpl</code> starts out by storing <code>nil</code>, and is replaced by either the default value (if accessed first via the getter) or the value assigned into it (if accessed first via the setter). This lazy initialization is effectively invisible to the user, who accesses the value through the computed property <code>expensive</code>, and is similar to what happens under the hood for global and static variables (minus the thread-safety).</p><p>This kind of construct comes up a lot in certain kinds of programming, and it&#39;s a ton of boilerplate to write out each time. Therefore, Swift lets you do the same thing directly with a <code>lazy var</code>:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line"><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">lazy</span> <span class="token keyword">var</span> expensive<span class="token punctuation">:</span> <span class="token class-name">Expensive</span> <span class="token operator">=</span> <span class="token class-name">Expensive</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The effect of this code is the same as the prior example, but the Swift compiler is doing the work of introducing the stored property of type <code>Expensive?</code> behind the scenes and making <code>expensive</code> computed. Note that <code>lazy</code> variables do <em>not</em> need to be initialized within an initializer, because they get the default initialization to <code>nil</code>.</p><p>Unlike global and static variables, a <code>lazy var</code> does <em>not</em> provide thread-safe initialization. The reasoning here is that, if multiple threads are accessing a given instance of a struct or class concurrently, <em>you already have a data race</em>. There&#39;s no point in having the compiler increase the size of each struct or class instance, and pay the cost of something like <code>pthread_once</code>, to protect against a second-order data race. Rather, Swift&#39;s model is moving toward eliminating this class of data races entirely in Swift 6.</p><hr><h2 id="no-guaranteed-constant-initialization" tabindex="-1"><a class="header-anchor" href="#no-guaranteed-constant-initialization"><span>No guaranteed constant initialization</span></a></h2>`,17)),a("p",null,[s[48]||(s[48]=n("One feature of C++ initialization is that has no analogue yet in Swift is constant initialization. For example, with C++ ",-1)),a("a",I,[e(o,{icon:"iconfont icon-cpp"}),s[47]||(s[47]=a("code",null,"constinit",-1))]),s[49]||(s[49]=n(" it's possible to guarantee that there is no runtime initialization for a declaration:",-1))]),s[59]||(s[59]=l(`<div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line">constinit int buckets <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>C++ programmers often depend on constant initialization to avoid the problems of static initialization I&#39;ve talked about here. It can also be important in low-level systems where you might not even have the ability to perform initialization prior to <code>main</code>.</p><p>Swift has no such feature. I expect that at some point it will get a feature similar to C++20 <code>constinit</code>, which guarantees that a particular initialization produces a constant value that requires no run-time code execution. However, Swift still needs a model of constant evaluation for that to happen, and as of this writing there isn&#39;t yet a complete design to point to.</p><hr><h2 id="wrap-up" tabindex="-1"><a class="header-anchor" href="#wrap-up"><span>Wrap-up</span></a></h2><p>Global and static variables in Swift are conceptually similar to those in C++, and used for much the same purpose. However, Swift takes the &quot;Initialize on First Use&quot; principle all the way, with all global and static variables being initialized on first use. Function-local statics in Swift work identically to those in C++, based on the same &quot;Initialize on First Use&quot; principle.</p>`,6))])}const A=m(b,[["render",P]]),q=JSON.parse('{"path":"/douggregor.net/swift-for-cpp-practitioners-8.html","title":"Swift for C++ Practitioners, Part 8: Global Variables","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Swift for C++ Practitioners, Part 8: Global Variables","description":"Article(s) > Swift for C++ Practitioners, Part 8: Global Variables","icon":"fa-brands fa-swift","category":["Swift","C++","Article(s)"],"tag":["blog","douggregor.net","swift","ios","c++","cpp"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Swift for C++ Practitioners, Part 8: Global Variables\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-21T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/douggregor.net/swift-for-cpp-practitioners-8.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Swift for C++ Practitioners, Part 8: Global Variables"}],["meta",{"property":"og:description","content":"Article(s) > Swift for C++ Practitioners, Part 8: Global Variables"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"property":"article:tag","content":"cpp"}],["meta",{"property":"article:tag","content":"c++"}],["meta",{"property":"article:tag","content":"ios"}],["meta",{"property":"article:tag","content":"swift"}],["meta",{"property":"article:tag","content":"douggregor.net"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-05-21T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Swift for C++ Practitioners, Part 8: Global Variables"},{"property":"og:description","content":"Swift for C++ Practitioners, Part 8: Global Variables"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/douggregor.net/swift-for-cpp-practitioners-7.html"}]],"prev":"/programming/swift/articles/README.md","date":"2024-05-21T00:00:00.000Z","isOriginal":false},"git":{},"readingTime":{"minutes":6.85,"words":2056},"filePathRelative":"douggregor.net/swift-for-cpp-practitioners-8.md"}');export{A as comp,q as data};
