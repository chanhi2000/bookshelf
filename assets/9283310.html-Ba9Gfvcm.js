import{_ as g}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,d as s,f as e,b as i,a as k,t as b,n as r,g as c,w as p,e as n,r as m,o as v}from"./app-BItykJLQ.js";const y="/bookshelf/assets/image/d2.naver.com/9283310/russell.png",f={},w={id:"frontmatter-title-관련",tabindex:"-1"},x={class:"header-anchor",href:"#frontmatter-title-관련"},A={class:"table-of-contents"},M={href:"https://naver.me/Gq8Plxdp",target:"_blank",rel:"noopener noreferrer"},T={href:"https://en.wikipedia.org/wiki/Foundations_of_mathematics",target:"_blank",rel:"noopener noreferrer"},B={href:"https://en.wikipedia.org/wiki/Russell%27s_paradox",target:"_blank",rel:"noopener noreferrer"},S={href:"https://en.wikipedia.org/wiki/Alonzo_Church",target:"_blank",rel:"noopener noreferrer"},q={href:"https://en.wikipedia.org/wiki/Lambda_calculus",target:"_blank",rel:"noopener noreferrer"},j={href:"https://plato.stanford.edu/entries/type-theory/",target:"_blank",rel:"noopener noreferrer"},R={href:"https://javascript.xgqfrms.xyz/pdfs/TypeScript%20Language%20Specification.pdf",target:"_blank",rel:"noopener noreferrer"},L={href:"https://en.wikipedia.org/wiki/Total_order",target:"_blank",rel:"noopener noreferrer"},X={href:"https://en.wikipedia.org/wiki/Partially_ordered_set",target:"_blank",rel:"noopener noreferrer"},C={class:"hint-container info"};function V(d,a){const o=m("VPCard"),t=m("router-link"),u=m("SiteInfo"),l=m("VPIcon");return v(),h("div",null,[s("h1",w,[s("a",x,[s("span",null,b(d.$frontmatter.title)+" 관련",1)])]),e(o,r(c({title:"TypeScript > Article(s)",desc:"Article(s)",link:"/programming/ts/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",A,[s("ul",null,[s("li",null,[e(t,{to:"#이-글을-읽으면-좋은-분"},{default:p(()=>[...a[0]||(a[0]=[n("이 글을 읽으면 좋은 분",-1)])]),_:1})]),s("li",null,[e(t,{to:"#타입-이론의-역사적-배경"},{default:p(()=>[...a[1]||(a[1]=[n("타입 이론의 역사적 배경",-1)])]),_:1})]),s("li",null,[e(t,{to:"#typescript와-타입-이론"},{default:p(()=>[...a[2]||(a[2]=[n("TypeScript와 타입 이론",-1)])]),_:1})]),s("li",null,[e(t,{to:"#타입이란"},{default:p(()=>[...a[3]||(a[3]=[n("타입이란",-1)])]),_:1})]),s("li",null,[e(t,{to:"#타입은-부분순서집합"},{default:p(()=>[...a[4]||(a[4]=[n("타입은 부분순서집합",-1)])]),_:1})]),s("li",null,[e(t,{to:"#타입과-값의-대입"},{default:p(()=>[...a[5]||(a[5]=[n("타입과 값의 대입",-1)])]),_:1})]),s("li",null,[e(t,{to:"#타입의-종류에-따른-대소-비교"},{default:p(()=>[...a[6]||(a[6]=[n("타입의 종류에 따른 대소 비교",-1)])]),_:1}),s("ul",null,[s("li",null,[e(t,{to:"#원시-타입-primitive-type"},{default:p(()=>[...a[7]||(a[7]=[n("원시 타입(primitive type)",-1)])]),_:1})]),s("li",null,[e(t,{to:"#리터럴-타입-literal-type"},{default:p(()=>[...a[8]||(a[8]=[n("리터럴 타입(literal type)",-1)])]),_:1})]),s("li",null,[e(t,{to:"#객체-타입-object-type"},{default:p(()=>[...a[9]||(a[9]=[n("객체 타입(object type)",-1)])]),_:1})]),s("li",null,[e(t,{to:"#배열-튜플-타입"},{default:p(()=>[...a[10]||(a[10]=[n("배열/튜플 타입",-1)])]),_:1})]),s("li",null,[e(t,{to:"#키-타입-keyof"},{default:p(()=>[...a[11]||(a[11]=[n("키 타입(keyof)",-1)])]),_:1})]),s("li",null,[e(t,{to:"#함수-타입"},{default:p(()=>[...a[12]||(a[12]=[n("함수 타입",-1)])]),_:1})]),s("li",null,[e(t,{to:"#특수-타입"},{default:p(()=>[...a[13]||(a[13]=[n("특수 타입",-1)])]),_:1})])])]),s("li",null,[e(t,{to:"#퀴즈"},{default:p(()=>[...a[14]||(a[14]=[n("퀴즈",-1)])]),_:1})]),s("li",null,[e(t,{to:"#마치며"},{default:p(()=>[...a[15]||(a[15]=[n("마치며",-1)])]),_:1})])])]),a[41]||(a[41]=s("hr",null,null,-1)),e(u,{name:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론",url:"https://d2.naver.com/helloworld/9283310",logo:"/assets/image/d2.naver.com/favicon.ico",preview:"/assets/image/d2.naver.com/9283310/banner.jpg"}),s("p",null,[a[17]||(a[17]=n("'infer, never만 보면 두려워지는 당신을 위한 타입 추론' 관련 영상은 ",-1)),s("a",M,[e(l,{icon:"fas fa-globe"}),a[16]||(a[16]=n("링크",-1))]),a[18]||(a[18]=n("에서 보실 수 있습니다.",-1))]),a[42]||(a[42]=i('<p>TypeScript(이하 TS)는 JavaScript(이하 JS)의 런타임 취약성을 극복하고자, 타입 이론을 도입하여 정적 분석을 실현한 언어입니다. 하지만 대다수의 웹 애플리케이션 개발 과정에선 TS의 기능을 깊게 사용할 일은 드뭅니다. 기껏해야 인터페이스를 선언하거나, <code>Record</code> 등의 유틸리티 타입 일부를 쓰는 정도입니다.</p><p>그러나 라이브러리를 개발한다면 이야기는 달라집니다. 사실상 TS가 필수가 된 시대상 속에, 심지어 TS를 사용하지 않는 사람조차 IDE의 타입 추론 기능 수혜를 받고 있을 정도로, 타입은 빼놓을 수 없는 관심사가 되었습니다. 타입 추론이 제대로 이루어지지 않으면 라이브러리의 사용성은 현저히 떨어집니다.</p><p>제대로 된 타입 추론을 실현하려면, 수학적으로 타입 이론을 이해하고 적용할 수 있어야 합니다. 이 글의 시리즈는 TS를 관통하는 타입 추론의 원리를 기초 타입 이론과 고급 타입 추론으로 나누어 살펴보고, 라이브러리 개발자가 경험할 법한 실전 문제를 풀어봅니다. 단번에 읽기엔 벅찰 수 있습니다. 여유가 있다면 천천히 음미하시면서 학습하시는 것을 권장합니다.</p><hr><h2 id="이-글을-읽으면-좋은-분" tabindex="-1"><a class="header-anchor" href="#이-글을-읽으면-좋은-분"><span>이 글을 읽으면 좋은 분</span></a></h2><ul><li>JS 라이브러리 개발자</li><li>타입이 추론되는 원리가 궁금한 개발자</li><li>infer 등으로 고급 제네릭을 사용해 보고 싶은 개발자</li></ul><hr><h2 id="타입-이론의-역사적-배경" tabindex="-1"><a class="header-anchor" href="#타입-이론의-역사적-배경"><span>타입 이론의 역사적 배경</span></a></h2>',8)),s("p",null,[a[21]||(a[21]=n("타입 이론의 근간에는 ",-1)),s("a",T,[e(l,{icon:"fa-brands fa-wikipedia-w"}),a[19]||(a[19]=n("수학기초론(foundation of mathematics)",-1))]),a[22]||(a[22]=n("이 있습니다. 20세기 이전까지만 하더라도 수학은 생각보다 엄밀하지 않았는데요, 1908년 ",-1)),s("a",B,[e(l,{icon:"fa-brands fa-wikipedia-w"}),a[20]||(a[20]=n("러셀의 역설",-1))]),a[23]||(a[23]=n("이 발견되며 모든 수학의 기초인 집합이 흔들립니다. 이 문제를 해결하고자 ZFC 공리계, 괴델의 불완전성 정리 등의 엄밀한 고찰이 계속되었습니다.",-1))]),a[43]||(a[43]=s("figure",null,[s("img",{src:y,alt:"러셀의 역설의 발견",tabindex:"0",loading:"lazy"}),s("figcaption",null,"러셀의 역설의 발견")],-1)),s("p",null,[a[27]||(a[27]=n("타입 이론은 위대한 과학자 중 하나인 ",-1)),s("a",S,[e(l,{icon:"fa-brands fa-wikipedia-w"}),a[24]||(a[24]=n("앨런조 처치(Alanzo Church)",-1))]),a[28]||(a[28]=n("가 ",-1)),s("a",q,[e(l,{icon:"fa-brands fa-wikipedia-w"}),a[25]||(a[25]=n("람다 대수(lambda calculus)",-1))]),a[29]||(a[29]=n("를 고찰하면서 탄생했습니다. 처치 외에도 많은 수학자가 유사한 시도를 했고, 비교적 최근까지도 학계에서 다뤄지는 주제라고 합니다. 수리철학적으로 더 자세한 내용을 알고 싶다면 ",-1)),s("a",j,[e(l,{icon:"fas fa-globe"}),a[26]||(a[26]=n("스탠포드 대학의 자료",-1))]),a[30]||(a[30]=n("를 참고해 주세요.",-1))]),a[44]||(a[44]=s("hr",null,null,-1)),a[45]||(a[45]=s("h2",{id:"typescript와-타입-이론",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#typescript와-타입-이론"},[s("span",null,"TypeScript와 타입 이론")])],-1)),s("p",null,[a[32]||(a[32]=n("TS 1.8까지는 ",-1)),s("a",R,[e(l,{icon:"fas fa-globe"}),a[31]||(a[31]=n("공식 문서",-1))]),a[33]||(a[33]=n("가 존재했으나, 이후 Microsoft가 문서 유지보수를 포기했습니다. 때문에 현재 TS의 사양은 TypeScript 컴파일러(이하 tsc)의 구현 그 자체가 된 상황입니다. 게다가 구버전 문서에도 일관성 있는 타입 추론 알고리즘에 대한 정보는 찾아보기가 어렵습니다.",-1))]),a[46]||(a[46]=i(`<p>따라서 이 글에서는 tsc를 블랙박스로 간주하고, 수학적 일관성과 실험을 근거로 얻은 내용을 서술합니다. 만약 이 글의 내용과 충돌하는 사항이 있다면, TS 저장소의 Discussion에서 논의하는 것을 권장합니다. 시간이 지나 버전이 바뀌면 동작이 변경될 수 있습니다. 또한 이 글에서는 실용적인 개발을 돕기 위해, 엄밀함을 다소 포기하고 간결한 설명을 목표로 했음을 알립니다.</p><hr><h2 id="타입이란" tabindex="-1"><a class="header-anchor" href="#타입이란"><span>타입이란</span></a></h2><p>타입은 다음과 같이 정의할 수 있습니다.</p><blockquote><p>어떤 심벌(symbol, ≒변수명)에 엮인(binded) 메모리 공간에 존재할 수 있는 값(value)의 집합과 그 값들이 가질 수 있는 성질(properties)</p></blockquote><p>구체적인 예시를 통해 알아봅시다. 아래는 값 3.141592가 타입 <em>number</em>에 속한다는 것을 표현한 것입니다.</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">3.141592 : number  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><em>number</em> 타입으로 엮인 메모리 공간에는 <code>&#39;foo&#39;</code>, <code>null</code> 같은 값은 올 수 없습니다.</li><li><em>number</em> 타입은 덧셈, 곱셈 등의 산술 연산을 할 수 있으며, <code>toString</code>, <code>toFixed</code> 등의 속성이 있습니다.</li></ul><p>타입과 타입 간에도 관계가 존재하는데요, 타입 A가 다음을 만족할 때 타입 B의 서브타입이라고 합니다.</p><blockquote><p>타입 B의 모든 속성이 A에도 있을 것</p></blockquote><p>속성이 무엇이냐, primitive 타입일 땐 어떻게 비교할 것이냐 하는 것은 뒤에서 살펴보고 지금은 거시적인 개념만 익혀두겠습니다. 아래는 타입 <code>{ x: number; y?: string }</code> 이 <code>{ x: number }</code>의 서브타입임을 표현한 것입니다.</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">{ x: number; y?: string } ≲ { x: number }</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="타입은-부분순서집합" tabindex="-1"><a class="header-anchor" href="#타입은-부분순서집합"><span>타입은 부분순서집합</span></a></h2><p>앞서 살펴보았듯, <strong>타입은 비교 가능합니다</strong>. 비교 가능한 집합 중 가장 익숙한 것으로 실수(real number)가 있는데요. 타입의 대소 관계와 실수의 대소 관계는 약간 다릅니다.</p><p>모든 임의의 두 실수는 다음의 둘 중 최소한 하나를 만족합니다.</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≥</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\ge{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\le{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span></li></ul>`,17)),s("p",null,[a[35]||(a[35]=n("특별히 a ≥ b이면서 a ≤ b인 관계를 a = b라고 합니다. 이런 집합을 ",-1)),s("a",L,[e(l,{icon:"fa-brands fa-wikipedia-w"}),a[34]||(a[34]=n("전순서집합(totally ordered set)",-1))]),a[36]||(a[36]=n("이라고 합니다. 엄밀하게는 몇 가지 조건이 붙지만, 지금은 중요하지 않으니 참고만 해주세요.",-1))]),a[47]||(a[47]=i('<p>타입은 조금 다릅니다. 다음 4가지 중 하나만 만족합니다.</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≳</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\gtrsim{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≲</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\lesssim{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≲</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≳</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\gtrsim{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span> 이면서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≲</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\lesssim{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≲</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≄</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a\\not\\simeq{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">b</span></span></span></span></span></li></ul>',2)),s("p",null,[a[38]||(a[38]=n("특별히 a ≳ b 이면서 a ≲ b 인 경우를 a ≃ b 라고 표현하겠습니다. 여기서 중요한 점은 a ≳ b가 아니라고 해서 a ≲ b라고 할 수 없다는 점입니다. 이런 집합을 ",-1)),s("a",X,[e(l,{icon:"fa-brands fa-wikipedia-w"}),a[37]||(a[37]=n("부분순서집합(partially ordered set)",-1))]),a[39]||(a[39]=n("이라고 합니다.",-1))]),a[48]||(a[48]=i(`<p>구체적인 예시를 보고 기호를 체화해 보세요.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">number ≳ 42</span>
<span class="line"></span>
<span class="line">symbol | string ≲ number | symbol | string</span>
<span class="line"></span>
<span class="line">{ x?: number } ≃ { x: number | undefined }</span>
<span class="line"></span>
<span class="line">number ≄ { x: number }  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="타입과-값의-대입" tabindex="-1"><a class="header-anchor" href="#타입과-값의-대입"><span>타입과 값의 대입</span></a></h2><p>뜬금없이 대소 비교를 왜 배웠느냐, 바로 값을 대입하는 조건을 정의하기 위해서입니다. TS는 안전한 대입과 참조를 실현하는 방법으로서 타입 이론을 사용합니다.</p>`,5)),a[49]||(a[49]=s("blockquote",null,[s("p",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"l"),s("mi",null,"v"),s("mi",null,"a"),s("mi",null,"l"),s("mtext",null,"의 타입"),s("mo",null,"≳"),s("mrow",null,[s("mi",null,"r"),s("mi",null,"v"),s("mi",null,"a"),s("mi",null,"l"),s("mtext",null,"의 타입")]),s("mo",null,"⇔"),s("mrow",null,[s("mi",null,"l"),s("mi",null,"v"),s("mi",null,"a"),s("mi",null,"l"),s("mo",null,[s("mi",{mathvariant:"normal"},"≔")]),s("mrow",null,[s("mi",null,"r"),s("mi",null,"v"),s("mi",null,"a"),s("mi",null,"l")])])]),s("annotation",{encoding:"application/x-tex"},"lval\\text{의 타입}\\gtrsim{rval\\text{의 타입}}\\Leftrightarrow{lval\\coloneqq{rval}}")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.9592em","vertical-align":"-0.2296em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord text"},[s("span",{class:"mord hangul_fallback"},"의"),s("span",{class:"mord"}," "),s("span",{class:"mord hangul_fallback"},"타입")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel amsrm"},"≳"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord text"},[s("span",{class:"mord hangul_fallback"},"의"),s("span",{class:"mord"}," "),s("span",{class:"mord hangul_fallback"},"타입")])]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"⇔"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},[s("span",{class:"mrel"},[s("span",{class:"mop",style:{position:"relative",top:"-0.0347em"}},":")]),s("span",{class:"mrel"},[s("span",{class:"mspace",style:{"margin-right":"-0.0667em"}})]),s("span",{class:"mrel"},"=")]),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"r"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"v"),s("span",{class:"mord mathnormal"},"a"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l")])])])])]),n("는 올바른 대입")])],-1)),a[50]||(a[50]=i(`<p>다음 코드를 하나씩 볼까요?</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">42</span>  </span>
<span class="line"><span class="token comment">// number ≳ number이므로, 대입 가능</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">42</span>  </span>
<span class="line"><span class="token comment">// string ≄ number이므로, 대입 불가능</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">42</span>  </span>
<span class="line"><span class="token comment">// string | number ≳ number이므로, 대입 가능</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>이렇게 동작하는 이유는, 서브타입은 반드시 슈퍼타입이 가지는 성질을 갖기 때문입니다. 즉, 속성에 대한 안전한 참조를 할 수 있습니다. <code>null</code>이나 <code>undefined</code>를 대상으로 <code>.toString()</code> 등의 참조를 하면 런타임 오류가 발생하죠? 타입 이론은 이를 <code>null</code> 타입이 <code>toString</code>이라는 속성을 가지지 않았기 때문으로 본 것입니다.</p><hr><h2 id="타입의-종류에-따른-대소-비교" tabindex="-1"><a class="header-anchor" href="#타입의-종류에-따른-대소-비교"><span>타입의 종류에 따른 대소 비교</span></a></h2><p>앞에서는 간단하게 소개했지만, 이제 정식으로 타입의 대소 비교를 어떻게 하는지 알아봅시다.</p><h3 id="원시-타입-primitive-type" tabindex="-1"><a class="header-anchor" href="#원시-타입-primitive-type"><span>원시 타입(primitive type)</span></a></h3><p>원시 타입이란 다음 6가지를 말합니다.</p><ul><li><code>boolean</code></li><li><code>number</code></li><li><code>string</code></li><li><code>symbol</code></li><li><code>null</code></li><li><code>undefined</code></li></ul><p>이들은 공리적으로 정의합니다. <code>null</code>을 제외하면, JS에 존재할 수 있는 값에 <code>typeof</code>를 수행했을 때 결과가 저 중 하나라면 그것이 곧 자신의 타입 이름입니다. 예를 들어 <code>typeof 3.141592 === &#39;number&#39;</code>이면 해당 리터럴은 <code>number</code> 타입입니다.</p><p>이들은 자기 자신과는 서브타입 관계이고, 다른 타입과는 무관계입니다.</p><p>참고로 TS에서는 <code>null</code>을 객체(<code>object</code>)의 서브타입으로 <strong>간주하지 않습니다</strong>. 왜냐하면 <code>null</code>은 참조할 수 있는 속성이 하나도 없기 때문입니다. JS에서 역사적인 이유로 인해 <code>typeof null === &#39;object&#39;</code>인 것과 대조적입니다.</p><h3 id="리터럴-타입-literal-type" tabindex="-1"><a class="header-anchor" href="#리터럴-타입-literal-type"><span>리터럴 타입(literal type)</span></a></h3><p>리터럴 타입이란 어떤 슈퍼타입에 속한 값 &#39;1개&#39;만으로 구성된 타입입니다. 예를 들어 <code>number ≳ 6</code>과 같은 경우가 있습니다.</p><p>참고로 대부분의 경우, 리터럴을 쓰면 해당 심벌은 원시 타입으로 간주됩니다. 강제로 리터럴 타입으로 변환할 필요가 있다면 <code>as const</code> 키워드를 붙이면 됩니다.</p><h3 id="객체-타입-object-type" tabindex="-1"><a class="header-anchor" href="#객체-타입-object-type"><span>객체 타입(object type)</span></a></h3><p>객체 타입은 개별 속성의 방향이 일치할 때, 전체의 대소 방향도 똑같이 따라갑니다.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>p</mi><mo>∈</mo><mtext>prop</mtext><mrow><mo fence="true">(</mo><mi>A</mi><mo fence="true">)</mo></mrow><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo><mo>≳</mo><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>p</mi><mo stretchy="false">]</mo></mrow><mo>⇒</mo><mrow><mi>A</mi><mo>≳</mo><mi>B</mi></mrow></mrow><annotation encoding="application/x-tex">\\forall{p}\\in\\text{prop}\\left(A\\right) : A[p]\\gtrsim{B[p]}\\Rightarrow{A\\gtrsim{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal">p</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">prop</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">A</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathnormal">p</span><span class="mclose">]</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span></span></p></blockquote><p>말이 어려우니 구체적인 예시를 보겠습니다. 여기 2가지 타입이 있습니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span></span>
<span class="line">  y<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span></span>
<span class="line">  z<span class="token operator">:</span> <span class="token builtin">boolean</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>  </span>
<span class="line">  x<span class="token operator">:</span> <span class="token builtin">number</span></span>
<span class="line">  z<span class="token operator">:</span> <span class="token boolean">false</span></span>
<span class="line">  a<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>tsc는 A ≳ B인지 궁금해 합니다. 이때 우리는 타입의 정의에서 잠시 보았던 &#39;슈퍼타입의 모든 속성&#39;을 따지기 시작합니다. A가 슈퍼타입인지 물어봤으니, A의 속성을 나열해야겠지요?</p><p>A는 <code>x</code>, <code>y</code>, <code>z</code>라는 속성을 가지고 있으며, 각각 <code>number</code>, <code>string | undefined</code>, <code>boolean</code>을 타입으로 갖습니다. 이제 각 속성 이름에 대해, B에서 해당 속성이 무슨 타입인지 확인합니다. 이를 간결하게 나타내면 다음과 같습니다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">A[&#39;x&#39;] = number             ≳ number    = B[&#39;x&#39;]  </span>
<span class="line">A[&#39;y&#39;] = string | undefined ≳ undefined = B[&#39;y&#39;]  </span>
<span class="line">A[&#39;z&#39;] = boolean            ≳ false     = B[&#39;z&#39;]  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>B[&#39;a&#39;]</code>는 왜 비교하지 않냐고요? 슈퍼타입인 <code>A</code>에는 <code>a</code>라는 속성이 없기 때문입니다. <code>B</code> 타입의 값은 <code>A</code> 타입에 대입할 수 있고, <code>A</code> 타입을 통해선 <code>a</code> 속성에 접근하지 못합니다. 따라서 <code>a</code>의 타입은 중요하지 않습니다.</p><p>이렇게 <strong>어떤 더 작은 관심사에서의 방향이 거시적인 대소 관계 방향과 일치할 때</strong> 그 성질을 <strong>공변성</strong>(covariance)이라고 합니다. 객체 타입의 대소 관계는 각 타입이 가진 성질에 대하여 공변적입니다. 만약 하나라도 방향이 일치하지 않을 경우, 두 타입은 무관계입니다.</p><h3 id="배열-튜플-타입" tabindex="-1"><a class="header-anchor" href="#배열-튜플-타입"><span>배열/튜플 타입</span></a></h3><p>배열도 객체입니다. 튜플은 배열의 일종이죠. 따라서 이들은 객체와 동일한 원리가 적용됩니다.</p><p>배열의 타입은 개별 원소 타입에 대하여 공변적입니다.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≳</mo><mi>B</mi><mo>⇒</mo><mrow><mi>A</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo><mo>≳</mo><mrow><mi>B</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">A\\gtrsim{B}\\Rightarrow{A[]\\gtrsim{B[]}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span></span></span></p></blockquote><p>객체와 배열의 차이가 있다면, <code>number</code>를 키 값으로 갖는다는 점입니다. 다만 <code>keyof string[]</code>이 <code>number</code>를 직접 반환하지는 않는데, 배열에는 <code>concat</code>과 같은 다른 속성도 많이 있기 때문입니다. 하지만 명백하게 <code>keyof string[] ≳ number</code>는 맞습니다.</p><p>튜플 타입은 <code>length</code>가 <code>number</code>의 리터럴 타입이라는 점이 배열과 다릅니다. 만약 <code>length</code> 범위 밖의 인덱스를 참조 시, 타입 오류를 발생시키며 해당 참조값은 <code>any</code>로 추론합니다.</p><h3 id="키-타입-keyof" tabindex="-1"><a class="header-anchor" href="#키-타입-keyof"><span>키 타입(keyof)</span></a></h3><p>키 타입이란 객체 타입의 속성 이름의 합집합(<code>|</code>)으로 이루어진 타입입니다.</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">keyof { x: number; y?: string; z: boolean }  </span>
<span class="line">≃ &#39;x&#39; | &#39;y&#39; | &#39;z&#39;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>모든 키 타입은 <code>number | string | symbol</code>의 서브타입입니다.</p><h3 id="함수-타입" tabindex="-1"><a class="header-anchor" href="#함수-타입"><span>함수 타입</span></a></h3><p>함수 타입은 반환형과 인자의 타입 두 가지 요소가 조합된 것이며, 호출 가능합니다. 함수 타입의 포함 관계는 다소 복잡한데, 반환형에는 공변적이고 인자형에는 반변적(contravariant)입니다.</p><h4 id="반환형에-공변적" tabindex="-1"><a class="header-anchor" href="#반환형에-공변적"><span>반환형에 공변적</span></a></h4><p>두 함수의 인자를 고려하지 않을 때, 반환형의 포함 관계의 방향이 곧 전체 함수 타입의 포함 관계를 결정합니다.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≳</mo><mi>B</mi><mo>⇒</mo><mi>X</mi><mo>→</mo><mrow><mi>A</mi><mo>≳</mo><mi>X</mi></mrow><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\\gtrsim{B}\\Rightarrow{X}\\rightarrow{A\\gtrsim{X}}\\rightarrow{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span></p></blockquote><p>왜 함수 타입은 반환형에 공변적일까요? 바로 반환값이 rvalue로 쓰이기 때문입니다. 앞에서 특정 타입의 lvalue에는 그 서브타입의 rvalue를 넣을 수 있다고 했습니다. 공변적이라면 더 작은 타입의 함수를 큰 타입에 대입하더라도 사용할 때 일관성을 유지할 수 있습니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">fa</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token operator">...</span>  </span>
<span class="line"><span class="token keyword">const</span> <span class="token function-variable function">fb</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token operator">...</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> a<span class="token operator">:</span> <span class="token constant">A</span>  </span>
<span class="line"><span class="token keyword">let</span> <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">A</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// () =&gt; A ≳ () =&gt; B라면, fb를 f에 대입할 수 있고</span></span>
<span class="line"><span class="token comment">// f의 반환값은 위에서 하던 대로 a에 대입할 수 있어야 한다.</span></span>
<span class="line">f <span class="token operator">=</span> fb  </span>
<span class="line">a <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="인자형에-반변적" tabindex="-1"><a class="header-anchor" href="#인자형에-반변적"><span>인자형에 반변적</span></a></h4><p>두 함수의 반환형을 고려하지 않을 때, 인자형의 포함 관계의 <strong>역전</strong>이 전체 함수 타입의 포함 관계를 결정합니다. 이 성질을 반변성(contravariance)이라고 합니다.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≳</mo><mi>B</mi><mo>⇒</mo><mi>A</mi><mo>→</mo><mrow><mi>X</mi><mo>≲</mo><mi>B</mi></mrow><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">A\\gtrsim{B}\\Rightarrow{A}\\rightarrow{X\\lesssim{B}}\\rightarrow{X}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≳</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">A</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≲</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span></span></p></blockquote><p>왜 함수 타입은 인자형에 반변적일까요? 바로 인자가 lvalue로 쓰이기 때문입니다. 어떤 함수가 더 작은 타입의 함수로 치환이 되더라도, 인자를 받는 데 문제가 없어야 하는데 반변성은 이를 보장해 줍니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> <span class="token function-variable function">fa</span><span class="token operator">:</span> <span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>  </span>
<span class="line"><span class="token keyword">const</span> <span class="token function-variable function">fb</span><span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> <span class="token function-variable function">f</span><span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token operator">:</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// b는 A의 서브타입인 B 타입이므로, A에 대입이 가능</span></span>
<span class="line">f <span class="token operator">=</span> fa  </span>
<span class="line"><span class="token function">f</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>한편 함수 인자의 길이도 고려를 해야 하는데요. 이것 역시 직관과 반대로 돌아갑니다.</p><blockquote><p><strong>인자가 적은 함수 타입 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≲</mo></mrow><annotation encoding="application/x-tex">\\lesssim</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mrel amsrm">≲</span></span></span></span> 인자가 많은 함수 타입</strong></p></blockquote><p>왜 그럴까요? 인자가 적은 함수는 더 많은 인자를 받더라도 문제가 안되는 반면, 인자를 많이 요구하는 함수가 더 적게 받으면 안 되기 때문입니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">function</span> <span class="token function">consume1Arg</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">X</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>  </span>
<span class="line"><span class="token keyword">function</span> <span class="token function">consume2Arg</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">X</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">Y</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> <span class="token function-variable function">wide</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">X</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">Y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span></span>
<span class="line"></span>
<span class="line">wide <span class="token operator">=</span> consume1Arg  </span>
<span class="line"><span class="token function">wide</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// consume1Arg는 y를 무시함</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">let</span> <span class="token function-variable function">narrow</span><span class="token operator">:</span> <span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">X</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span></span>
<span class="line"></span>
<span class="line">narrow <span class="token operator">=</span> consume2Arg  </span>
<span class="line"><span class="token comment">// Target signature provides too few arguments. Expected 2 or more, but got 1</span></span>
<span class="line"></span>
<span class="line"><span class="token function">narrow</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// consume2Arg의 y가 결정되지 못함  </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="특수-타입" tabindex="-1"><a class="header-anchor" href="#특수-타입"><span>특수 타입</span></a></h3><p>특수 타입이란 JS에서 값으로 존재하지 않고 TS에서만 존재하는 타입인 <code>never</code>, <code>unknown</code>, <code>any</code>, <code>void</code>를 이릅니다.</p><h4 id="never-unknown" tabindex="-1"><a class="header-anchor" href="#never-unknown"><span><code>never</code>, <code>unknown</code></span></a></h4><p>우리는 값의 안전한 대입을 타입의 대소 관계로서 다루기로 했습니다. 이 관점에서 <code>never</code>와 <code>unknown</code>은 아주 간단합니다.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>T</mi><mo>:</mo><mtext>never</mtext><mo>≲</mo><mi>T</mi><mo>≲</mo><mtext>unknown</mtext></mrow><annotation encoding="application/x-tex">\\forall{T} : \\text{never}\\lesssim{T}\\lesssim\\text{unknown}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord text"><span class="mord">never</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≲</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≲</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">unknown</span></span></span></span></span></p></blockquote><p>모든 타입 T에 대하여, <code>never</code>는 T의 서브타입이며, T는 <code>unknown</code>의 서브타입입니다.</p><p><code>never</code>는 존재할 수 있는 가장 좁은 타입으로, 그 어떤 값도 대입할 수 없습니다. 심지어 <code>undefined</code>도요. <code>never</code>는 일반적인 상황에선 거의 쓰이지 않지만, 복잡한 제네릭을 구성 시 잘못된 대입에 대한 징벌적 오류를 발생시킬 때 유용합니다.</p><p>한편 <code>unknown</code>은 존재할 수 있는 가장 넓은 타입으로, 그 어떤 값도 대입할 수 있습니다. 심지어 <code>never</code> 타입으로 강제로 형변환한 값도요.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">const</span> thisIsNever<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> <span class="token keyword">undefined</span>  </span>
<span class="line"><span class="token comment">// Type &#39;undefined&#39; is not assignable to type &#39;never&#39;.</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> thisIsUnknown<span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token number">0</span>  </span>
<span class="line"><span class="token comment">// OK</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> neverCantReceiveAnything<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token builtin">unknown</span>  </span>
<span class="line"><span class="token comment">// Type &#39;unknown&#39; is not assignable to type &#39;never&#39;.</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> unknownCanReceiveAnything<span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token builtin">never</span>  </span>
<span class="line"><span class="token comment">// OK</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> unknownCantBeAssigned<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">as</span> <span class="token builtin">unknown</span>  </span>
<span class="line"><span class="token comment">// Type &#39;unknown&#39; is not assignable to type &#39;number&#39;.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="any" tabindex="-1"><a class="header-anchor" href="#any"><span><code>any</code></span></a></h4><p>그렇다면 <code>any</code>는 무엇일까요?</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>T</mi><mo>≄</mo><mtext>never</mtext><mo>:</mo><mi>T</mi><mo>≃</mo><mtext>any</mtext></mrow><annotation encoding="application/x-tex">\\forall{T}\\not\\simeq\\text{never} : T\\simeq\\text{any}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="inner"><span class="mord"><span class="mrel"></span></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord text"><span class="mord">never</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">any</span></span></span></span></span></p></blockquote><p><code>never</code>를 제외한 모든 타입 T에 대하여, <code>any</code>는 T와 서로 서브타입 관계입니다.</p><p>서로 서브타입 관계이기 때문에 <code>any</code>를 <code>number</code>에 대입할 수도 있고, <code>number</code>를 <code>any</code>에 대입할 수도 있습니다. 단, <code>never</code>에 <code>any</code>를 대입할 수는 없습니다.</p><h4 id="void" tabindex="-1"><a class="header-anchor" href="#void"><span><code>void</code></span></a></h4><p><code>void</code>는 함수의 반환형을 서술할 때 유의미한 타입으로, <code>undefined</code>의 슈퍼타입입니다. <code>undefined</code>과 특수 타입을 제외한 모든 타입과는 무관계입니다.</p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>undefined</mtext><mo>≲</mo><mtext>void</mtext></mrow><annotation encoding="application/x-tex">\\text{undefined}\\lesssim{\\text{void}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9592em;vertical-align:-0.2296em;"></span><span class="mord text"><span class="mord">undefined</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">≲</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord text"><span class="mord">void</span></span></span></span></span></span></p></blockquote><p>즉, <code>undefined</code>를 <code>void</code>에는 대입할 수 있지만 그 역은 안 됩니다. 이는 함수를 정의할 때를 생각하면 합리적인데요, <code>void</code>형 함수에 <code>return</code> 문은 사실상 <code>return undefined</code>와 동일하기 때문입니다. 하지만 이 함수의 반환값이 사용되지 않아야 하므로, 다른 타입에 대입은 불가능합니다.</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code class="language-typescript"><span class="line"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">undefined</span> <span class="token comment">// OK</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> x<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  </span>
<span class="line"><span class="token comment">// Type &#39;void&#39; is not assignable to type &#39;number&#39;.</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> y<span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  </span>
<span class="line"><span class="token comment">// Type &#39;void&#39; is not assignable to type &#39;undefined&#39;.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="퀴즈" tabindex="-1"><a class="header-anchor" href="#퀴즈"><span>퀴즈</span></a></h2><p>다음 중 이론상 가장 넓은 함수의 타입은?</p><ol><li><code>(...args: unknown[]) =&gt; unknown</code></li><li><code>(...args: never[]) =&gt; unknown</code></li><li><code>(...args: any[]) =&gt; any</code></li><li><code>(...args: void[]) =&gt; never</code></li></ol><p>정답 및 풀이</p><p>정답은 2번입니다.</p><ul><li>함수의 타입 중 가장 넓은 타입을 찾아야 하므로, 우선 반환형이 좁은 <code>never</code>(4번)은 아웃입니다.</li><li>인자 개수는 모두 무한하게 같고, 인자형 중 가장 좁은 타입을 찾아야 합니다.</li><li>배열은 개별 원소 타입에 공변적이므로, 개별 요소 중 가장 좁은 타입을 찾아야 합니다.</li><li>따라서 가장 좁은 <code>never</code>를 가진 2번이 정답입니다.</li></ul><p>실제로 이 타입은 함수 타입의 예시로서 TS 공식 문서에 종종 등장하곤 합니다.</p><hr><h2 id="마치며" tabindex="-1"><a class="header-anchor" href="#마치며"><span>마치며</span></a></h2><p>TS의 궁극적인 목표는 안전한 대입과 참조를 실현하는 것입니다. 이를 위해서 타입과 그 대소 관계를 정의하고, 안전한 대입이 무엇인지 살펴보았습니다. 다음 글에서는 TS가 어떻게 안전하지 않은 대입이나 참조를 잡아내는지 알아보겠습니다.</p>`,81)),s("div",C,[a[40]||(a[40]=s("p",{class:"hint-container-title"},[s("strong",null,"infer, never만 보면 두려워지는 당신을 위한 타입 추론"),n(" 시리즈")],-1)),e(o,r(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론",link:"/d2.naver.com/9283310.md",logo:"/assets/image/d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16),e(o,r(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 고급 타입 추론 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 고급 타입 추론",link:"/d2.naver.com/3713986.md",logo:"/assets/image/d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16),e(o,r(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제 | NAVER D2",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 응용 문제",link:"/d2.naver.com/5088940.md",logo:"/assets/image/d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16)]),k(" TODO: add ARTICLE CARD "),e(o,r(c({title:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론",desc:"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론",link:"https://chanhi2000.github.io/bookshelf/d2.naver.com/9283310.html",logo:"https://d2.naver.com/favicon.ico",background:"rgba(103,262,163,0.2)"})),null,16)])}const N=g(f,[["render",V]]),D=JSON.parse('{"path":"/d2.naver.com/9283310.html","title":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론","description":"Article(s) > infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론","icon":"iconfont icon-typescript","category":["Node.js","TypeScript","Article(s)"],"tag":["blog","d2.naver.com","node","nodejs","node-js","ts","typescript"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론\\",\\"image\\":[\\"https://chanhi2000.github.io/bookshelf/assets/image/d2.naver.com/9283310/russell.png\\"],\\"datePublished\\":\\"2024-07-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/d2.naver.com/9283310.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론"}],["meta",{"property":"og:description","content":"Article(s) > infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://chanhi2000.github.io/bookshelf/assets/image/d2.naver.com/9283310/banner.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://chanhi2000.github.io/bookshelf/assets/image/d2.naver.com/9283310/banner.png"}],["meta",{"name":"twitter:image:alt","content":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론"}],["meta",{"property":"article:tag","content":"typescript"}],["meta",{"property":"article:tag","content":"ts"}],["meta",{"property":"article:tag","content":"node-js"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:tag","content":"d2.naver.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-07-04T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론"},{"property":"og:description","content":"infer, never만 보면 두려워지는 당신을 위한 타입 추론 - 기초 타입 이론"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/d2.naver.com/9283310.html"}]],"prev":"/programming/ts/articles/README.md","date":"2024-07-04T00:00:00.000Z","isOriginal":false,"cover":"/assets/image/d2.naver.com/9283310/banner.png"},"git":{},"readingTime":{"minutes":3.47,"words":1040},"filePathRelative":"d2.naver.com/9283310.md"}');export{N as comp,D as data};
