import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,d as n,f as a,b as t,t as u,n as d,g as k,r as o,o as m}from"./app-BItykJLQ.js";const v={},b={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},g={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"};function h(p,s){const l=o("VPCard"),c=o("SiteInfo"),e=o("KotlinPlayground");return m(),r("div",null,[n("h1",b,[n("a",g,[n("span",null,u(p.$frontmatter.title)+" ê´€ë ¨",1)])]),a(l,d(k({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s[0]||(s[0]=n("nav",{class:"table-of-contents"},[n("ul")],-1)),s[1]||(s[1]=n("hr",null,null,-1)),a(c,{name:"Mutable objects or properties?",desc:"Time to answer the question: var/readonly vs val/mutable. Which one should you use?",url:"https://kt.academy/article/var_readonly_vs_val_mutable",logo:"https://kt.academy/logo.png",preview:"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Fvar_vs_mutable_cover.png&w=576&q=75"}),s[2]||(s[2]=t(`<p>One of the oldest discussions in Kotlin is if we should prefer to represent a mutable state with read-only var or a mutable val property. There is no single answer! Each of them should be preferred in different cases!</p><p>The key difference between those two options is how we can modify them. Modifications to var with read-only collection require making a copy of the entire collection. For large collections, that is a heavy and memory-consuming operation.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">var</span> storedUsers<span class="token operator">:</span> Map<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> User<span class="token operator">?</span> <span class="token operator">=</span> storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token comment">// Cheap!</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">addUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        storedUsers <span class="token operator">=</span> storedUsers <span class="token operator">+</span> <span class="token punctuation">(</span>id <span class="token keyword">to</span> <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> </span>
<span class="line">        <span class="token comment">// This makes a copy of the whole collection!</span></span>
<span class="line">        <span class="token comment">// What is expensive for large collections!</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Mutable collections support a range of methods that allow their modification, that are as fast as possible. That is why many people prefer mutable collections by default, arguing it is for efficiency.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> storedUsers<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">mutableMapOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> User<span class="token operator">?</span> <span class="token operator">=</span> storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token comment">// Cheap!</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">addUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// Cheap!</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, var with read-only collections also have their advantages, and can sometimes be more efficient! First, their changes are observable, so we can use read-only collections with StateFlow, observable delegate, or observe them with setter.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> users <span class="token operator">=</span> <span class="token function">MutableStateFlow</span><span class="token punctuation">(</span>mapOf<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">var</span> users <span class="token keyword">by</span> <span class="token function">mutableStateOf</span><span class="token punctuation">(</span>mapOf<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">var</span> users <span class="token keyword">by</span> Delegates<span class="token punctuation">.</span><span class="token function">observable</span><span class="token punctuation">(</span>mapOf<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _ <span class="token operator">-&gt;</span> </span>
<span class="line">    <span class="token comment">// Do something when users change</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We cannot so easily observe changes in mutable collections. Another problem is that when we store state in a mutable collection, it is easy to expose access to this collection! Consider the below code. Even though <code>getAllUsers</code> returns a read-only type, it is still returning a reference to the mutable collection. That is why whenever this collection changes, the result of <code>getAllUsers</code> changes as well. That is why when we print <code>users</code> for the second time, it has changed, even though <code>users</code> is a val with <code>Map</code> type. That is a common source of bugs.</p>`,8)),a(e,{title:"1",key:"3ed4674c",settings:"%7B%7D",files:"eJx1kUFrAjEQhf/KsKcsLBWvS22xPfUghZaejIdpEyWQHZckKxTxvzsT3XVVDDll3vdm5mVZ/HmMEX6iDV+23UaXtuEf9pqATxvcDpOFHXqIXLBGdLGGRZfw19sFts8flKqMv8AMmuH9c61KTSebdUewsUlEypkaGCnrzLwyMzJeOrO6gebe55Ji4q7dCB1jaPJb36sCwsbW8J2Co03ZLyfnpjdbZlD0PL0oDpr4ahLfBh2pgZdQAkd2hi7pyeK9oBNrVojw6WqdIWFKnlTWlTCZwJ7bSSUT/SbTCnQxf3vXxWNuOmOBjAsyr8GEcPlbJcNcxaCpWB0Boqypow=="}),s[3]||(s[3]=n("p",null,'To prevent that, we must use a technique known as "defensive copy", so copy the collection before exposing it.',-1)),a(e,{title:"2",key:"3ed38d90",settings:"%7B%7D",files:"eJx9kU9rwzAMxb+KyMmB0LJr2B+6nXYog42d6h602S0GRwm2Uxhl372S26RNCzU+We/3JD2vil+PMcJ3tOHTdm10qQ1/sNcEfLrgdpgs7NBD5II1oos1LPuEP94usXt8p1Rl/BmeoBnfPzaq1HS02fQEW5tEpJypgZGyzswLMxfGK2fWV9DC+1xSTNy0u0BnqeXytCeaXBt6VkDY2Bq+UnC0LYcl5VzNwNYZFD07iuJfE19N4tugIzXyEk7g6E7QOUUZZhD0Ys0KEc4ma41JU/Kksq6E+Rz23E4qmRg2eahAF4vXN13c5fKkBhPC+XeVjDEJQFOxPgD8MqrP"}),s[4]||(s[4]=n("p",null,"Making such a copy is expensive. We do not need to make a copy for read-only collection, so if we expect exposing the whole collection is more frequent than its modification, var with read-only collection should be preferable. However, it is rather a rare situation.",-1)),a(e,{title:"3",key:"3ed2b3d4",settings:"%7B%7D",files:"eJx9kU9LAzEQxb/KY08JLhavi3+onjyIoHhqehhMWgLZ2SVJF6T43U3Srm48NOSU+b03byab5tNRCPgIxr+ZcQg2Dv4LR8VIZ/R2omgwkUdIBaMzFzq80Hj7zLEtunvcoafxdSek4pNwd2DsTcxVYXWHxMquwA8JXlhtrN7+E62dKyUha3SJkS5vs3cLpt50eI/e8l7O8fNZGNR2uEKSIw4llsgGUuIk/FacruLcqifLKcrZciIHn/aUvOqV5dln4HDulsHraqLftXJ0LAonsVrhmNrlSlHMw920UM368Uk1F3UlqaZI+PtKkWNUO1HcbH8AE8ejow=="}),s[5]||(s[5]=t(`<p>Now consider thread safety. Default mutable collections require synchronizing both their reads, copies, and modifications, because those are all non-atomic operations.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> storedUsers<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">mutableMapOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> lock <span class="token operator">=</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> User<span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span> </span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getAllUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">        storedUsers<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> </span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">addUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If we don&#39;t do that, with every modification, we can end up with a corrupted collection. It might mean losing some data, or even worse, getting a <code>ConcurrentModificationException</code>.</p>`,3)),a(e,{title:"4",key:"3ed1bc10",settings:"%7B%7D",files:"eJyVUrFuwjAQ/ZUjkyOhQNeotKKIoUOKlKoTYXBjAxbOObIPVFrx77VDgABd6snye/fu3TvPI1XVxhJsDGmFSWmw3ForkRJaW8lFgQWWmjsHH07aXNbGKTJ2Dz8Fgj+1VTtOEnZcg/OAFIHnUsi2xD+1zHj9+IrUb8qfYATV+X22ZPG9iDblxtPGuA/oEV9uEVaSggRTIgUvGKeN4rOnuj2Wa2tQfUvBQnl8MhdOx9RciQUckcON9FjrhsJiL/hncULGe/b4YACZcsQ3sgdvptOdkzLY6wpz0dSePPcBeSVTeCercBU6/c/6qBmZBZE2OD/GwdstMHSruELvrxUIWVq/rrbqsrlT6B6UnNjDcDi86nrce/elZZvkPI8fpYjGL5MiasVaM7canSjbPSNpZI3YVerxDdOHPM3zWZ7C5PwjMyPUUpVNzNOvUtbhctc+RBISEZw4XH4uC3lcxV9gtPgFerv1Yg=="}),s[6]||(s[6]=t(`<p>Of course, there are mutable collections like <code>ConcurrentHashMap</code> that are thread-safe, but they are not always the best choice. They are slower than regular mutable collections.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> storedUsers<span class="token operator">:</span> MutableMap<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">ConcurrentHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    </span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> User<span class="token operator">?</span> <span class="token operator">=</span> storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getAllUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> storedUsers<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">addUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Property read and write is atomic, so we do not need to synchronize many operations on var with read-only collections. We typically need to synchronize only updates.</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">class</span> UserRepository <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">var</span> storedUsers<span class="token operator">:</span> Map<span class="token operator">&lt;</span>Int<span class="token punctuation">,</span> User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">val</span> lock <span class="token operator">=</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">)</span><span class="token operator">:</span> User<span class="token operator">?</span> <span class="token operator">=</span> storedUsers<span class="token punctuation">[</span>id<span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">getAllUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> storedUsers</span>
<span class="line"></span>
<span class="line">    <span class="token keyword">fun</span> <span class="token function">addUser</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        storedUsers <span class="token operator">=</span> storedUsers <span class="token operator">+</span> <span class="token punctuation">(</span>id <span class="token keyword">to</span> <span class="token function">User</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// Copy!</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>To summarize, var with read-only allows observability, and it is easier to synchronize it. On the other hand, mutable collections offer us better update performance and offer thread-safe alternatives, but its exposure requires defensive copying.</p><table><thead><tr><th style="text-align:left;">Mutable collection</th><th style="text-align:left;">Read-only collection</th></tr></thead><tbody><tr><td style="text-align:left;">Reading is cheap</td><td style="text-align:left;">Reading is cheap</td></tr><tr><td style="text-align:left;">Modifications are cheap</td><td style="text-align:left;">Modifications require making a copy</td></tr><tr><td style="text-align:left;">Cannot be observed</td><td style="text-align:left;">Can be obserced</td></tr><tr><td style="text-align:left;">Modifications require synchroniztaion</td><td style="text-align:left;">Modifications require synchroniztaion</td></tr><tr><td style="text-align:left;">Exposing require making a defensive copy</td><td style="text-align:left;">Exposing is cheap</td></tr><tr><td style="text-align:left;">Exposing must be synchronized</td><td style="text-align:left;">Exposing require no synchronization</td></tr></tbody></table>`,6))])}const w=i(v,[["render",h]]),U=JSON.parse('{"path":"/kt.academy/var-readonly-vs-val-mutable.html","title":"Mutable objects or properties?","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Mutable objects or properties?","description":"Article(s) > Mutable objects or properties?","icon":"iconfont icon-kotlin","category":["Kotlin","Article(s)"],"tag":["blog","kt.academy","kotlin","kt"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Mutable objects or properties?\\",\\"image\\":[\\"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Fvar_vs_mutable_cover.png&w=576&q=75\\"],\\"datePublished\\":\\"2024-06-10T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/var-readonly-vs-val-mutable.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"Mutable objects or properties?"}],["meta",{"property":"og:description","content":"Article(s) > Mutable objects or properties?"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Fvar_vs_mutable_cover.png&w=576&q=75"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Fvar_vs_mutable_cover.png&w=576&q=75"}],["meta",{"name":"twitter:image:alt","content":"Mutable objects or properties?"}],["meta",{"property":"article:tag","content":"kt"}],["meta",{"property":"article:tag","content":"kotlin"}],["meta",{"property":"article:tag","content":"kt.academy"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2024-06-10T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Mutable objects or properties?"},{"property":"og:description","content":"Mutable objects or properties?"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kt.academy/var-readonly-vs-val-mutable.html"}]],"prev":"/programming/java/articles/README.md","date":"2024-06-10T00:00:00.000Z","isOriginal":false,"cover":"https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fimages%2Fvar_vs_mutable_cover.png&w=576&q=75"},"git":{},"readingTime":{"minutes":3.75,"words":1126},"filePathRelative":"kt.academy/var-readonly-vs-val-mutable.md"}');export{w as comp,U as data};
