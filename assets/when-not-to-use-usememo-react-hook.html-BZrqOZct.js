import{_ as h}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as v,d as s,f as a,b as c,a as g,t as b,n as u,g as r,w as t,e,r as i,o as f}from"./app-BVguHYKu.js";const y="/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/banner.png",w="/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/eslint-hook-warnings.png",x="/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/props-lint-warning-example.png",j={},M={id:"frontmatter-title-관련",tabindex:"-1"},I={class:"header-anchor",href:"#frontmatter-title-관련"},T={class:"table-of-contents"},R={class:"hint-container note"},z={href:"https://kentcdodds.com/blog/usememo-and-usecallback",target:"_blank",rel:"noopener noreferrer"},S={href:"https://github.com/facebook/create-react-app/issues/6880",target:"_blank",rel:"noopener noreferrer"},H={href:"https://npmjs.com/package/eslint-plugin-react-hooks",target:"_blank",rel:"noopener noreferrer"},C={href:"https://github.com/facebook/create-react-app/issues/6880#issuecomment-485912528",target:"_blank",rel:"noopener noreferrer"},E={href:"https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables",target:"_blank",rel:"noopener noreferrer"};function A(d,n){const l=i("VPCard"),o=i("router-link"),m=i("SiteInfo"),k=i("RouteLink"),p=i("VPIcon");return f(),v("div",null,[s("h1",M,[s("a",I,[s("span",null,b(d.$frontmatter.title)+" 관련",1)])]),a(l,u(r({title:"React.js > Article(s)",desc:"Article(s)",link:"/programming/js-react/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),s("nav",T,[s("ul",null,[s("li",null,[a(o,{to:"#what-is-the-usememo-hook"},{default:t(()=>n[0]||(n[0]=[e("What is the useMemo Hook?")])),_:1,__:[0]})]),s("li",null,[a(o,{to:"#when-not-to-use-usememo"},{default:t(()=>n[1]||(n[1]=[e("When not to use useMemo")])),_:1,__:[1]}),s("ul",null,[s("li",null,[a(o,{to:"#don-t-use-usememo-if-your-operation-is-inexpensive"},{default:t(()=>n[2]||(n[2]=[e("Don’t use useMemo if your operation is inexpensive")])),_:1,__:[2]})]),s("li",null,[a(o,{to:"#don-t-use-usememo-if-you-are-memoizing-a-defaultstate-object"},{default:t(()=>n[3]||(n[3]=[e("Don’t use useMemo if you are memoizing a defaultState object")])),_:1,__:[3]})])])]),s("li",null,[a(o,{to:"#using-usememo-as-an-escape-hatch-for-the-eslint-hook-warnings"},{default:t(()=>n[4]||(n[4]=[e("Using useMemo as an escape hatch for the ESLint Hook warnings")])),_:1,__:[4]})]),s("li",null,[a(o,{to:"#usememo-vs-useref"},{default:t(()=>n[5]||(n[5]=[e("useMemo vs. useRef")])),_:1,__:[5]})]),s("li",null,[a(o,{to:"#conclusion"},{default:t(()=>n[6]||(n[6]=[e("Conclusion")])),_:1,__:[6]})])])]),n[43]||(n[43]=s("hr",null,null,-1)),a(m,{name:"When not to use the useMemo React Hook",desc:"Learn when not to use the useMemo React Hook, such as when a memoized value is not used frequently or a computation is not expensive.",url:"https://blog.logrocket.com/when-not-to-use-usememo-react-hook",logo:"/assets/image/blog.logrocket.com/favicon.png",preview:"/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/banner.png"}),s("div",R,[n[10]||(n[10]=s("p",{class:"hint-container-title"},"Editor’s note",-1)),s("p",null,[n[8]||(n[8]=e("This article was last updated on 10 March 2023. To read more on React Hooks, check out this ")),a(k,{to:"/blog.logrocket.com/react-hooks-cheat-sheet-solutions-common-problems.html"},{default:t(()=>n[7]||(n[7]=[s("strong",null,"cheat sheet",-1)])),_:1,__:[7]}),n[9]||(n[9]=e("."))])]),n[44]||(n[44]=c('<figure><img src="'+y+`" alt="Understanding When Not To Use The UseMemo React Hook" tabindex="0" loading="lazy"><figcaption>Understanding When Not To Use The UseMemo React Hook</figcaption></figure><p>Despite its usefulness in optimizing React performance, I’ve observed that some developers have a tendency to employ the <code>useMemo</code> Hook excessively. To delve deeper into this issue, I decided do some code explorations to determine scenarios where the use of <code>useMemo</code> may not be beneficial.</p><p>In this article, we’ll explore scenarios in which you might be overusing <code>useMemo</code>.</p><hr><h2 id="what-is-the-usememo-hook" tabindex="-1"><a class="header-anchor" href="#what-is-the-usememo-hook"><span>What is the <code>useMemo</code> Hook?</span></a></h2><p>The <code>useMemo</code> Hook in React is a performance optimization tool that allows you to memoize expensive computations and avoid unnecessary re-renders. When you use <code>useMemo</code>, you can calculate the value of a variable or function once and reuse it across multiple renders, rather than recalculating it every time your component re-renders.</p><p>This can significantly improve the performance of your application, particularly if you have complex or time-consuming computations that need to be done in your components.</p><p>It’s important to note that you should only use <code>useMemo</code> when you have expensive computations that need to be memoized. Using it for every value in your component can actually hurt performance, as <code>useMemo</code> itself has a small overhead.</p><p>Let’s take at some examples and scenarios in which you should reconsider using the <code>useMemo</code> Hook in a React app.</p><hr><h2 id="when-not-to-use-usememo" tabindex="-1"><a class="header-anchor" href="#when-not-to-use-usememo"><span>When not to use <code>useMemo</code></span></a></h2><h3 id="don-t-use-usememo-if-your-operation-is-inexpensive" tabindex="-1"><a class="header-anchor" href="#don-t-use-usememo-if-your-operation-is-inexpensive"><span>Don’t use <code>useMemo</code> if your operation is inexpensive</span></a></h3><p>Consider the example component below:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token comment">/** </span>
<span class="line"> * @param {number} page </span>
<span class="line"> * @param {string} type </span>
<span class="line"> **/</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token function">myComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>page<span class="token punctuation">,</span> type<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">  <span class="token keyword">const</span> resolvedValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">     <span class="token keyword">return</span> <span class="token function">getResolvedValue</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> type<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>page<span class="token punctuation">,</span> type<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ExpensiveComponent</span></span> <span class="token attr-name">resolvedValue</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>resolvedValue<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this example, it’s easy to justify the author’s use of <code>useMemo</code>. What goes through their mind is they don’t want the <code>ExpensiveComponent</code> to be re-rendered when the reference to <code>resolvedValue</code> changes.</p><p>While that’s a valid concern, there are two questions to ask to justify the use of <code>useMemo</code> at any given time.</p><p>First, is the function passed into <code>useMemo</code> an expensive one? In this case, is the <code>getResolvedValue</code> computation an expensive one?</p>`,17)),s("p",null,[n[12]||(n[12]=e("Most methods on JavaScript data types are optimized, e.g. ")),n[13]||(n[13]=s("code",null,"Array.map",-1)),n[14]||(n[14]=e(", ")),n[15]||(n[15]=s("code",null,"Object.getOwnPropertyNames()",-1)),n[16]||(n[16]=e(", etc. If you’re performing an operation that’s not expensive (think Big O notation), then you don’t need to memoize the return value. The cost of using ")),n[17]||(n[17]=s("code",null,"useMemo",-1)),n[18]||(n[18]=e()),s("a",z,[a(p,{icon:"fas fa-globe"}),n[11]||(n[11]=e("may outweigh"))]),n[19]||(n[19]=e(" the cost of reevaluating the function."))]),n[45]||(n[45]=c(`<p>Second, given the same input values, does the reference to the memoized value change? For example, in the code block above, given the <code>page</code> as <code>2</code> and <code>type</code> as <code>&quot;GET&quot;</code>, does the reference to <code>resolvedValue</code> change?</p><p>The simple answer is to consider the data type of the <code>resolvedValue</code> variable. If <code>resolvedValue</code> is <code>primitive</code> (i.e., <code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, or <code>symbol</code>), then the reference never changes. By implication, the <code>ExpensiveComponent</code> won’t be re-rendered.</p><p>Consider the revised code below:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token comment">/** </span>
<span class="line"> * @param {number} page </span>
<span class="line"> * @param {string} type </span>
<span class="line"> **/</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>page<span class="token punctuation">,</span> type<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> resolvedValue <span class="token operator">=</span> <span class="token function">getResolvedValue</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> type<span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ExpensiveComponent</span></span> <span class="token attr-name">resolvedValue</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>resolvedValue<span class="token punctuation">}</span></span><span class="token punctuation">/&gt;</span></span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Following the explanation above, if <code>resolvedValue</code> returns a string or other primitive value, and <code>getResolvedValue</code> isn’t an expensive operation, then this is perfectly correct and performant code.</p><p>As long as <code>page</code> and <code>type</code> are the same — i.e., no prop changes — <code>resolvedValue</code> will hold the same reference except the returned value isn’t a primitive (e.g., an object or array).</p><p>Remember the two questions: Is the function being memoized an expensive one, and is the returned value a primitive? With these questions, you can always evaluate your use of <code>useMemo</code>.</p><h3 id="don-t-use-usememo-if-you-are-memoizing-a-defaultstate-object" tabindex="-1"><a class="header-anchor" href="#don-t-use-usememo-if-you-are-memoizing-a-defaultstate-object"><span>Don’t use <code>useMemo</code> if you are memoizing a <code>defaultState</code> object</span></a></h3><p>Consider the following code block:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token comment">/** </span>
<span class="line"> * @param {number} page </span>
<span class="line"> * @param {string} type </span>
<span class="line"> **/</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token function">myComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>page<span class="token punctuation">,</span> type<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> </span>
<span class="line">  <span class="token keyword">const</span> defaultState <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">fetched</span><span class="token operator">:</span> <span class="token function">someOperationValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">type</span><span class="token operator">:</span> type</span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>defaultState<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ExpensiveComponent</span></span> <span class="token punctuation">/&gt;</span></span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The code above seems harmless to some, but the <code>useMemo</code> call there is unnecessary.</p><p>First of all, the intent here is to have a new <code>defaultState</code> object when the <code>type</code> prop changes, and not have any reference to the <code>defaultState</code> object be invalidated on every re-render.</p><p>While these are decent concerns, the approach is wrong and violates a fundamental principle: <code>useState</code> will not be reinitialized on every re-render, only when the component is remounted.</p><p>The argument passed to <code>useState</code> is better called <code>INITIAL_STATE</code>. It’s only computed (or triggered) once when the component is initially mounted:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token function">useState</span><span class="token punctuation">(</span><span class="token constant">INITIAL_STATE</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Although in the code block above, we are interested in getting a new <code>defaultState</code> value when the <code>type</code> array dependency for <code>useMemo</code> changes, this is a wrong judgment as <code>useState</code> ignores the newly computed <code>defaultState</code> object.</p><p>This is the same for lazily initializing <code>useState</code> as shown below:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token comment">/**</span>
<span class="line"> * @param {number} page </span>
<span class="line"> * @param {string} type </span>
<span class="line"> **/</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token function">myComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>page<span class="token punctuation">,</span> type<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// default state initializer </span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token function-variable function">defaultState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;default state computed&quot;</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token punctuation">{</span></span>
<span class="line">       <span class="token literal-property property">fetched</span><span class="token operator">:</span> <span class="token function">someOperationValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">       <span class="token literal-property property">type</span><span class="token operator">:</span> type</span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>defaultState<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ExpensiveComponent</span></span> <span class="token punctuation">/&gt;</span></span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the example above, the <code>defaultState</code> init function will only be invoked once — on mount. The function isn’t invoked on every re-render. As a result, the log “default state computed” will only be seen once, except when the component is remounted.</p><p>Here’s the previous code rewritten:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token comment">/**</span>
<span class="line"> * @param {number} page </span>
<span class="line"> * @param {string} type </span>
<span class="line"> **/</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token function">myComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>page<span class="token punctuation">,</span> type<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token function-variable function">defaultState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">     <span class="token literal-property property">fetched</span><span class="token operator">:</span> <span class="token function">someOperationValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line">     type<span class="token punctuation">,</span></span>
<span class="line">   <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>defaultState<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// if you really need to update state based on prop change, </span></span>
<span class="line">  <span class="token comment">// do so here</span></span>
<span class="line">  <span class="token comment">// pseudo code - if(previousProp !== prop){setState(newStateValue)}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ExpensiveComponent</span></span> <span class="token punctuation">/&gt;</span></span> </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We will now consider more subtle scenarios where you should avoid <code>useMemo</code>.</p><hr><h2 id="using-usememo-as-an-escape-hatch-for-the-eslint-hook-warnings" tabindex="-1"><a class="header-anchor" href="#using-usememo-as-an-escape-hatch-for-the-eslint-hook-warnings"><span>Using <code>useMemo</code> as an escape hatch for the ESLint Hook warnings</span></a></h2><figure><img src="`+w+'" alt="ESLint Hook Warnings" tabindex="0" loading="lazy"><figcaption>ESLint Hook Warnings</figcaption></figure>',25)),s("p",null,[n[26]||(n[26]=e("While I couldn’t bring myself to read ")),s("a",S,[n[20]||(n[20]=e("all the comments (")),a(p,{icon:"iconfont icon-github"}),n[21]||(n[21]=s("code",null,"cebook/create-react-app",-1)),n[22]||(n[22]=e(")"))]),n[27]||(n[27]=e(" from people who seek ways to suppress the lint warnings from the official ")),s("a",H,[n[23]||(n[23]=e("ESLint plugin for Hooks (")),a(p,{icon:"fa-brands fa-npm"}),n[24]||(n[24]=s("code",null,"eslint-plugin-react-hooks",-1)),n[25]||(n[25]=e(")"))]),n[28]||(n[28]=e(", I do understand their plight."))]),s("p",null,[n[32]||(n[32]=e("I agree with Dan Abramov ")),s("a",C,[n[29]||(n[29]=e("on this one (")),a(p,{icon:"iconfont icon-github "}),n[30]||(n[30]=s("code",null,"facebook/create-react-app",-1)),n[31]||(n[31]=e(")"))]),n[33]||(n[33]=e(". Suppressing the ")),n[34]||(n[34]=s("code",null,"eslint-warnings",-1)),n[35]||(n[35]=e(" from the plugin will likely come back to bite you someday in the future."))]),n[46]||(n[46]=c(`<p>Generally, I consider it a bad idea to suppress these warnings in production apps because you increase the likelihood of introducing subtle bugs in the near future.</p><p>With that being said, there are still some valid cases for wanting to suppress these lint warnings. Below is an example I’ve run into myself. The code’s been simplified for easier comprehension:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">function</span> <span class="token function">Example</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> impressionTracker<span class="token punctuation">,</span> propA<span class="token punctuation">,</span> propB<span class="token punctuation">,</span> propC <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 👇Track initial impression</span></span>
<span class="line">    <span class="token function">impressionTracker</span><span class="token punctuation">(</span>propA<span class="token punctuation">,</span> propB<span class="token punctuation">,</span> propC<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BeautifulComponent</span></span> <span class="token attr-name">propA</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propA<span class="token punctuation">}</span></span> <span class="token attr-name">propB</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propB<span class="token punctuation">}</span></span> <span class="token attr-name">propC</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propC<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>                 </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is a rather tricky problem.</p><p>In this specific use case, you don’t care whether the props change or not. You’re only interested in invoking the <code>track</code> function with whatever the initial props are. That’s how impression tracking works. You only call the impression track function when the component mounts. The difference here is you need to call the function with some initial props.</p><p>While you may think simply renaming the <code>props</code> to something like <code>initialProps</code> solves the problem, that won’t work. This is because <code>BeautifulComponent</code> relies on receiving updated prop values, too:</p><figure><img src="`+x+`" alt="Initial Props And Updated Props Example" tabindex="0" loading="lazy"><figcaption>Initial Props And Updated Props Example</figcaption></figure><p>In this example, you will get the lint warning message:</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">React Hook useEffect has missing dependencies: &#39;impressionTracker&#39;, &#39;propA&#39;, &#39;propB&#39;, and &#39;propC&#39;. Either include them or remove the dependency array.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>That’s a rather brash message, but the linter is simply doing its job. The easy solution is to use a <code>eslint-disable</code> comment, but this isn’t always the best solution because you could introduce bugs within the same <code>useEffect</code> call in the future:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">impressionTracker</span><span class="token punctuation">(</span>propA<span class="token punctuation">,</span> propB<span class="token punctuation">,</span> propC<span class="token punctuation">)</span></span>
<span class="line">  <span class="token comment">// eslint-disable-next-line react-hooks/exhaustive-deps</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>My suggestion solution is to use the <code>useRef</code> Hook to keep a reference to the initial prop values you don’t need updated:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>impressionTracker<span class="token punctuation">,</span> propA<span class="token punctuation">,</span> propB<span class="token punctuation">,</span> propC<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// keep reference to the initial values         </span></span>
<span class="line">  <span class="token keyword">const</span> initialTrackingValues <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">      <span class="token literal-property property">tracker</span><span class="token operator">:</span> impressionTracker<span class="token punctuation">,</span> </span>
<span class="line">      <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">        propA<span class="token punctuation">,</span> </span>
<span class="line">        propB<span class="token punctuation">,</span> </span>
<span class="line">        propC<span class="token punctuation">,</span> </span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// track impression </span></span>
<span class="line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token punctuation">{</span> tracker<span class="token punctuation">,</span> params <span class="token punctuation">}</span> <span class="token operator">=</span> initialTrackingValues<span class="token punctuation">.</span>current<span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">tracker</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// you get NO eslint warnings for tracker or params</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BeautifulComponent</span></span> <span class="token attr-name">propA</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propA<span class="token punctuation">}</span></span> <span class="token attr-name">propB</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propB<span class="token punctuation">}</span></span> <span class="token attr-name">propC</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propC<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>   </span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In all my tests, the linter only respects <code>useRef</code> for such cases. With <code>useRef</code>, the linter understands that the referenced values won’t change and so you don’t get any warnings! Not even <code>useMemo</code> prevents these warnings.</p><p>For example:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">function</span> <span class="token function">Example</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>impressionTracker<span class="token punctuation">,</span> propA<span class="token punctuation">,</span> propB<span class="token punctuation">,</span> propC<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// useMemo to memoize the value i.e so it doesn&#39;t change</span></span>
<span class="line">  <span class="token keyword">const</span> initialTrackingValues <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">tracker</span><span class="token operator">:</span> impressionTracker<span class="token punctuation">,</span> </span>
<span class="line">    <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span></span>
<span class="line">       propA<span class="token punctuation">,</span> </span>
<span class="line">       propB<span class="token punctuation">,</span> </span>
<span class="line">       propC<span class="token punctuation">,</span> </span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 👈 you get a lint warning here</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// track impression </span></span>
<span class="line">  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token punctuation">{</span> tracker<span class="token punctuation">,</span> params<span class="token punctuation">}</span> <span class="token operator">=</span> initialTrackingValues</span>
<span class="line">    <span class="token function">tracker</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>tracker<span class="token punctuation">,</span> params<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 👈 you must put these dependencies here</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">BeautifulComponent</span></span> <span class="token attr-name">propA</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propA<span class="token punctuation">}</span></span> <span class="token attr-name">propB</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propB<span class="token punctuation">}</span></span> <span class="token attr-name">propC</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>propC<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the faulty solution above, even though I keep track of the initial values by memoizing the initial prop values with <code>useMemo</code>, the linter still yells at me. Within the <code>useEffect</code> call, the memoized values <code>tracker</code> and <code>params</code> still have to be entered as array dependencies, too.</p><p>I’ve seen people <code>useMemo</code> in this way. It’s poor code and should be avoided. Use the <code>useRef</code> Hook, as shown in the initial solution.</p><p>In conclusion, in most legitimate cases where I really want to silent the lint warnings, I’ve found <code>useRef</code> to be a perfect ally. Embrace it.</p><hr><h2 id="usememo-vs-useref" tabindex="-1"><a class="header-anchor" href="#usememo-vs-useref"><span><code>useMemo</code> vs. <code>useRef</code></span></a></h2><p>Most people say to use <code>useMemo</code> for expensive calculations and for keeping referential equalities. I agree with the first but disagree with the second. Don’t use the <code>useMemo</code> Hook just for referential equalities. There’s only one reason to do this — which I discuss later.</p><p>Why is using <code>useMemo</code> solely for referential equalities a bad thing? Isn’t this what everyone else preaches?</p><p>Consider the following contrived example:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">function</span> <span class="token function">Bla</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span></span> <span class="token attr-name">baz</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>baz<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the component <code>Bla</code>, the value <code>baz</code> is memoized NOT because the evaluation of the array <code>[1,2,3]</code> is expensive, but because the reference to the <code>baz</code> variable changes on every re-render.</p><p>While this doesn’t seem to be a problem, I don’t believe <code>useMemo</code> is the right Hook to use here.</p><p>One, look at the array dependency:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Here, an empty array is passed to the <code>useMemo</code> Hook. By implication, the value <code>[1,2,3]</code> is only computed once — when the component mounts.</p><p>So, we know two things: the value being memoized is not an expensive calculation, and it is not recomputed after mount.</p><p>If you find yourself in such a situation, I ask that you rethink the use of the <code>useMemo</code> Hook. You’re memoizing a value that is not an expensive calculation and isn’t recomputed at any point in time. There’s no way this fits the definition of the term “memoization.”</p><p>This is a terrible use of the <code>useMemo</code> Hook. It is semantically wrong and arguably costs you more in terms of memory allocation and performance.</p><p>So, what should you do?</p><p>First, what exactly is the author of the code trying to accomplish here? They aren’t trying to memoize a value; rather, they want to keep the reference to a value the same across re-renders.</p><p>In these cases, use the <code>useRef</code> Hook.</p><p>For example, if you don’t like the usage of the current property, then simply deconstruct and rename as shown below:</p><div class="language-jsx line-numbers-mode" data-highlighter="prismjs" data-ext="jsx"><pre><code class="language-jsx"><span class="line"><span class="token keyword">function</span> <span class="token function">Bla</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token literal-property property">current</span><span class="token operator">:</span> baz <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span></span> <span class="token attr-name">baz</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>baz<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Problem solved.</p><p>In fact, you can use the <code>useRef</code> to keep reference to an expensive function evaluation — so long as the function doesn’t need to be recomputed on props change.</p><p><code>useRef</code> is the right Hook for such scenarios, NOT the <code>useMemo</code> Hook.</p>`,41)),s("p",null,[n[37]||(n[37]=e("Being able to use the ")),n[38]||(n[38]=s("code",null,"useRef",-1)),n[39]||(n[39]=e(" Hook to mimic ")),s("a",E,[a(p,{icon:"fa-brands fa-react"}),n[36]||(n[36]=e("instance variables"))]),n[40]||(n[40]=e(" is one of the least used super powers Hooks avail us. The ")),n[41]||(n[41]=s("code",null,"useRef",-1)),n[42]||(n[42]=e(" Hook can do more than just keeping references to DOM nodes. Embrace it."))]),n[47]||(n[47]=c('<p>Please remember, the condition here is if you’re memoizing a value just because you need to keep a consistent reference to it. If you need the value to be recomputed based off of a changing prop or value, then please feel free to use the <code>useMemo</code> Hook. In some cases, you can still use <code>useRef</code> — but <code>useMemo</code> is mostly convenient given the array dependency list.</p><hr><h2 id="conclusion" tabindex="-1"><a class="header-anchor" href="#conclusion"><span>Conclusion</span></a></h2><p>In this article, we see that while the <code>useMemo</code> Hook is useful for performance optimizations in React apps, there are indeed scenarios in which the hook is not needed. Some of these scenarios are:</p><ol><li><strong>When the computation is not expensive</strong>: If a computation is relatively cheap to perform, it may not be worth using <code>useMemo</code> to memoize it. As a general rule, if a computation takes less than a few milliseconds to complete, it’s probably not worth memoizing</li><li><strong>When the computation depends on props that change frequently</strong>. If a computation depends on props that change frequently, it may not be worth memoizing</li><li><strong>When the memoized value is not used frequently</strong>. If a memoized value is only used in one or two places in your component, it may not be worth the overhead of using <code>useMemo</code> to memoize it. In this scenario, it may be more efficient to simply recalculate the value when it’s needed, rather than maintaining a memoized version of it</li></ol><p>In general, it’s important to use <code>useMemo</code> judiciously and only when it’s likely to provide a measurable performance benefit. If you’re not sure whether to use useMemo, it’s a good idea to profile your application and measure the performance impact of different optimizations before making a decision.</p>',6)),g(" TODO: add ARTICLE CARD "),a(l,u(r({title:"When not to use the useMemo React Hook",desc:"Learn when not to use the useMemo React Hook, such as when a memoized value is not used frequently or a computation is not expensive.",link:"https://chanhi2000.github.io/bookshelf/blog.logrocket.com/when-not-to-use-usememo-react-hook.html",logo:"/assets/image/blog.logrocket.com/favicon.png",background:"rgba(112,76,182,0.2)"})),null,16)])}const B=h(j,[["render",A]]),O=JSON.parse('{"path":"/blog.logrocket.com/when-not-to-use-usememo-react-hook.html","title":"When not to use the useMemo React Hook","lang":"en-US","frontmatter":{"lang":"en-US","title":"When not to use the useMemo React Hook","description":"Article(s) > When not to use the useMemo React Hook","icon":"fa-brands fa-react","category":["Node.js","React.js","Article(s)"],"tag":["blog","blog.logrocket.com","node","nodejs","node-js","react","reactjs","react-js"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"When not to use the useMemo React Hook\\",\\"image\\":[\\"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/banner.png\\",\\"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/eslint-hook-warnings.png\\",\\"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/props-lint-warning-example.png\\"],\\"datePublished\\":\\"2023-03-10T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ohans Emmanuel\\",\\"url\\":\\"https://blog.logrocket.com/author/ohansemmanuel/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/blog.logrocket.com/when-not-to-use-usememo-react-hook.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"When not to use the useMemo React Hook"}],["meta",{"property":"og:description","content":"Article(s) > When not to use the useMemo React Hook"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/banner.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://chanhi2000.github.io/bookshelf/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/banner.png"}],["meta",{"name":"twitter:image:alt","content":"When not to use the useMemo React Hook"}],["meta",{"property":"article:author","content":"Ohans Emmanuel"}],["meta",{"property":"article:tag","content":"react-js"}],["meta",{"property":"article:tag","content":"reactjs"}],["meta",{"property":"article:tag","content":"react"}],["meta",{"property":"article:tag","content":"node-js"}],["meta",{"property":"article:tag","content":"nodejs"}],["meta",{"property":"article:tag","content":"node"}],["meta",{"property":"article:tag","content":"blog.logrocket.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2023-03-10T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > When not to use the useMemo React Hook"},{"property":"og:description","content":"When not to use the useMemo React Hook"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/blog.logrocket.com/when-not-to-use-usememo-react-hook.html"}]],"prev":"/programming/js-react/articles/README.md","date":"2023-03-10T00:00:00.000Z","isOriginal":false,"author":[{"name":"Ohans Emmanuel","url":"https://blog.logrocket.com/author/ohansemmanuel/"}],"cover":"/assets/image/blog.logrocket.com/when-not-to-use-usememo-react-hook/banner.png"},"git":{},"readingTime":{"minutes":8.85,"words":2654},"filePathRelative":"blog.logrocket.com/when-not-to-use-usememo-react-hook.md","copyright":{"author":"Ohans Emmanuel"}}');export{B as comp,O as data};
