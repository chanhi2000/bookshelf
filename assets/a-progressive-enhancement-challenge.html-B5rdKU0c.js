import{_ as m}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as g,d as n,f as t,b as c,a as v,t as b,n as r,g as p,w as o,e as a,r as i,o as f}from"./app-BItykJLQ.js";const y={},k={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},w={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},S={class:"table-of-contents"},j={href:"https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display#block",target:"_blank",rel:"noopener noreferrer"};function A(d,e){const l=i("VPCard"),s=i("router-link"),u=i("SiteInfo"),h=i("VPIcon");return f(),g("div",null,[n("h1",k,[n("a",w,[n("span",null,b(d.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),t(l,r(p({title:"CSS > Article(s)",desc:"Article(s)",link:"/programming/css/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t(l,r(p({title:"JavaScript > Article(s)",desc:"Article(s)",link:"/programming/js/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",S,[n("ul",null,[n("li",null,[t(s,{to:"#a-js-class"},{default:o(()=>[...e[0]||(e[0]=[a("A ‚Äújs‚Äù Class",-1)])]),_:1}),n("ul",null,[n("li",null,[t(s,{to:"#downsides"},{default:o(()=>[...e[1]||(e[1]=[a("Downsides",-1)])]),_:1})])])]),n("li",null,[t(s,{to:"#on-states"},{default:o(()=>[...e[2]||(e[2]=[a("On States",-1)])]),_:1}),n("ul",null,[n("li",null,[t(s,{to:"#no-js"},{default:o(()=>[...e[3]||(e[3]=[a("No JS",-1)])]),_:1})]),n("li",null,[t(s,{to:"#before-js-loaded"},{default:o(()=>[...e[4]||(e[4]=[a("Before JS Loaded",-1)])]),_:1})]),n("li",null,[t(s,{to:"#js-ready"},{default:o(()=>[...e[5]||(e[5]=[a("JS Ready",-1)])]),_:1})])])]),n("li",null,[t(s,{to:"#is-there-a-better-way"},{default:o(()=>[...e[6]||(e[6]=[a("Is there a better way?",-1)])]),_:1})])])]),e[16]||(e[16]=n("hr",null,null,-1)),t(u,{name:"A Progressive Enhancement Challenge",desc:"You want to hide an interactive element that you don't need anymore after JavaScript loads/runs. Can you do it without a ",url:"https://frontendmasters.com/blog/a-progressive-enhancement-challenge/",logo:"https://frontendmasters.com/favicon.ico",preview:"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/7324"}),e[17]||(e[17]=c(`<p>Let‚Äôs say you‚Äôve got some interactive element.</p><p>This element works perfectly fine in just HTML, which is the foundation of progressive enhancement.</p><p>And now, in your JavaScript, the functionality this button provides isn‚Äôt really necessary anymore, and your plan is to <strong>hide</strong> this element.</p><p>What is the best way to accomplish this?</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>I think it‚Äôs good to think of this abstractly, but if what I‚Äôve presented above is so abstract that it makes it hard to think about, here are some examples:</p><ol><li>A ‚ÄúLoad More‚Äù anchor link that loads the next set of items (i.e. <code>&lt;a href=&quot;?page=3&quot;&gt;Load More&lt;/a&gt;</code>) which you don‚Äôt need after JavaScript loads because you‚Äôve implemented an infinite scroll UX.</li><li>A ‚ÄúSave‚Äù button that saves user-entered information on the page to the database (i.e. <code>&lt;button onclick=&quot;save()&quot;&gt;Save&lt;/button&gt;</code>) which you don‚Äôt need after JavaScript loads because you‚Äôve implemented auto-saving functionality.</li></ol></div><hr><h2 id="a-js-class" tabindex="-1"><a class="header-anchor" href="#a-js-class"><span>A ‚Äújs‚Äù Class</span></a></h2><p>A classic approach to this is hiding the button when you know JavaScript is available. You put something like this pretty early in your HTML:</p><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html"><pre><code class="language-html"><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;js&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>If this executes, you‚Äôve proven that JavaScript is available, so you hide the button:</p><div class="language-css line-numbers-mode" data-highlighter="prismjs" data-ext="css"><pre><code class="language-css"><span class="line"><span class="token selector">html.js</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token selector">.save-button</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As appealing as this looks, it may not be the catch-all perfect solution.</p><h3 id="downsides" tabindex="-1"><a class="header-anchor" href="#downsides"><span>Downsides</span></a></h3><ul><li>You‚Äôve proven here that JavaScript is available, but you aren‚Äôt checking if the <em>particular</em> JavaScript that does the auto-saving is loaded and has run successfully. You can probably account for that by applying a more specific class just for this situation and applying it after the code that implements auto-saving.</li><li>The longer you (necessarily) have to wait for the JavaScript to be done, the longer the button is visible on the screen. This is likely to cause a ‚Äúflash‚Äù of the button being there where is doesn‚Äôt need really need to be.</li></ul><hr><h2 id="on-states" tabindex="-1"><a class="header-anchor" href="#on-states"><span>On States</span></a></h2><p>This question came up for me from a ShopTalk Show listener Tibor Leupold writing in asking about it. He was concerned about <strong>layout shift</strong> as a result of hiding the element(s) as well as the awkward UX.</p><div class="hint-container note"><p class="hint-container-title">Note</p><p>Let‚Äôs get this one out of the way: <strong>couldn‚Äôt you just‚Ä¶ leave the interactive elements there but change their functionality when the JavaScript loads?</strong> Maybe? Probably? That‚Äôs skirting the question though. Let‚Äôs assume the web is a big place with an unknowable amount of situations and that this particular situation of needing/wanting to hide an element with minimal impact is a reasonable one.</p></div><p>A way to think about our needs here is that there are three states to concern ourselves with:</p><ol><li>JavaScript is unavailable entirely</li><li>Before the relevant JavaScript has loaded and executed</li><li>The relevant JavaScript is loaded and executed successfully</li></ol><h3 id="no-js" tabindex="-1"><a class="header-anchor" href="#no-js"><span>No JS</span></a></h3><p>We‚Äôre probably not going to hide the button by default, as we don‚Äôt have a mechanism for un-hiding it in a no-JS situation. So we basically don‚Äôt need to do anything to accomplish this state, just have the interactive element on the page and functional in HTML.</p><p>In the <strong>reverse situation</strong>, where you have an element on the page that <em>only</em> works with JavaScript, you can hide it in a no-JS situation like:</p><div class="language-css line-numbers-mode" data-highlighter="prismjs" data-ext="css"><pre><code class="language-css"><span class="line"><span class="token selector">&lt;noscript&gt;</span>
<span class="line">  &lt;style&gt; .js-only-interactive-element</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> &lt;/style&gt;</span>
<span class="line">&lt;/noscript&gt;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="before-js-loaded" tabindex="-1"><a class="header-anchor" href="#before-js-loaded"><span>Before JS Loaded</span></a></h3><p>This is the hardest state. In this state, perhaps we know that JavaScript is available, but we don‚Äôt know <em>how long</em> it‚Äôs going to take or even <em>if</em> the JavaScript we care about is going to execute successfully.</p><p>It seems like the ideal behavior would be ‚Äúhide the interactive element for a brief period, then if the relevant JavaScript isn‚Äôt ready, show the element.‚Äù But how?! We can‚Äôt count on JavaScript for this behavior, which is the only technology I‚Äôm aware of that could do it. Rock and a hard place!</p><p>Maybe there is some extremely exotic technique involving HTML streaming that could delay the ‚Äúsend‚Äù of the interactive element down from the network for that brief blocking period? That‚Äôd be wild.</p>`,28)),n("p",null,[e[8]||(e[8]=a("Another thing I think of is the behavior of ",-1)),n("a",j,[t(h,{icon:"fa-brands fa-firefox"}),e[7]||(e[7]=n("code",null,"font-display: block;",-1))]),e[9]||(e[9]=a(". This is about the behavior of loading custom fonts via CSS ",-1)),e[10]||(e[10]=n("code",null,"@font-face",-1)),e[11]||(e[11]=a(". It can tell the browser how to behave while the custom font it loading. Do you want the browser to ",-1)),e[12]||(e[12]=n("em",null,"wait",-1)),e[13]||(e[13]=a(" to see if the custom font loads and then ‚Äúswap‚Äù to it? You‚Äôve got options. The ",-1)),e[14]||(e[14]=n("code",null,"block",-1)),e[15]||(e[15]=a(" value says:",-1))]),e[18]||(e[18]=c(`<blockquote><p>Gives the font face a short block period and an infinite swap period.</p></blockquote><p>Seems related! Maybe there is a way to bring this kind of behavior to progressive enhancement elements to mimic the behavior we want: ‚Äúhide the interactive element for a brief period, then if the relevant JavaScript isn‚Äôt ready, show the element.‚Äù Help us, web platform.</p><h3 id="js-ready" tabindex="-1"><a class="header-anchor" href="#js-ready"><span>JS Ready</span></a></h3><p>This is a fairly straightforward state, but it‚Äôs the cause of the ‚Äúflash‚Äù and potential layout shift.</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code class="language-javascript"><span class="line"><span class="token keyword">function</span> <span class="token function">setUpInfiniteScroll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// do all the work</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// at the end, say it&#39;s ready</span></span>
<span class="line">  document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;infinite-scroll-ready&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-highlighter="prismjs" data-ext="css"><pre><code class="language-css"><span class="line"><span class="token selector">.infinite-scroll-ready</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token selector">.load-more-link</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The problem here is: how long is that ‚ÄúLoad More‚Äù link going to be on the page before it disappears? Is it fairly instant? A few hundred milliseconds? Eight seconds? Never? (You really can‚Äôt know.)</p><p>Also: will the layout shift it triggers cause the user to potentially click on something they didn‚Äôt mean to? Maybe hiding can be done without the layout shift?</p><div class="language-scss line-numbers-mode" data-highlighter="prismjs" data-ext="scss"><pre><code class="language-scss"><span class="line"><span class="token selector">.infinite-scroll-ready </span><span class="token punctuation">{</span></span>
<span class="line">  <span class="token selector">.load-more-link </span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token property">visibility</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="is-there-a-better-way" tabindex="-1"><a class="header-anchor" href="#is-there-a-better-way"><span>Is there a better way?</span></a></h2><p>I feel like people have been thinking about progressive enhancement for a couple decades now. Is there an extremely clean/simple way to do this that I‚Äôm just not seeing?</p>`,12)),v(" TODO: add ARTICLE CARD "),t(l,r(p({title:"A Progressive Enhancement Challenge",desc:"You want to hide an interactive element that you don't need anymore after JavaScript loads/runs. Can you do it without a ",link:"https://chanhi2000.github.io/bookshelf/frontendmasters.com/a-progressive-enhancement-challenge.html",logo:"https://frontendmasters.com/favicon.ico",background:"rgba(188,75,52,0.2)"})),null,16)])}const x=m(y,[["render",A]]),T=JSON.parse('{"path":"/frontendmasters.com/a-progressive-enhancement-challenge.html","title":"A Progressive Enhancement Challenge","lang":"en-US","frontmatter":{"lang":"en-US","title":"A Progressive Enhancement Challenge","description":"Article(s) > A Progressive Enhancement Challenge","icon":"fa-brands fa-css3-alt","category":["CSS","JavaScript","Article(s)"],"tag":["blog","frontendmasters.com","css","js","javascript"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"A Progressive Enhancement Challenge\\",\\"image\\":[\\"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/7324\\"],\\"datePublished\\":\\"2025-10-03T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Chris Coyier\\",\\"url\\":\\"https://frontendmasters.com/blog/author/chriscoyier/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/frontendmasters.com/a-progressive-enhancement-challenge.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"A Progressive Enhancement Challenge"}],["meta",{"property":"og:description","content":"Article(s) > A Progressive Enhancement Challenge"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/7324"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/7324"}],["meta",{"name":"twitter:image:alt","content":"A Progressive Enhancement Challenge"}],["meta",{"property":"article:author","content":"Chris Coyier"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"css"}],["meta",{"property":"article:tag","content":"frontendmasters.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-10-03T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > A Progressive Enhancement Challenge"},{"property":"og:description","content":"A Progressive Enhancement Challenge"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/frontendmasters.com/a-progressive-enhancement-challenge.html"}]],"prev":"/programming/css/articles/README.md","date":"2025-10-03T00:00:00.000Z","isOriginal":false,"author":[{"name":"Chris Coyier","url":"https://frontendmasters.com/blog/author/chriscoyier/"}],"cover":"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/7324"},"git":{},"readingTime":{"minutes":4.05,"words":1216},"filePathRelative":"frontendmasters.com/a-progressive-enhancement-challenge.md","copyright":{"author":"Chris Coyier"}}');export{x as comp,T as data};
