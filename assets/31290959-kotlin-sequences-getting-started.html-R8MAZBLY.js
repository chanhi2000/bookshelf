import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as h,d as n,f as t,b as l,t as m,n as g,g as k,w as o,e as s,r,o as f}from"./app-BItykJLQ.js";const b={},y={id:"frontmatter-title-관련",tabindex:"-1"},v={class:"header-anchor",href:"#frontmatter-title-관련"},w={class:"table-of-contents"},q={href:"https://koenig-media.raywenderlich.com/uploads/2022/03/kotlin-sequences-materials.zip",target:"_blank",rel:"noopener noreferrer"},S={class:"hint-container tip"},I={class:"hint-container tip"},T={class:"hint-container tip"},x={href:"https://koenig-media.raywenderlich.com/uploads/2022/03/kotlin-sequences-materials.zip",target:"_blank",rel:"noopener noreferrer"};function j(p,e){const c=r("VPCard"),a=r("router-link"),u=r("SiteInfo"),i=r("VPIcon");return f(),h("div",null,[n("h1",y,[n("a",v,[n("span",null,m(p.$frontmatter.title)+" 관련",1)])]),t(c,g(k({title:"Java > Article(s)",desc:"Article(s)",link:"/programming/java/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),n("nav",w,[n("ul",null,[n("li",null,[t(a,{to:"#getting-started"},{default:o(()=>[...e[0]||(e[0]=[s("Getting Started",-1)])]),_:1})]),n("li",null,[t(a,{to:"#understanding-sequences"},{default:o(()=>[...e[1]||(e[1]=[s("Understanding Sequences",-1)])]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#lazy-processing"},{default:o(()=>[...e[2]||(e[2]=[s("Lazy Processing",-1)])]),_:1})]),n("li",null,[t(a,{to:"#creating-a-sequence"},{default:o(()=>[...e[3]||(e[3]=[s("Creating a Sequence",-1)])]),_:1})])])]),n("li",null,[t(a,{to:"#using-sequence-operators"},{default:o(()=>[...e[4]||(e[4]=[s("Using Sequence Operators",-1)])]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#intermediate-operators"},{default:o(()=>[...e[5]||(e[5]=[s("Intermediate Operators",-1)])]),_:1})]),n("li",null,[t(a,{to:"#terminal-operators"},{default:o(()=>[...e[6]||(e[6]=[s("Terminal Operators",-1)])]),_:1})])])]),n("li",null,[t(a,{to:"#sequences-vs-collections"},{default:o(()=>[...e[7]||(e[7]=[s("Sequences vs. Collections",-1)])]),_:1}),n("ul",null,[n("li",null,[t(a,{to:"#element-operation-order"},{default:o(()=>[...e[8]||(e[8]=[s("Element Operation Order",-1)])]),_:1})]),n("li",null,[t(a,{to:"#stateless-and-stateful-operators"},{default:o(()=>[...e[9]||(e[9]=[s("Stateless and Stateful Operators",-1)])]),_:1})]),n("li",null,[t(a,{to:"#when-to-use-sequences"},{default:o(()=>[...e[10]||(e[10]=[s("When to Use Sequences",-1)])]),_:1})])])]),n("li",null,[t(a,{to:"#where-to-go-from-here"},{default:o(()=>[...e[11]||(e[11]=[s("Where to Go From Here?",-1)])]),_:1})])])]),e[53]||(e[53]=n("hr",null,null,-1)),t(u,{name:"Kotlin Sequences - Getting Started",desc:"In this Kotlin Sequences tutorial, you’ll learn what a sequence is, its operators and when you should consider using them instead of collections.",url:"https://kodeco.com/31290959-kotlin-sequences-getting-started",logo:"https://assets.carolus.kodeco.com/assets/murakami/category-icons/category-getting-started-android-e9d686100b123d4ecc7ed664ce28c6efd1b54ce9ca4c85bcfc0cd93036dbe9f8.svg",preview:"https://koenig-media.raywenderlich.com/uploads/2022/04/KotlinSequences-twitter.png"}),e[54]||(e[54]=l('<p>Dealing with multiple items of a specific type is part of the daily work of, most likely, every software developer out there. A list of coffee roasters, a set of coffee origins, a mapping between coffee origins and farmers… It really depends on the use case.</p><p>You can handle this kind of data in a few ways. The most common is through the <strong>Collections API</strong>. For instance, translating the cases above, you could have something like <code>List&lt;Roaster&gt;</code>, <code>Set&lt;Origin&gt;</code> or <code>Map&lt;Origin, Farmer&gt;</code>.</p><p>While the Collections API does a good job, it might not be suited for all cases. It’s always useful to be aware of alternatives, how they work, and when they can be a better fit.</p><p>In this tutorial, you’ll learn about Kotlin’s <strong>Sequences API</strong>. Specifically, you’ll learn:</p><ul><li>What a sequence is and how it works.</li><li>How to work with a sequence and its operators.</li><li>When should you consider using sequences instead of collections.</li></ul><div class="hint-container tip"><p class="hint-container-title">Note</p><p>This tutorial assumes you have basic Kotlin knowledge. If not, check out <a href="https://www.raywenderlich.com/4736-programming-in-kotlin" target="_blank" rel="noopener noreferrer">Programming in Kotlin</a> first.</p></div><hr><h2 id="getting-started" tabindex="-1"><a class="header-anchor" href="#getting-started"><span>Getting Started</span></a></h2>',8)),n("p",null,[e[13]||(e[13]=s("Download the project materials by clicking the ",-1)),n("a",q,[t(i,{icon:"fas fa-download"}),e[12]||(e[12]=n("code",null,"[Download Materials]",-1))]),e[14]||(e[14]=s(" button at the top or bottom of this tutorial, and open the sta**rter project.",-1))]),e[55]||(e[55]=n("p",null,"Run the project, and you’ll notice it’s just a simple “Hello World” app. If you came here hoping to implement some cool app full of sequences everywhere, the sad truth is that you won’t even touch the app’s code.",-1)),e[56]||(e[56]=n("p",null,'![A simple "Hello World" app on a phone screen.](https://koenig-media.raywenderlich.com/uploads/2022/02/hello-world.png =240x)',-1)),e[57]||(e[57]=n("p",null,[s("Instead, the project exists just so you can use it to create a "),n("strong",null,"scratch file"),s(". When working on a project, you may want to test or draft some code before actually proceeding to a proper implementation. A scratch file lets you do just that. It has both syntax highlighting and code completion. And the best part is, it can run your code right after you write it, letting you debug it as well!")],-1)),n("p",null,[e[15]||(e[15]=s("You’ll now create the scratch file where you’ll work. In Android Studio, go to ",-1)),t(i,{icon:"iconfont icon-select"}),e[16]||(e[16]=n("code",null,"[File] ▸ [New] ▸ [Scratch File]",-1)),e[17]||(e[17]=s(".",-1))]),e[58]||(e[58]=l('<figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/03/Untitled-557x500.png" alt="Creating a new scratch file by selecting it from the dropdown menu." tabindex="0" loading="lazy"><figcaption>Creating a new scratch file by selecting it from the dropdown menu.</figcaption></figure><p>On the little dialog that pops up, scroll until you find <strong>Kotlin</strong>, and pick it.</p><p>In your case, the position may be different.</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-15-at-21.51.50.png" alt="Selecting the kind of scratch file from the dialog." tabindex="0" loading="lazy"><figcaption>Selecting the kind of scratch file from the dialog.</figcaption></figure><p>This opens your new scratch file. At the top, you have a few options to play with.</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-15-at-21.54.48.png" alt="Scratch file options." tabindex="0" loading="lazy"><figcaption>Scratch file options.</figcaption></figure>',6)),n("p",null,[e[18]||(e[18]=s("Make sure ",-1)),t(i,{icon:"iconfont icon-select"}),e[19]||(e[19]=n("code",null,"[Interactive mode]",-1)),e[20]||(e[20]=s(" is checked. This runs any code you write after you stop typing for two seconds. The ",-1)),t(i,{icon:"iconfont icon-select"}),e[21]||(e[21]=n("code",null,"[Use classpath of module]",-1)),e[22]||(e[22]=s(" option is pretty useful if you want to test something that uses code from a specific module. Since that’s not the case here, there’s no need to change it. Also, make sure to leave ",-1)),t(i,{icon:"iconfont icon-select"}),e[23]||(e[23]=n("code",null,"[Use REPL]",-1)),e[24]||(e[24]=s(" unchecked, as that would run the code in Kotlin REPL, and there’s no need for that here.",-1))]),e[59]||(e[59]=l(`<p>Look at your project structure, and you’ll notice that the scratch file is nowhere to be seen. This is because scratch files are <strong>scoped to the IDE</strong> rather than the project. You’ll find the scratch file by switching to the <strong>Project</strong> view under <strong>Scratches and Consoles</strong>.</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/03/Untitled-1.png" alt="Selecting  in Scratches and Consoles." tabindex="0" loading="lazy"><figcaption>Selecting <code>scratch.kts</code> in Scratches and Consoles.</figcaption></figure><p>This is useful if you want to share scratch files between different projects, for example. You can move it to the project’s directory, but that’s not relevant for what you’ll do in this tutorial. That said, it’s time to build some sequences!</p><div class="hint-container tip"><p class="hint-container-title">Note</p><p>If you want to know more about scratch files, check the <a href="https://www.jetbrains.com/help/idea/scratches.html" target="_blank" rel="noopener noreferrer">Jetbrains documentation</a> about them.</p></div><hr><h2 id="understanding-sequences" tabindex="-1"><a class="header-anchor" href="#understanding-sequences"><span>Understanding Sequences</span></a></h2><p>Sequences are data containers, just like collections. However, they have two main differences:</p><ul><li>They execute their operations <strong>lazily</strong>.</li><li>They process elements <strong>one at a time</strong>.</li></ul><p>You’ll learn more about element processing as you go through the tutorial. For now, you’ll dig deeper into what does it mean to execute operations in a lazy fashion.</p><h3 id="lazy-processing" tabindex="-1"><a class="header-anchor" href="#lazy-processing"><span>Lazy Processing</span></a></h3><p>Sequences execute their operations <strong>lazily</strong>, while collections execute them <strong>eagerly</strong>. For instance, if you apply a <code>map</code> to a <code>List</code>:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> list <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">val</span> doubleList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>The operation will execute immediately, and <code>doubleList</code> will be a list of the elements from the first list multiplied by two. If you do this with sequences, however:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> originalSequence <span class="token operator">=</span> <span class="token function">sequenceOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">val</span> doubleSequence <span class="token operator">=</span> originalSequence<span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>While <code>doubleSequence</code> is a different sequence than <code>originalSequence</code>, it won’t have the doubled values. Instead, <code>doubleSequence</code> is a sequence composed by the initial <code>originalSequence</code> <em>and</em> the <code>map</code> operation. The operation will only be executed later, when you query <code>doubleSequence</code> about its result. But, before getting into how to get results from sequences, you need to know about the different ways of creating them.</p><h3 id="creating-a-sequence" tabindex="-1"><a class="header-anchor" href="#creating-a-sequence"><span>Creating a Sequence</span></a></h3><p>You can create sequences in a few ways. You already saw one of them above:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line">val sequence <span class="token operator">=</span> <span class="token function">sequenceOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The <code>sequenceOf()</code> function works just like the <code>listOf()</code> function or any other collections function of the same kind. You pass in the elements as parameters, and it outputs a sequence.</p><p>Another way of creating a sequence is by doing so from a collection:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line">val coffeeOriginsSequence <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span></span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;Ethiopia&quot;</span></span><span class="token punctuation">,</span> </span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;Colombia&quot;</span></span><span class="token punctuation">,</span> </span>
<span class="line">  <span class="token string-literal"><span class="token string">&quot;El Salvador&quot;</span></span></span>
<span class="line"><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asSequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>asSequence()</code> function can be called on any <code>Iterable</code>, which every <code>Collection</code> implements. It outputs a sequence with the same elements present in said <code>Iterable</code>.</p><p>The last sequence creation method you’ll see here is by using a generator function. Here’s an example:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> naturalNumbersSequence <span class="token operator">=</span> <span class="token function">generateSequence</span><span class="token punctuation">(</span>seed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> previousNumber <span class="token operator">-&gt;</span> previousNumber <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>The <code>generateSequence</code> function takes a <code>seed</code> as the first element of the sequence and a lambda to produce the remaining elements, starting from that seed.</p><p>Unlike the <code>Collection</code> interface, the <code>Sequence</code> interface doesn’t bind any of its implementations to a <code>size</code> property. In other words, you can create <em>infinite</em> sequences, which is exactly what the code above does. The code starts at one, and goes <em>to infinity and beyond</em> from there, adding one to each generated value.</p><p>As you might suspect, you could get in trouble if you try to operate on this sequence. It’s infinite! What if you try to get <em>all</em> its elements? How will you stop?</p><p>One way is to use some kind of stopping mechanism in the generator function itself. In fact, <code>generateSequence</code> is programmed to stop generation when it returns <code>null</code>. Translating that into code, this is how to create a finite sequence:</p><div class="language-swift line-numbers-mode" data-highlighter="prismjs" data-ext="swift"><pre><code class="language-swift"><span class="line">val naturalNumbersUpToTwoHundredMillion <span class="token operator">=</span> </span>
<span class="line">  <span class="token function">generateSequence</span><span class="token punctuation">(</span>seed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> previousNumber <span class="token operator">-&gt;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNumber <span class="token operator">&lt;</span> <span class="token number">200_000_000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 1</span></span>
<span class="line">        previousNumber <span class="token operator">+</span> <span class="token number">1</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        null <span class="token comment">// 2</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this code:</p><ol><li>You check if the previously generated value is below 200,000,000. If so, you add one to it.</li><li>If you reach a value equal to 200,000,000 or above, you return <code>null</code>, effectively stopping the sequence generation.</li></ol><p>Another way of stopping sequence generation is by using some of its <strong>operators</strong>, which you&#39;ll learn about in the next section.</p><hr><h2 id="using-sequence-operators" tabindex="-1"><a class="header-anchor" href="#using-sequence-operators"><span>Using Sequence Operators</span></a></h2><p>Sequences have two kinds of operators:</p><ul><li><strong>Intermediate operators</strong>: Operators used to <em>build</em> the sequence.</li><li><strong>Terminal operators</strong>: Operators used to <em>execute</em> the operations the sequence was built with.</li></ul><p>You&#39;ll learn about intermediate operators first.</p><h3 id="intermediate-operators" tabindex="-1"><a class="header-anchor" href="#intermediate-operators"><span>Intermediate Operators</span></a></h3><p>To start understanding how operators work, write that last sequence in your scratch file:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> naturalNumbersUpToTwoHundredMillion <span class="token operator">=</span> </span>
<span class="line">  <span class="token function">generateSequence</span><span class="token punctuation">(</span>seed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> previousNumber <span class="token operator">-&gt;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNumber <span class="token operator">&lt;</span> <span class="token number">200_000_000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      previousNumber <span class="token operator">+</span> <span class="token number">1</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">null</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now, build a new sequence from it by adding two intermediate operators. You&#39;ll probably recognize these, as sequences and collections have a lot of similar operators:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> firstHundredEvenNaturalNumbers <span class="token operator">=</span> naturalNumbersUpToTwoHundredMillion</span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token comment">// 1</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// 2</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In this code, you:</p><ol><li>Filter the elements by their parity, accepting only the even ones, i.e, the ones divisible by two.</li><li>Take the first 100 elements, discarding the rest.</li></ol><p>As mentioned before, sequences process their operations <em>one element at a time</em>. In other words, <code>filter</code> starts by operating on the first number, <code>1</code>, and then discarding it since it&#39;s not divisible by two. Then, it operates on <code>2</code>, letting it proceed to <code>take</code>, as <code>2</code> is an even number. The operations keep going until the element operated on is <code>200</code> since, in the <code>[1, 200_000_000]</code> interval, <code>200</code> is the hundredth even number. At that point, neither <code>take</code> nor <code>filter</code> handle any more elements.</p><p>This might get confusing to read, so here&#39;s a visualization of what&#39;s happening:</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/intermediate-operators.gif" alt="Sequence intermediate operators, rejecting odd numbers and selecting even ones." tabindex="0" loading="lazy"><figcaption>Sequence intermediate operators, rejecting odd numbers and selecting even ones.</figcaption></figure><p>Thanks to <code>take(100)</code>, <code>200,000,000</code> never gets operated on, along with the all the numbers before it, from <code>200</code> onward.</p><p>As you&#39;ll notice in your scratch file, <code>firstHundredEvenNaturalNumbers</code> isn&#39;t actually outputting any values yet. In fact, the scratch file just shows the type:</p><p>You already know it&#39;s a sequence of Ints!</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-15-at-22.09.26.png" alt="Intermediate operators have no useful output." tabindex="0" loading="lazy"><figcaption>Intermediate operators have no useful output.</figcaption></figure><p>As you may suspect already, you still need a terminal operator to output the sequence&#39;s result.</p><h3 id="terminal-operators" tabindex="-1"><a class="header-anchor" href="#terminal-operators"><span>Terminal Operators</span></a></h3><p>Terminal operators can take many forms. Some, like <code>toList()</code> or <code>toSet()</code>, can output the sequence results as a collection. Others, like <code>first()</code> or <code>sum()</code>, output a single value.</p><p>There are a lot of terminal operators, but there&#39;s an easy way to identify them without having to dig into the implementation or documentation.</p><p>Back in your scratch file, just below <code>take(100)</code>, start typing the <code>map</code> operator. As you type, Android Studio will pop up code completion. If you look at the suggestions, you&#39;ll see that <code>map</code> has the return type of <code>Sequence</code>, with <code>R</code> being the return type for map.</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-16-at-00.24.08.png" alt="Code completion for an intermediate sequence operator." tabindex="0" loading="lazy"><figcaption>Code completion for an intermediate sequence operator.</figcaption></figure><p>Now, delete it! Delete the <code>map</code> you just typed. And in its place, start typing the <code>forEach</code> terminal operator. When code completion pops up, notice the return type of <code>forEach</code>.</p><figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-16-at-00.59.25.png" alt="Code completion for terminal sequence operator." tabindex="0" loading="lazy"><figcaption>Code completion for terminal sequence operator.</figcaption></figure><p>Unlike <code>map</code>, <code>forEach</code> doesn&#39;t return a <code>Sequence</code>. Which makes sense, right? It&#39;s a terminal operator, after all. So, long story short, that&#39;s how you can distinguish them at a glance:</p><ul><li>Intermediate operators <em>always</em> return a <code>Sequence</code>.</li><li>Terminal operators <em>never</em> return a <code>Sequence</code>.</li></ul><p>You now know how to build a sequence and output its result. So, now it&#39;s time to try it out! Finish that terminal operator you were just writing by printing each element with it. In the end, you should have something like:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> firstHundredEvenNaturalNumbers <span class="token operator">=</span> naturalNumbersUpToTwoHundredMillion</span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You&#39;ll see the result printed on the top right side of the scratch file.</p>`,64)),n("div",S,[e[30]||(e[30]=n("p",{class:"hint-container-title"},"Note",-1)),n("p",null,[e[25]||(e[25]=s("If you don't see anything, click the green ",-1)),t(i,{icon:"iconfont icon-select"}),e[26]||(e[26]=n("code",null,"[play]",-1)),e[27]||(e[27]=s(' button — "run scratch file" — at the top of the file, next to the ',-1)),t(i,{icon:"iconfont icon-select"}),e[28]||(e[28]=n("code",null,"[trash can]",-1)),e[29]||(e[29]=s(' — "clear results". Clicking the button cleans up all the output and runs the code again.',-1))])]),e[60]||(e[60]=l(`<figure><img src="https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-16-at-01.35.05.png" alt="Result of a terminal sequence operator, showing results of even numbers up to 14" tabindex="0" loading="lazy"><figcaption>Result of a terminal sequence operator, showing results of even numbers up to 14</figcaption></figure><p>If you expand it, you&#39;ll see that it printed every even number up to 200.</p><p>Just like with collections, operator order is important in sequences. For instance, swap <code>take</code> with <code>filter</code>, like so:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> firstHundredEvenNaturalNumbers <span class="token operator">=</span> naturalNumbersUpToTwoHundredMillion</span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span> </span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4)),n("div",I,[e[38]||(e[38]=n("p",{class:"hint-container-title"},"Note",-1)),n("p",null,[e[31]||(e[31]=s("Before doing this change, you may want to disable ",-1)),t(i,{icon:"iconfont icon-select"}),e[32]||(e[32]=n("code",null,"[Interactive mode]",-1)),e[33]||(e[33]=s(". Otherwise, if you happen to cut the ",-1)),e[34]||(e[34]=n("code",null,"take(100)",-1)),e[35]||(e[35]=s(" line — with the intent of pasting it later — the IDE will run the code from the scratch file, and it'll take a while before you get any results. This is because ",-1)),e[36]||(e[36]=n("code",null,"forEach",-1)),e[37]||(e[37]=s(" is a terminal operator, therefore, it'll iterate two hundred million elements.",-1))])]),e[61]||(e[61]=l('<p>After a few seconds, the scratch file should run your code again. Expand it, and you&#39;ll see that it has printed every even number up to 100. Since <code>take</code> is running first, <code>filter</code> only gets to operate on the first 100 natural numbers, starting from one.</p><p>Now that you&#39;ve played around with sequences a bit, all that&#39;s left is to address the elephant in the room: When should you use sequences?</p><hr><h2 id="sequences-vs-collections" tabindex="-1"><a class="header-anchor" href="#sequences-vs-collections"><span>Sequences vs. Collections</span></a></h2><p>You now know how to build and use sequences. But when should you use them instead of collections? Should you use them at all?</p><p>This can be quickly answered with one of the most famous sayings in software development: It depends.</p><p>The long answer is a bit more complex. It <em>always</em> depends on your use case. In fact, to be really sure, you should always measure both implementations to check which one is faster. However, knowing about a few quirks surrounding sequences will also help you make a better-informed decision.</p><h3 id="element-operation-order" tabindex="-1"><a class="header-anchor" href="#element-operation-order"><span>Element Operation Order</span></a></h3>',8)),n("p",null,[e[39]||(e[39]=s("In case you have the memory of a goldfish, remember that sequences operate on each element at a time. Collections, on the other hand, execute each operation for the whole collection, building an ",-1)),t(i,{icon:"iconfont icon-select"}),e[40]||(e[40]=n("code",null,"[intermediate result]",-1)),e[41]||(e[41]=s(" before proceeding to the next operation. So, each collection operation creates an intermediate collection with its results, where the next operation will operate on:",-1))]),e[62]||(e[62]=l(`<div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> list <span class="token operator">=</span> naturalNumbersUpToTwoHundredMillion</span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the code above, <code>filter</code> would create a new list, then <code>take</code> would operate on that list, creating a new one of its own, and so on and so forth. That&#39;s a lot of wasted work! Especially since you&#39;re only taking 100 elements in the end. There&#39;s absolutely no need to bother with the elements after the hundredth one.</p><div class="hint-container tip"><p class="hint-container-title">Note</p><p>It might not be wise to run this code in your scratch file. Computers aren&#39;t fond of working with such large lists. It might even stop responding! And if it doesn&#39;t, the scratch file will probably crash while building and output nothing.</p></div><p>Sequences effectively avoid computing intermediate results, being able to <em>outperform</em> collections in cases like this one. However, it&#39;s not all roses and unicorns.</p><p>Each intermediate operation added introduces some overhead. This overhead comes from the fact that each operation involves the creation of a new function object to store the transformation to be executed later. In fact, this overhead can be problematic for datasets that aren&#39;t large enough or in cases where you don&#39;t need that many operations. This overhead may even outweigh the gains from avoiding intermediate results.</p><p>To better understand where this overhead comes from, look at <code>filter</code>&#39;s implementation:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">public</span> <span class="token keyword">fun</span> Sequence<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>predicate<span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> Boolean<span class="token punctuation">)</span><span class="token operator">:</span> Sequence <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">FilteringSequence</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> predicate<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7)),n("div",T,[e[49]||(e[49]=n("p",{class:"hint-container-title"},"Note",-1)),n("p",null,[e[42]||(e[42]=s("You won't be able to properly check the implementation of ",-1)),e[43]||(e[43]=n("code",null,"filter",-1)),e[44]||(e[44]=s(" in the scratch file. If you try, the IDE will show you a decompiled ",-1)),t(i,{icon:"fas fa-file-lines"}),e[45]||(e[45]=n("code",null,".class",-1)),e[46]||(e[46]=s(" file. For that reason, the final project has a Sequences.kt file with all the tutorial code, where you can easily check the inner workings of sequences. Or you can also check the ",-1)),e[47]||(e[47]=n("a",{href:"https://github.com/JetBrains/kotlin/blob/v1.6.10/libraries/stdlib/common/src/generated/_Sequences.kt#L429",target:"_blank",rel:"noopener noreferrer"},"Jetbrains source code",-1)),e[48]||(e[48]=s(".",-1))])]),e[63]||(e[63]=l(`<p>That <code>FilteringSequence</code> is a <code>Sequence</code> of its own. It wraps the <code>Sequence</code> where you call on <code>filter</code>. In other words, each intermediate operator creates a new <code>Sequence</code> object that <em>decorates</em> the previous <code>Sequence</code>. In the end, you&#39;re left with at least as many objects as intermediate operators, all wrapped around each other.</p><p>To complicate things a bit, not all intermediate operators limit themselves to just decorating the previous sequence. Some of them need to be aware of the sequence&#39;s <strong>state</strong>.</p><h3 id="stateless-and-stateful-operators" tabindex="-1"><a class="header-anchor" href="#stateless-and-stateful-operators"><span>Stateless and Stateful Operators</span></a></h3><p>Intermediate operators can be:</p><ul><li><strong>Stateless</strong>: They process each element independently, without needing to know about any other element.</li><li><strong>Stateful</strong>: They need information about other elements to process the current element.</li></ul><p>The intermediate operators you&#39;ve seen in this tutorial so far are all stateless. So, what does a stateful operator look like?</p><p>In your scratch file, just before the terminal <code>forEach</code> operator, add a <code>sortedDescending()</code> call, like so:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">val</span> firstHundredEvenNaturalNumbers <span class="token operator">=</span> naturalNumbersUpToTwoHundredMillion</span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">sortedDescending</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// add this call</span></span>
<span class="line">  <span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> number <span class="token operator">-&gt;</span> <span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>As you can see from the scratch file output, you get the same list of numbers as before, but printed in reverse. For <code>sortedDescending</code> to be able to reverse it, it had to process each element while comparing to every other element of the sequence. But how could it do that, since sequences process one element at a time?</p><p>The answer is actually quite simple, but it&#39;ll betray your confidence in sequences. Check how <code>sortedDescending</code> is implemented, and you&#39;ll see that it delegates the sorting to a function called <code>sortedWith</code>. In turn, if you check the implementation of <code>sortedWith</code>, you&#39;ll see something like this:</p><div class="language-kotlin line-numbers-mode" data-highlighter="prismjs" data-ext="kt"><pre><code class="language-kotlin"><span class="line"><span class="token keyword">public</span> <span class="token keyword">fun</span> Sequence<span class="token punctuation">.</span><span class="token function">sortedWith</span><span class="token punctuation">(</span>comparator<span class="token operator">:</span> Comparator<span class="token punctuation">)</span><span class="token operator">:</span> Sequence <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">object</span> <span class="token operator">:</span> Sequence <span class="token punctuation">{</span> <span class="token comment">// 1</span></span>
<span class="line">    <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Iterator <span class="token punctuation">{</span> <span class="token comment">// 2</span></span>
<span class="line">      <span class="token keyword">val</span> sortedList <span class="token operator">=</span> <span class="token keyword">this</span><span class="token label symbol">@sortedWith</span><span class="token punctuation">.</span><span class="token function">toMutableList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 3</span></span>
<span class="line">      sortedList<span class="token punctuation">.</span><span class="token function">sortWith</span><span class="token punctuation">(</span>comparator<span class="token punctuation">)</span> <span class="token comment">// 4</span></span>
<span class="line">      <span class="token keyword">return</span> sortedList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 5</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here&#39;s what the code is doing:</p><ol><li>It creates and returns an anonymous <code>object</code> that implements the <code>Sequence</code> interface.</li><li>The <code>object</code> implements the <code>iterator()</code> method of the <code>Sequence</code> interface.</li><li>The method converts the sequence to a <code>MutableList</code>.</li><li>It then sorts the list according to the <code>comparator</code>.</li><li>Finally, it returns the list&#39;s <code>iterator</code>.</li></ol><p>Wait, what?! It converts the <em>sequence</em> to a <em>collection</em>. That <code>toMutableList</code> is a terminal operator. This intermediate operator effectively calls a terminal operator on the sequence and then outputs a new one in the end.</p><p>So, for instance, think what will happen if you call <code>sortedDescending</code> on <code>naturalNumbersUpToTwoHundredMillion</code> before any other operator: You&#39;ll have a <code>MutableList</code> with two hundred million elements in memory! You <em>can</em> try it in your scratch file, but be warned that it&#39;ll take a while before you get any results.</p><p>It takes a while!</p><p>Running the code with two hundred million elements in memory. While not all stateful operators use a <code>MutableList</code> behind the curtain like <code>sortedDescending</code>, they all do similar <em>tricks</em> to have the state needed to perform their tasks. That said, these operators can have a huge negative impact on the sequence&#39;s performance, so always be mindful of when to use them, as their impact can be strong enough for collections to be a better fit.</p><h3 id="when-to-use-sequences" tabindex="-1"><a class="header-anchor" href="#when-to-use-sequences"><span>When to Use Sequences</span></a></h3><p>After all this, you should have a rough idea of the situations where sequences might come in handy. Here&#39;s a summary of the factors that might make sequences a better fit than collections:</p><ul><li>Working with large datasets, applying a lot of operations.</li><li>Using intermediate operators that avoid unnecessary work — like <code>take</code>, for instance.</li><li>Avoiding stateful operators.</li><li>Avoiding terminal operators that convert the sequence to a collection — like <code>toList</code>, for instance.</li></ul><p>And again, while these might point you in the right direction, don&#39;t forget: You&#39;ll never know for sure which one fits best <em>unless you measure</em>!</p><hr><h2 id="where-to-go-from-here" tabindex="-1"><a class="header-anchor" href="#where-to-go-from-here"><span>Where to Go From Here?</span></a></h2>`,23)),n("p",null,[e[51]||(e[51]=s("You can download the completed project files by clicking the ",-1)),n("a",x,[t(i,{icon:"fas fa-download"}),e[50]||(e[50]=n("code",null,"[Download Materials]",-1))]),e[52]||(e[52]=s(" button at the top or bottom of the tutorial.",-1))]),e[64]||(e[64]=l('<p>In this tutorial, you learned a lot about when to use sequences versus collections, but there&#39;s still a lot to learn about the topic.</p><p>If you want to dig deeper into <code>Sequence</code> and operators, Kotlin&#39;s documentation is always a good place to start. Check out <a href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener noreferrer">the documentation for Sequence</a> and <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/" target="_blank" rel="noopener noreferrer">the list of operators</a>.</p><p>To learn more about how they compare to collections, you can read <a href="https://medium.com/androiddevelopers/collections-and-sequences-in-kotlin-55db18283aca" target="_blank" rel="noopener noreferrer">Collections and sequences in Kotlin</a>.</p><p>To measure the performance of an app, you&#39;ll find several methods and tools. You can check the <a href="https://developer.android.com/studio/profile" target="_blank" rel="noopener noreferrer">user guide</a> from Android Developers or the tutorial <a href="https://www.raywenderlich.com/4557771-android-memory-profiler-getting-started" target="_blank" rel="noopener noreferrer">Android Memory Profiler: Getting Started</a>.</p><p>I hope you&#39;ve enjoyed this tutorial. If you have any questions, tips or comments, feel free to join the discussion below.</p>',5))])}const E=d(b,[["render",j]]),O=JSON.parse('{"path":"/kodeco.com/31290959-kotlin-sequences-getting-started.html","title":"Kotlin Sequences - Getting Started","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"Kotlin Sequences - Getting Started","description":"Article(s) > Kotlin Sequences - Getting Started","icon":"iconfont icon-kotlin","category":["Java","Kotlin","Gradle"],"tag":["blog","kodeco.com","java","kotiln","gradle"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kotlin Sequences - Getting Started\\",\\"image\\":[\\"https://koenig-media.raywenderlich.com/uploads/2022/02/hello-world.png =240x\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/03/Untitled-557x500.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-15-at-21.51.50.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-15-at-21.54.48.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/03/Untitled-1.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/intermediate-operators.gif\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-15-at-22.09.26.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-16-at-00.24.08.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-16-at-00.59.25.png\\",\\"https://koenig-media.raywenderlich.com/uploads/2022/02/Screenshot-2022-02-16-at-01.35.05.png\\"],\\"datePublished\\":\\"2022-04-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/kodeco.com/31290959-kotlin-sequences-getting-started.html"}],["meta",{"property":"og:site_name","content":"📚Bookshelf"}],["meta",{"property":"og:title","content":"Kotlin Sequences - Getting Started"}],["meta",{"property":"og:description","content":"Article(s) > Kotlin Sequences - Getting Started"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://koenig-media.raywenderlich.com/uploads/2022/04/KotlinSequences-twitter.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://koenig-media.raywenderlich.com/uploads/2022/04/KotlinSequences-twitter.png"}],["meta",{"name":"twitter:image:alt","content":"Kotlin Sequences - Getting Started"}],["meta",{"property":"article:tag","content":"gradle"}],["meta",{"property":"article:tag","content":"kotiln"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:tag","content":"kodeco.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2022-04-04T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Kotlin Sequences - Getting Started"},{"property":"og:description","content":"Kotlin Sequences - Getting Started"},{"property":"og:url","content":"https://chanhi2000.github.io/crashcourse/kodeco.com/31290959-kotlin-sequences-getting-started.html"}]],"prev":"/programming/java/articles/README.md","date":"2022-04-04T00:00:00.000Z","isOriginal":false,"cover":"https://koenig-media.raywenderlich.com/uploads/2022/04/KotlinSequences-twitter.png"},"git":{},"readingTime":{"minutes":12.04,"words":3613},"filePathRelative":"kodeco.com/31290959-kotlin-sequences-getting-started.md"}');export{E as comp,O as data};
