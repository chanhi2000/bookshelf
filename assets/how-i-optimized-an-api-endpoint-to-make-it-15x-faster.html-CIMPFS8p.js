import{_ as g}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as v,d as t,f as a,b as c,t as k,n as f,g as b,w as s,e as n,r,o as w}from"./app-BItykJLQ.js";const y={},I={id:"frontmatter-title-á„€á…ªá†«á„…á…§á†«",tabindex:"-1"},x={class:"header-anchor",href:"#frontmatter-title-á„€á…ªá†«á„…á…§á†«"},A={class:"table-of-contents"},T={href:"https://linkedin.com/feed/update/urn:li:activity:6966700329111310336/",target:"_blank",rel:"noopener noreferrer"},z={href:"https://github.com/DapperLib/Dapper",target:"_blank",rel:"noopener noreferrer"},P={href:"https://redis.io/",target:"_blank",rel:"noopener noreferrer"};function E(d,e){const u=r("VPCard"),o=r("router-link"),m=r("SiteInfo"),p=r("VPIcon"),h=r("Tabs");return w(),v("div",null,[t("h1",I,[t("a",x,[t("span",null,k(d.$frontmatter.title)+" ê´€ë ¨",1)])]),a(u,f(b({title:"C# > Article(s)",desc:"Article(s)",link:"/programming/cs/articles/README.md",logo:"https://chanhi2000.github.io/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",A,[t("ul",null,[t("li",null,[a(o,{to:"#focus-on-bottlenecks-first"},{default:s(()=>[...e[0]||(e[0]=[n("Focus On Bottlenecks First",-1)])]),_:1})]),t("li",null,[a(o,{to:"#reduce-the-number-of-round-trips"},{default:s(()=>[...e[1]||(e[1]=[n("Reduce The Number of Round Trips",-1)])]),_:1})]),t("li",null,[a(o,{to:"#parallelize-external-calls"},{default:s(()=>[...e[2]||(e[2]=[n("Parallelize External Calls",-1)])]),_:1})]),t("li",null,[a(o,{to:"#caching-as-a-last-resort"},{default:s(()=>[...e[3]||(e[3]=[n("Caching As a Last Resort",-1)])]),_:1})]),t("li",null,[a(o,{to:"#closing-thoughts"},{default:s(()=>[...e[4]||(e[4]=[n("Closing Thoughts",-1)])]),_:1})])])]),e[26]||(e[26]=t("hr",null,null,-1)),a(m,{name:"How I Optimized an API Endpoint to Make It 15x Faster",desc:"Performance optimizations are my favorite thing about software engineering. Over the last 5 years, I've encountered various performance problems that taught me different ways to overcome them.",url:"https://milanjovanovic.tech/blog/how-i-optimized-an-api-endpoint-to-make-it-15x-faster/",logo:"https://milanjovanovic.tech/profile_favicon.png",preview:"https://milanjovanovic.tech/blog-covers/mnw_007.png"}),e[27]||(e[27]=t("p",null,"Performance optimization is my favorite thing about software engineering. Over the last 5 years, I've encountered various performance problems that taught me different ways to overcome them.",-1)),e[28]||(e[28]=t("p",null,"About a month ago, I ran into an issue with an API endpoint that wasn't scaling well.",-1)),e[29]||(e[29]=t("p",null,"This endpoint is used to calculate a report for an e-commerce web application. It needed to talk to multiple modules (services) to gather all the necessary data, combine it and perform the calculations.",-1)),t("p",null,[e[6]||(e[6]=n("I made a ",-1)),t("a",T,[a(p,{icon:"fa-brands fa-linkedin"}),e[5]||(e[5]=n("post about it on LinkedIn",-1))]),e[7]||(e[7]=n(" that resonated with many people.",-1))]),e[30]||(e[30]=c('<figure><img src="https://milanjovanovic.tech/blogs/mnw_007/linkedin_post.png?imwidth=1920" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>In this newsletter, I want to break down what I did to achieve a <strong>15x performance improvement</strong>.</p><hr><h2 id="focus-on-bottlenecks-first" tabindex="-1"><a class="header-anchor" href="#focus-on-bottlenecks-first"><span>Focus On Bottlenecks First</span></a></h2><p>The first thing I do when I&#39;m solving a performance problem is determine where the slowest piece of the code is. Fixing this part of the code will usually give the most significant improvement.</p><p>Solving one bottleneck can also reveal where the next bottleneck is.<br>This is a continual process.</p><p>In my situation, there were a few bottlenecks:</p><ul><li>Calling the database from a loop</li><li>Calling an external service multiple times</li><li>Executing a complex calculation multiple times with identical parameters</li></ul><p>How can you measure performance?</p><p>A simple approach can be using <code>System.Timers.Timer</code> where you manually log execution times between method calls. Or you can use a performance profiler.</p><hr><h2 id="reduce-the-number-of-round-trips" tabindex="-1"><a class="header-anchor" href="#reduce-the-number-of-round-trips"><span>Reduce The Number of Round Trips</span></a></h2><p>A round trip between your application and a database (or some other service) can last 5-10ms, or more. If you have many round trips in your flow, it&#39;s going to add up quickly.</p><p>Here are a few things you can do reduce the number of round trips:</p>',14)),a(h,{data:[{id:"1."},{id:"2."},{id:"3."}],active:0},{title0:s(({value:i,isActive:l})=>[...e[8]||(e[8]=[n("1.",-1)])]),title1:s(({value:i,isActive:l})=>[...e[9]||(e[9]=[n("2.",-1)])]),title2:s(({value:i,isActive:l})=>[...e[10]||(e[10]=[n("3.",-1)])]),tab0:s(({value:i,isActive:l})=>[...e[11]||(e[11]=[t("p",null,"Don't call the database from a loop. This can usually be solved with a simple query like this:",-1),t("div",{class:"language-sql line-numbers-mode","data-highlighter":"prismjs","data-ext":"sql"},[t("pre",null,[t("code",{class:"language-sql"},[t("span",{class:"line"},[n("   "),t("span",{class:"token keyword"},"SELECT"),n(),t("span",{class:"token operator"},"*"),n(),t("span",{class:"token keyword"},"FROM"),n(),t("span",{class:"token punctuation"},"["),n("TableName"),t("span",{class:"token punctuation"},"]"),n(),t("span",{class:"token keyword"},"WHERE"),n(" Id "),t("span",{class:"token operator"},"IN"),n(),t("span",{class:"token punctuation"},"("),n("list_of_ids"),t("span",{class:"token punctuation"},")")]),n(`
`),t("span",{class:"line"})])]),t("div",{class:"line-numbers","aria-hidden":"true",style:{"counter-reset":"line-number 0"}},[t("div",{class:"line-number"})])],-1)])]),tab1:s(({value:i,isActive:l})=>[t("p",null,[e[13]||(e[13]=n("Use a query that returns multiple result sets from the database. One library that supports this is ",-1)),t("a",z,[a(p,{icon:"iconfont icon-github"}),e[12]||(e[12]=t("code",null,"DapperLib/Dapper",-1))]),e[14]||(e[14]=n(", with the ",-1)),e[15]||(e[15]=t("code",null,"QueryMultiple",-1)),e[16]||(e[16]=n(" method.",-1))]),e[17]||(e[17]=t("p",null,null,-1))]),tab2:s(({value:i,isActive:l})=>[...e[18]||(e[18]=[t("p",null,"If you need to make multiple calls to another service, try to convert that into one call. And in the service, aggregate the required data and return everything at once.",-1)])]),_:1}),e[31]||(e[31]=c(`<hr><h2 id="parallelize-external-calls" tabindex="-1"><a class="header-anchor" href="#parallelize-external-calls"><span>Parallelize External Calls</span></a></h2><p>I had a situation where I was awaiting multiple asynchronous calls from a few services. These calls had no dependencies on each other, so I used a simple technique to gain a significant performance improvement.</p><p>Let&#39;s say you&#39;re awaiting two tasks:</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token class-name"><span class="token keyword">var</span></span> task1Result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">CallService1Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name"><span class="token keyword">var</span></span> task2Result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">CallService2Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Use the results.</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>A simple way to parallelize these calls is using the <code>Task.WhenAll</code> method:</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code class="language-csharp"><span class="line"><span class="token class-name"><span class="token keyword">var</span></span> task1 <span class="token operator">=</span> <span class="token function">CallService1Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name"><span class="token keyword">var</span></span> task2 <span class="token operator">=</span> <span class="token function">CallService2Async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">WhenAll</span><span class="token punctuation">(</span>task1<span class="token punctuation">,</span> task2<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// Use the results.</span></span>
<span class="line">task1<span class="token punctuation">.</span>Result<span class="token punctuation">;</span></span>
<span class="line">task2<span class="token punctuation">.</span>Result<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Notice that I&#39;m directly accessing the <code>Result</code> property on the tasks. This can be <strong>detrimental</strong> if you&#39;re using it to block on an asynchronous call, and can even lead to deadlocks.</p><p>However, in this situation it is perfectly safe to do, because the two tasks will have completed after the call to <code>Task.WhenAll</code> completes.</p><p>Of course, whether or not these tasks will be executed in parallel when calling <code>Task.WhenAll</code> depends on a few factors, which I won&#39;t cover here.</p><hr><h2 id="caching-as-a-last-resort" tabindex="-1"><a class="header-anchor" href="#caching-as-a-last-resort"><span>Caching As a Last Resort</span></a></h2><p>I try to leave caching for the end, after I have exhausted all other possibilities to improve performance. While I love to use caching in general, I&#39;m aware it can introduce some unwanted behavior when data is stale.</p><p>You have to consider how long you can safely cache the data, and how you are going to clear the cache if the underlying data changes.</p>`,14)),t("p",null,[e[20]||(e[20]=n("In simple applications, I use ",-1)),e[21]||(e[21]=t("code",null,"IMemoryCache",-1)),e[22]||(e[22]=n(" that is available in ",-1)),e[23]||(e[23]=t("strong",null,"ASP.NET Core",-1)),e[24]||(e[24]=n(" out of the box. But you can also use an external cache like ",-1)),t("a",P,[a(p,{icon:"iconfont icon-redis"}),e[19]||(e[19]=n("Redis",-1))]),e[25]||(e[25]=n(".",-1))]),e[32]||(e[32]=t("p",null,"A good candidate for caching is data that is frequently accessed, but rarely modified.",-1)),e[33]||(e[33]=t("hr",null,null,-1)),e[34]||(e[34]=t("h2",{id:"closing-thoughts",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#closing-thoughts"},[t("span",null,"Closing Thoughts")])],-1)),e[35]||(e[35]=t("p",null,"I didn't talk about database optimization and indexes here, but this should also be on your mind if the database is your bottleneck.",-1))])}const O=g(y,[["render",E]]),R=JSON.parse('{"path":"/milanjovanovic.tech/how-i-optimized-an-api-endpoint-to-make-it-15x-faster.html","title":"How I Optimized an API Endpoint to Make It 15x Faster","lang":"ko-KR","frontmatter":{"lang":"ko-KR","title":"How I Optimized an API Endpoint to Make It 15x Faster","description":"Article(s) > How I Optimized an API Endpoint to Make It 15x Faster","icon":"iconfont icon-csharp","category":["C#","DotNet","Article(s)"],"tag":["blog","milanjovanovic.tech","cs","c#","csharp","dotnet"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"How I Optimized an API Endpoint to Make It 15x Faster\\",\\"image\\":[\\"https://milanjovanovic.tech/blogs/mnw_007/linkedin_post.png?imwidth=1920\\"],\\"datePublished\\":\\"2022-10-15T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Milan JovanoviÄ‡\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/how-i-optimized-an-api-endpoint-to-make-it-15x-faster.html"}],["meta",{"property":"og:site_name","content":"ðŸ“šBookshelf"}],["meta",{"property":"og:title","content":"How I Optimized an API Endpoint to Make It 15x Faster"}],["meta",{"property":"og:description","content":"Article(s) > How I Optimized an API Endpoint to Make It 15x Faster"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://milanjovanovic.tech/blog-covers/mnw_007.png"}],["meta",{"property":"og:locale","content":"ko-KR"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://milanjovanovic.tech/blog-covers/mnw_007.png"}],["meta",{"name":"twitter:image:alt","content":"How I Optimized an API Endpoint to Make It 15x Faster"}],["meta",{"property":"article:author","content":"Milan JovanoviÄ‡"}],["meta",{"property":"article:tag","content":"dotnet"}],["meta",{"property":"article:tag","content":"csharp"}],["meta",{"property":"article:tag","content":"c#"}],["meta",{"property":"article:tag","content":"cs"}],["meta",{"property":"article:tag","content":"milanjovanovic.tech"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2022-10-15T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > How I Optimized an API Endpoint to Make It 15x Faster"},{"property":"og:description","content":"How I Optimized an API Endpoint to Make It 15x Faster"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/how-i-optimized-an-api-endpoint-to-make-it-15x-faster.html"}]],"prev":"/programming/cs/articles/README.md","date":"2022-10-15T00:00:00.000Z","isOriginal":false,"author":"Milan JovanoviÄ‡","cover":"https://milanjovanovic.tech/blog-covers/mnw_007.png"},"git":{},"readingTime":{"minutes":3,"words":901},"filePathRelative":"milanjovanovic.tech/how-i-optimized-an-api-endpoint-to-make-it-15x-faster.md","copyright":{"author":"Milan JovanoviÄ‡"}}');export{O as comp,R as data};
