import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as b,d as t,f as n,b as a,a as u,t as y,n as p,g,w as s,e as o,r as l,o as k}from"./app-BItykJLQ.js";const w={},v={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},D={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},x={class:"table-of-contents"},L={href:"https://jpetazzo.github.io/2014/08/24/syslog-docker/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://aws.amazon.com/cloudwatch/",target:"_blank",rel:"noopener noreferrer"},T={href:"https://cloud.google.com/stackdriver/",target:"_blank",rel:"noopener noreferrer"},E={href:"https://honeycomb.io/",target:"_blank",rel:"noopener noreferrer"},G={href:"https://loggly.com/",target:"_blank",rel:"noopener noreferrer"},P={href:"https://splunk.com/",target:"_blank",rel:"noopener noreferrer"},q={href:"http://jpetazzo.github.io/orchestration-workshop/",target:"_blank",rel:"noopener noreferrer"},j={href:"https://jpetazzo.github.io/orchestration-workshop/#logging",target:"_blank",rel:"noopener noreferrer"},F={href:"https://elastic.co/webinars/introduction-elk-stack",target:"_blank",rel:"noopener noreferrer"},A={href:"https://twitter.com/alicegoldfuss/status/811009771583074304",target:"_blank",rel:"noopener noreferrer"},S={href:"https://twitter.com/alicegoldfuss/status/725534286351233024",target:"_blank",rel:"noopener noreferrer"},C={href:"https://sentry.io/welcome/",target:"_blank",rel:"noopener noreferrer"},N={href:"https://honeycomb.io/",target:"_blank",rel:"noopener noreferrer"},z={href:"https://docs.docker.com/engine/admin/logging/overview/#/json-file",target:"_blank",rel:"noopener noreferrer"},U={href:"https://docs.docker.com/engine/admin/logging/overview/#/supported-logging-drivers",target:"_blank",rel:"noopener noreferrer"},H={href:"http://docs.graylog.org/en/2.1/pages/gelf.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://graylog.org/",target:"_blank",rel:"noopener noreferrer"},W={href:"https://elastic.co/webinars/introduction-elk-stack",target:"_blank",rel:"noopener noreferrer"},B={href:"https://graylog.org/",target:"_blank",rel:"noopener noreferrer"},R={href:"https://elastic.co/products/logstash",target:"_blank",rel:"noopener noreferrer"},M={href:"https://fluentd.org/",target:"_blank",rel:"noopener noreferrer"},V={href:"https://docs.docker.com/engine/admin/logging/overview/#/options-3",target:"_blank",rel:"noopener noreferrer"},J={id:"i-would-tell-you-an-udp-joke-but",tabindex:"-1"},K={class:"header-anchor",href:"#i-would-tell-you-an-udp-joke-but"},Y={href:"http://imgur.com/gallery/kxBtzL3",target:"_blank",rel:"noopener noreferrer"},Z={href:"https://github.com/docker/docker/blob/a33105626870bfcbca97052b25b114e005a145ac/daemon/logger/gelf/gelf.go#L43",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://github.com/docker/docker/blob/a33105626870bfcbca97052b25b114e005a145ac/daemon/logger/gelf/gelf.go#L88",target:"_blank",rel:"noopener noreferrer"},$={href:"https://github.com/docker/docker/blob/a33105626870bfcbca97052b25b114e005a145ac/daemon/logger/gelf/gelf.go#L88",target:"_blank",rel:"noopener noreferrer"},X={href:"https://github.com/docker/docker/blob/a33105626870bfcbca97052b25b114e005a145ac/daemon/logger/gelf/gelf.go#L122",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/docker/docker/blob/a33105626870bfcbca97052b25b114e005a145ac/daemon/logger/gelf/gelf.go#L137",target:"_blank",rel:"noopener noreferrer"},ee={href:"https://github.com/Graylog2/go-gelf",target:"_blank",rel:"noopener noreferrer"},oe={href:"https://github.com/Graylog2/go-gelf/blob/f80b0a83dd6533b222823ef4f649fa3acb726cf3/gelf/writer.go#L102",target:"_blank",rel:"noopener noreferrer"},te={href:"https://github.com/Graylog2/go-gelf/blob/f80b0a83dd6533b222823ef4f649fa3acb726cf3/gelf/writer.go#L308",target:"_blank",rel:"noopener noreferrer"},ne={href:"https://github.com/Graylog2/go-gelf/blob/f80b0a83dd6533b222823ef4f649fa3acb726cf3/gelf/writer.go#L199",target:"_blank",rel:"noopener noreferrer"},re={href:"https://github.com/Graylog2/go-gelf/blob/f80b0a83dd6533b222823ef4f649fa3acb726cf3/gelf/writer.go#L125",target:"_blank",rel:"noopener noreferrer"},se={href:"https://redislabs.com/ebook/redis-in-action/part-2-core-concepts-2/chapter-5-using-redis-for-application-support/5-1-logging-to-redis",target:"_blank",rel:"noopener noreferrer"},ie={href:"https://kafka.apache.org/intro",target:"_blank",rel:"noopener noreferrer"},ae={href:"https://github.com/docker/docker/issues/23679",target:"_blank",rel:"noopener noreferrer"},le={href:"https://github.com/docker/docker/issues/17904",target:"_blank",rel:"noopener noreferrer"},de={href:"https://github.com/docker/docker/issues/16330",target:"_blank",rel:"noopener noreferrer"},ue={href:"https://twitter.com/berndahlers/status/822508266190237698",target:"_blank",rel:"noopener noreferrer"},pe={href:"https://github.com/docker/docker/issues/23679",target:"_blank",rel:"noopener noreferrer"},ge={href:"https://github.com/docker/docker/issues/17904",target:"_blank",rel:"noopener noreferrer"};function he(h,e){const d=l("VPCard"),i=l("router-link"),r=l("VPIcon"),f=l("SiteInfo"),m=l("RouteLink");return k(),b("div",null,[t("h1",v,[t("a",D,[t("span",null,y(h.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),n(d,p(g({title:"Docker > Article(s)",desc:"Article(s)",link:"/devops/docker/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",x,[t("ul",null,[t("li",null,[n(i,{to:"#some-context"},{default:s(()=>[...e[0]||(e[0]=[o("Some context",-1)])]),_:1})]),t("li",null,[n(i,{to:"#the-default-logging-driver-json-file"},{default:s(()=>[...e[1]||(e[1]=[o("The default logging driver: json-file",-1)])]),_:1})]),t("li",null,[n(i,{to:"#beyond-json-file"},{default:s(()=>[...e[2]||(e[2]=[o("Beyond json-file",-1)])]),_:1})]),t("li",null,[n(i,{to:"#gelf"},{default:s(()=>[...e[3]||(e[3]=[o("GELF",-1)])]),_:1})]),t("li",null,[n(i,{to:"#using-a-logging-driver"},{default:s(()=>[...e[4]||(e[4]=[o("Using a logging driver",-1)])]),_:1})]),t("li",null,[n(i,{to:"#i-would-tell-you-an-udp-joke-but"},{default:s(()=>[e[5]||(e[5]=o("I would tell you an UDP ",-1)),n(r,{icon:"fas fa-globe"}),e[6]||(e[6]=o("joke, but",-1))]),_:1})]),t("li",null,[n(i,{to:"#dns-to-the-rescue"},{default:s(()=>[...e[7]||(e[7]=[o("DNS to the rescue",-1)])]),_:1})]),t("li",null,[n(i,{to:"#hmmm-tcp-to-the-rescue-then"},{default:s(()=>[...e[8]||(e[8]=[o("Hmmm ‚Ä¶ TCP to the rescue, then?",-1)])]),_:1}),t("ul",null,[t("li",null,[n(i,{to:"#‚ïØ¬∞‚ñ°¬∞-‚ïØ-‚îª‚îÅ‚îª"},{default:s(()=>[...e[9]||(e[9]=[o("(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª",-1)])]),_:1})])])]),t("li",null,[n(i,{to:"#hot-potato"},{default:s(()=>[...e[10]||(e[10]=[o("Hot potato",-1)])]),_:1})]),t("li",null,[n(i,{to:"#workarounds"},{default:s(()=>[...e[11]||(e[11]=[o("Workarounds",-1)])]),_:1})]),t("li",null,[n(i,{to:"#future-directions"},{default:s(()=>[...e[12]||(e[12]=[o("Future directions",-1)])]),_:1})])])]),e[157]||(e[157]=t("hr",null,null,-1)),n(f,{name:"Adventures in GELFDocker",desc:"Learn from Docker experts to simplify and advance your app development and management with Docker. Stay up to date on Docker events and new version",url:"https://docker.com/blog/adventures-in-gelf",logo:"https://docker.com/app/uploads/2024/02/cropped-docker-logo-favicon-192x192.png",preview:"https://docker.com/app/uploads/2024/02/docker-default-meta-image-1110x583.png"}),e[158]||(e[158]=a('<p>If you are running apps in containers and are using Docker‚Äôs GELF logging driver (or are considering using it), the following musings might be relevant to your interests.</p><hr><h2 id="some-context" tabindex="-1"><a class="header-anchor" href="#some-context"><span>Some context</span></a></h2><p>When you run applications in containers, the easiest logging method is to write on standard output. You can‚Äôt get simpler than that: just <code>echo</code>, <code>print</code>, <code>write</code> (or the equivalent in your programming language!) and the container engine will capture your application‚Äôs output.</p><p>Other approaches are still possible, of course; for instance:</p>',5)),t("ul",null,[t("li",null,[e[16]||(e[16]=o("you can use syslog, by running a syslog daemon in your container or ",-1)),t("a",L,[n(r,{icon:"fas fa-globe"}),e[13]||(e[13]=o("exposing a ",-1)),e[14]||(e[14]=t("code",null,"/dev/log",-1)),e[15]||(e[15]=o(" socket",-1))]),e[17]||(e[17]=o(";",-1))]),t("li",null,[e[19]||(e[19]=o("you can write to regular files and ",-1)),n(m,{to:"/digitalocean.com/how-to-work-with-docker-data-volumes-on-ubuntu-14-04.html"},{default:s(()=>[...e[18]||(e[18]=[t("strong",null,"share these log files with your host, or with other containers, by placing them on a volume",-1)])]),_:1}),e[20]||(e[20]=o(";",-1))])]),u(" TODO: /digitalocean.com/how-to-work-with-docker-data-volumes-on-ubuntu-14-04.md "),e[159]||(e[159]=t("ul",null,[t("li",null,"your code can directly talk to the API of a logging service.")],-1)),e[160]||(e[160]=t("p",null,"In the last scenario, this service can be:",-1)),t("ul",null,[t("li",null,[e[23]||(e[23]=o("a proprietary logging mechanism operated by your cloud provider, e.g. ",-1)),t("a",I,[n(r,{icon:"fa-brands fa-aws"}),e[21]||(e[21]=o("AWS CloudWatch",-1))]),e[24]||(e[24]=o(" or ",-1)),t("a",T,[n(r,{icon:"iconfont icon-gcp"}),e[22]||(e[22]=o("Google Stackdriver",-1))]),e[25]||(e[25]=o(";",-1))]),t("li",null,[e[29]||(e[29]=o("provided by a third-party specialized in managing logs or events, e.g. ",-1)),t("a",E,[n(r,{icon:"fas fa-globe"}),e[26]||(e[26]=o("Honeycomb",-1))]),e[30]||(e[30]=o(", ",-1)),t("a",G,[n(r,{icon:"fas fa-globe"}),e[27]||(e[27]=o("Loggly",-1))]),e[31]||(e[31]=o(", ",-1)),t("a",P,[n(r,{icon:"iconfont icon-splunk"}),e[28]||(e[28]=o("Splunk",-1))]),e[32]||(e[32]=o(", etc.;",-1))]),e[33]||(e[33]=t("li",null,"something running in-house, that you deploy and maintain yourself.",-1))]),t("p",null,[e[43]||(e[43]=o("If your application is very terse, or if it serves very little traffic (because it has three users, including you and your dog), you can certainly run your logging service in-house. My ",-1)),t("a",q,[n(r,{icon:"fas fa-globe"}),e[34]||(e[34]=o("orchestration workshop",-1))]),e[44]||(e[44]=o(" even has a ",-1)),t("a",j,[n(r,{icon:"fas fa-globe"}),e[35]||(e[35]=o("chapter on logging",-1))]),e[45]||(e[45]=o(" which might give you the false idea that running your own ",-1)),t("a",F,[n(r,{icon:"fas fa-globe"}),e[36]||(e[36]=o("ELK",-1))]),e[46]||(e[46]=o(" cluster is all unicorns and rainbows, while the ",-1)),t("a",A,[e[37]||(e[37]=o("truth is very different (",-1)),n(r,{icon:"fa-brands fa-x-twitter"}),e[38]||(e[38]=t("code",null,"alicegoldfuss",-1)),e[39]||(e[39]=o(")",-1))]),e[47]||(e[47]=o(" and ",-1)),t("a",S,[e[40]||(e[40]=o("running reliable logging systems at scale is hard (",-1)),n(r,{icon:"fa-brands fa-x-twitter"}),e[41]||(e[41]=t("code",null,"alicegoldfuss",-1)),e[42]||(e[42]=o(")",-1))]),e[48]||(e[48]=o(".",-1))]),t("p",null,[e[51]||(e[51]=o("Therefore, you certainly want the possibility to send your logs to somebody else who will deal with the complexity (and pain) that comes with real-time storing, indexing, and querying of semi-structured data. It‚Äôs worth mentioning that these people can do more than just managing your logs. Some systems like ",-1)),t("a",C,[n(r,{icon:"fas fa-globe"}),e[49]||(e[49]=o("Sentry",-1))]),e[52]||(e[52]=o(" are particularly suited to extract insights from errors (think traceback dissection); and many modern tools like ",-1)),t("a",N,[n(r,{icon:"fas fa-globe"}),e[50]||(e[50]=o("Honeycomb",-1))]),e[53]||(e[53]=o(" will deal not only with logs but also any kind of event, letting you crossmatch everything together to find out the actual cause of that nasty 3am outage.",-1))]),e[161]||(e[161]=a('<p>But before getting there, you want to start with something easy to implement, and free (as much as possible).</p><p>That‚Äôs where container logging comes handy. Just write your logs on stdout, and let your container engine do all the work. At first, it will write plain boring files; but later, you can reconfigure it to do something smarter with your logs ‚Äî without changing your application code.</p><p>Note that the ideas and tools that I discuss here are orthogonal to the orchestration platform that you might or might not be using: Kubernetes, Mesos, Rancher, Swarm ‚Ä¶ They can all leverage the logging drivers of the Docker Engine, so I‚Äôve got you covered!</p><hr><h2 id="the-default-logging-driver-json-file" tabindex="-1"><a class="header-anchor" href="#the-default-logging-driver-json-file"><span>The default logging driver: <code>json-file</code></span></a></h2><p>By default, the Docker Engine will capture the standard output (and standard error) of all your containers, and write them in files using the JSON format (hence the name <code>json-file</code> for this default logging driver). The JSON format annotates each line with its origin (stdout or stderr) and its timestamp, and keeps each container log in a separate file.</p><p>When you use the <code>docker log</code> command (or the equivalent API endpoint), the Docker Engine reads from these files and shows you whatever was printed by your container. So far, so good.</p><p>The <code>json-file</code> driver, however, has (at least) two pain points:</p><ul><li>by default, the log files will grow without bounds, until you run out of disk space;</li><li>you cannot make complex queries such as ‚Äúshow me all the HTTP requests for virtual host <code>api.container.church</code> between 2am and 7am having a response time of more than 250ms but only if the HTTP status code was <code>200/OK</code>.‚Äù</li></ul>',9)),t("p",null,[e[55]||(e[55]=o("The first issue can easily be fixed by giving ",-1)),t("a",z,[n(r,{icon:"fa-brands fa-docker"}),e[54]||(e[54]=o("some extra parameters",-1))]),e[56]||(e[56]=o(" to the ",-1)),e[57]||(e[57]=t("code",null,"json-file",-1)),e[58]||(e[58]=o(" driver in Docker to enable log rotation. The second one, however, requires one of these fancy log services that I was alluding to.",-1))]),e[162]||(e[162]=a('<p>Even if your queries are not as complex, you will want to centralize your logs somehow, so that:</p><ul><li>logs are not lost forever when the cloud instance running your container disappears;</li><li>you can at least grep the logs of multiple containers without dumping them entirely through the Docker API or having to SSH around.</li></ul><p>Apart√©: when I was still carrying a pager and taking care of the dotCloud platform, our preferred log analysis technique was called ‚ÄúOps Map/Reduce‚Äù and involved fabric, parallel SSH connections, grep, and a few other knick-knacks. Before you laugh of our antiquated techniques, let me ask you how your team of 6 engineers dealt with the log files of 100000 containers 5 years ago and let‚Äôs compare our battle scars and PTSD-related therapy bills around a mug of tea, beer, or other suitable beverage. ‚ô•</p><hr><h2 id="beyond-json-file" tabindex="-1"><a class="header-anchor" href="#beyond-json-file"><span>Beyond <code>json-file</code></span></a></h2><p>Alright, you can start developing (and even deploying) with the default <code>json-file</code> driver, but at some point, you will need something else to cope with the amount of logs generated by your containers.</p><p>That‚Äôs where the logging drivers come handy: without changing a single line of code in your application, you can ask your faithful container engine to send the logs somewhere else. Neat.</p>',7)),t("p",null,[e[60]||(e[60]=o("Docker supports ",-1)),t("a",U,[n(r,{icon:"fa-brands fa-docker"}),e[59]||(e[59]=o("many other logging drivers",-1))]),e[61]||(e[61]=o(", including but not limited to:",-1))]),e[163]||(e[163]=a('<ul><li><code>awslogs</code>, if you‚Äôre running on Amazon‚Äôs cloud and don‚Äôt plan to migrate to anything else, ever;</li><li><code>gcplogs</code>, if you‚Äôre more a Google person;</li><li><code>syslog</code>, if you already have a centralized syslog server and want to leverage it for your containers;</li><li><code>gelf</code></li></ul><p>I‚Äôm going to stop the list here because GELF has a few features that make it particulary interesting and versatile.</p><hr><h2 id="gelf" tabindex="-1"><a class="header-anchor" href="#gelf"><span>GELF</span></a></h2>',4)),t("p",null,[e[65]||(e[65]=o("GELF stands for ",-1)),t("a",H,[n(r,{icon:"fas fa-globe"}),e[62]||(e[62]=o("Graylog Extended Log Format",-1))]),e[66]||(e[66]=o(". It was initially designed for the ",-1)),t("a",O,[n(r,{icon:"fas fa-globe"}),e[63]||(e[63]=o("Graylog",-1))]),e[67]||(e[67]=o(" logging system. If you haven‚Äôt heard about Graylog before, it‚Äôs an open source project that pioneered ‚Äúmodern‚Äù logging systems like ",-1)),t("a",W,[n(r,{icon:"fas fa-globe"}),e[64]||(e[64]=o("ELK",-1))]),e[68]||(e[68]=o(". In fact, if you want to send Docker logs to your ELK cluster, you will probably use the GELF protocol! It is an open standard implemented by many logging systems (open or proprietary).",-1))]),e[164]||(e[164]=a(`<p>What‚Äôs so nice about the GELF protocol? It addresses some (if not most) of the shortcomings of the syslog protocol.</p><p>With the syslog protocol, a log message is mostly a raw string, with very little metadata. There is some kind of agreement between syslog emitters and receivers; a valid syslog message should be formatted in a specific way, allowing to extract the following information:</p><ul><li>a priority: is this a debug message, a warning, something purely informational, a critical error, etc.;</li><li>a timestamp indicating when the thing happened;</li><li>a hostname indicating where the thing happened (i.e. on which machine);</li><li>a facility indicating if the message comes from the mail system, the kernel, and such and such;</li><li>a process name and number;</li><li>etc.</li></ul><p>That protocol was great in the 80s (and even the 90s), but it has some shortcomings:</p><ul><li>as it evolved over time, there are almost 10 different RFCs to specify, extend, and retrofit it to various use-cases;</li><li>the message size is limited, meaning that very long messages (e.g.: tracebacks) have to be truncated or split across messages;</li><li>at the end of the day, even if some metadata can be extracted, the payload is a plain, unadorned text string.</li></ul><p>GELF made a very risqu√© move and decided that every log message would be a dict (or a map or a hash or whatever you want to call them). This ‚Äúdict‚Äù would have the following fields:</p><ul><li>version;</li><li>host (who sent the message in the first place);</li><li>timestamp;</li><li>short and long version of the message;</li><li>any extra field you would like!</li></ul><p>At first you might think, ‚ÄúOK, what‚Äôs the deal?‚Äù but this means that when a web servers logs a request, instead of having a raw string like this:</p><div class="language-plaintext line-numbers-mode" data-highlighter="prismjs" data-ext="plaintext"><pre><code class="language-plaintext"><span class="line">127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] &quot;GET /apache_pb.gif HTTP/1.0&quot; 200 2326</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>You get a dict like that:</p><div class="language-json line-numbers-mode" data-highlighter="prismjs" data-ext="json"><pre><code class="language-json"><span class="line"><span class="token punctuation">{</span></span>
<span class="line">  <span class="token property">&quot;client&quot;</span><span class="token operator">:</span> <span class="token string">&quot;127.0.0.1&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;user&quot;</span><span class="token operator">:</span> <span class="token string">&quot;frank&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;timestamp&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2000-10-10 13:55:36 -0700&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;method&quot;</span><span class="token operator">:</span> <span class="token string">&quot;GET&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;uri&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/apache_pb.gif&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;protocol&quot;</span><span class="token operator">:</span> <span class="token string">&quot;HTTP/1.0&quot;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;status&quot;</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token property">&quot;size&quot;</span><span class="token operator">:</span> <span class="token number">2326</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This also means that the logs get stored as structured objects, instead of raw strings. As a result, you can make elaboarate queries (something close to SQL) instead of carving regexes with grep like a caveperson.</p>`,12)),t("p",null,[e[72]||(e[72]=o("OK, so GELF is a convenient format that Docker can emit, and that is understood by a number of tools like ",-1)),t("a",B,[n(r,{icon:"fas fa-globe"}),e[69]||(e[69]=o("Graylog",-1))]),e[73]||(e[73]=o(", ",-1)),t("a",R,[n(r,{icon:"fas fa-globe"}),e[70]||(e[70]=o("Logstash",-1))]),e[74]||(e[74]=o(", ",-1)),t("a",M,[n(r,{icon:"fas fa-globe"}),e[71]||(e[71]=o("Fluentd",-1))]),e[75]||(e[75]=o(", and many more.",-1))]),e[165]||(e[165]=a('<p>Moreover, you can switch from the default <code>json-file</code> to GELF very easily; which means that you can start with <code>json-file</code> (i.e. not setup anything in your Docker cluster), and later, when you decide that these log entries could be useful after all, switch to GELF without changing anything in your application, and automatically have your logs centralized and indexed somewhere.</p><hr><h2 id="using-a-logging-driver" tabindex="-1"><a class="header-anchor" href="#using-a-logging-driver"><span>Using a logging driver</span></a></h2><p>How do we switch to GELF (or any other format)?</p><p>Docker provides two command-line flags for that:</p><ul><li><code>--log-driver</code> to indicate which driver to use;</li><li><code>--log-opt</code> to pass arbitrary options to the driver.</li></ul><p>These options can be passed to <code>docker run</code>, indicating that you want this one specific container to use a different logging mechanism; or to the Docker Engine itself (when starting it) so that it becomes the default option for all containers.</p><p>(If you are using the Docker API to start your containers, these options are passed to the <code>create</code> call, within the <code>HostConfig.LogConfig</code> structure.)</p>',8)),t("p",null,[e[77]||(e[77]=o("The ‚Äúarbitrary options‚Äù vary for each driver. In the case of the GELF driver, you can specify ",-1)),t("a",V,[n(r,{icon:"fa-brands fa-docker"}),e[76]||(e[76]=o("a bunch of options",-1))]),e[78]||(e[78]=o(" but there is one that is mandatory: the address of the GELF receiver.",-1))]),e[166]||(e[166]=a(`<p>If we have a GELF receiver on the machine 1.2.3.4 on the default UDP port 12201, you can start your container as follows:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line"><span class="token function">docker</span> run <span class="token punctuation">\\</span></span>
<span class="line">-log-driver gelf -log-opt gelf-address<span class="token operator">=</span>udp://1.2.3.4:12201 <span class="token punctuation">\\</span></span>
<span class="line">alpine <span class="token builtin class-name">echo</span> hello world</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The following things will happen:</p><ul><li>the Docker Engine will pull the <code>alpine</code> image (if necessary)</li><li>the Docker Engine will create and start our container</li><li>the container will execute the command <code>echo</code> with arguments <code>hello world</code></li><li>the process in the container will write <code>hello world</code> to the standard output</li><li>the <code>hello world</code> message will be passed to whomever is watching (i.e. you, since you started the container in the foreground)</li><li>the <code>hello world</code> message will also be caught by Docker and sent to the logging driver</li><li>the <code>gelf</code> logging driver will prepare a full GELF message, including the host name, the timestamp, the string <code>hello world</code>, but also a bunch of informations about the container, including its full ID, name, image name and ID, environment variables, and much more;</li><li>this GELF message will be sent through UDP to 1.2.3.4 on port 12201. Then, hopefully 1.2.3.4 receives the UDP packet, proecesses it, writes the message to some persistent indexed store, and allows you to retrieve or query it.</li></ul><p>Hopefully.</p><hr>`,6)),t("h2",J,[t("a",K,[t("span",null,[e[80]||(e[80]=o("I would tell you an UDP ",-1)),t("a",Y,[n(r,{icon:"fas fa-globe"}),e[79]||(e[79]=o("joke",-1))]),e[81]||(e[81]=o(", but",-1))])])]),e[167]||(e[167]=a('<p>If you have ever been on-call or responsible for other people‚Äôs code, you are probably cringing by now. Our precious logging message is within a UDP packet that might or might not arrive to our logging server (UDP has no transmission guarantees). If our logging server goes away (a nice wording for ‚Äúcrashes horribly‚Äù), our packet might arrive, but our message will be obliviously ignored, and we won‚Äôt know anything about it. (Technically, we might get an ICMP message telling us that the host or port is unreachable, but at that point, it will be too late, because we won‚Äôt even know which message this is about!)</p><p>Perhaps we can live with a few dropped messages (or a bunch, if the logging server is being rebooted, for instance). But what if we live in the Cloud, and our server evaporates? Seriously, though: what if I‚Äôm sending my log messages to an EC2 instance, and for some reason that instance has to be replaced with another one? The new instance will have a different IP address, but my log messages will continue to stubbornly go to the old address.</p><hr><h2 id="dns-to-the-rescue" tabindex="-1"><a class="header-anchor" href="#dns-to-the-rescue"><span>DNS to the rescue</span></a></h2><p>An easy technique to work around volatile IP addresses is tu use DNS. Instead of specifying <code>1.2.3.4</code> as our GELF target, we will use <code>gelf.container.church</code>, and make sure that this points to 1.2.3.4. That way, whenever we need to send messages to a different machine, we just update the DNS record, and our Docker Engine happily sends the messages to the new machine.</p><p>Or does it?</p><p>If you have to write some code sending data to a remote machine (say, gelf.container.church on port 12345), the simplest version will look like this:</p><ol><li>Resolve <code>gelf.container.church</code> to an IP address (A.B.C.D).</li><li>Create a socket.</li><li>Connect this socket to A.B.C.D, on port 12345.</li><li>Send data on the socket.</li></ol><p>If you must send data multiple times, you will keep the socket open, both for convenience and efficiency purposes. This is particularly important with TCP sockets, because before sending your data, you have to go through the ‚Äú3-way handshake‚Äù to establish the TCP connection; in other words, the 3rd step in our list above is very expensive (compared to the cost of sending a small packet of data).</p><p>In the case of UDP sockets, you might be tempted to think: ‚ÄúAh, since I don‚Äôt need to do the 3-way handshake before sending data (the 3rd step in our list above is essentially free), I can go through all 4 steps each time I need to send a message!‚Äù But in fact, if you do that, you will quickly realize that you are now stumped by the first step, the DNS resolution. DNS resolution is less expensive than a TCP 3-way handshake, but barely: it still requires a round-trip to your DNS resolver.</p><p>Apart√©: yes, it is possible to have very efficient local DNS resolvers. Something like pdns-recursor or dnsmasq running on <code>localhost</code> will get you some craaazy fast DNS response time for cached queries. However, if you need to make a DNS request each time you need to send a log message, it will add an indirect, but significant, cost to your application, since every log line will generate not only one syscall, but three. Damned! And some people (like, almost everyone running on EC2) are using their cloud provider‚Äôs DNS service. These people will incur two extra network packets for each log line. And when the cloud provider‚Äôs DNS is down, logging will be broken. Not cool.</p><p>Conclusion: if you log over UDP, you don‚Äôt want to resolve the logging server address each time you send a message.</p><hr><h2 id="hmmm-tcp-to-the-rescue-then" tabindex="-1"><a class="header-anchor" href="#hmmm-tcp-to-the-rescue-then"><span>Hmmm ‚Ä¶ TCP to the rescue, then?</span></a></h2><p>It would make sense to use a TCP connection, and keep it up as long as we need it. If anything horrible happens to the logging server, we can trust the TCP state machine to detect it eventually (because timeouts and whatnots) and notify us. When that happens, we can then re-resolve the server name and re-connect. We just need a little bit of extra logic in the container engine, to deal with the unfortunate scenario where the <code>write</code> on the socket gives us an <code>EPIPE</code> error, also known as ‚ÄúBroken pipe‚Äù or in plain english ‚Äúthe other end is not paying attention to us anymore.‚Äù</p><p>Let‚Äôs talk to our GELF server using TCP, and the problem will be solved, right?</p><p>Right?</p><p>Unfortunately, the GELF logging driver in Docker only supports UDP.</p><h3 id="‚ïØ¬∞‚ñ°¬∞-‚ïØ-‚îª‚îÅ‚îª" tabindex="-1"><a class="header-anchor" href="#‚ïØ¬∞‚ñ°¬∞-‚ïØ-‚îª‚îÅ‚îª"><span>(‚ïØ¬∞‚ñ°¬∞)‚ïØÔ∏µ ‚îª‚îÅ‚îª</span></a></h3><p>At this point, if you‚Äôre still with us, you might have concluded that computing is just a specialized kind of hell, that containers are the antichrist, and Docker is the harbinger of doom in disguise.</p><p>Before drawing hasty conclusions, let‚Äôs have a look at the code.</p>',21)),t("p",null,[e[91]||(e[91]=o("When you create a container using the GELF driver, ",-1)),t("a",Z,[e[82]||(e[82]=o("this function (",-1)),n(r,{icon:"iconfont icon-github"}),e[83]||(e[83]=t("code",null,"docker/docker",-1)),e[84]||(e[84]=o(")",-1))]),e[92]||(e[92]=o(" is invoked, and it creates a new ",-1)),e[93]||(e[93]=t("code",null,"gelfWriter",-1)),e[94]||(e[94]=o(" object by ",-1)),t("a",Q,[e[85]||(e[85]=o("calling (",-1)),n(r,{icon:"iconfont icon-github"}),e[86]||(e[86]=t("code",null,"docker/docker",-1)),e[87]||(e[87]=o(")",-1))]),e[95]||(e[95]=o()),t("a",$,[e[88]||(e[88]=o("gelf.NewWriter (",-1)),n(r,{icon:"iconfont icon-github"}),e[89]||(e[89]=t("code",null,"docker/docker",-1)),e[90]||(e[90]=o(")",-1))]),e[96]||(e[96]=o(".",-1))]),t("p",null,[e[103]||(e[103]=o("Then, when the container prints something out, eventually, ",-1)),t("a",X,[e[97]||(e[97]=o("the Log function (",-1)),n(r,{icon:"iconfont icon-github"}),e[98]||(e[98]=t("code",null,"docker/docker",-1)),e[99]||(e[99]=o(")",-1))]),e[104]||(e[104]=o(" of the GELF driver is invoked. It essentially ",-1)),t("a",_,[e[100]||(e[100]=o("writes the message to the gelfWriter (",-1)),n(r,{icon:"iconfont icon-github"}),e[101]||(e[101]=t("code",null,"docker/docker",-1)),e[102]||(e[102]=o(")",-1))]),e[105]||(e[105]=o(".",-1))]),t("p",null,[e[107]||(e[107]=o("This GELF writer object is implemented by an external dependency, ",-1)),t("a",ee,[n(r,{icon:"iconfont icon-github"}),e[106]||(e[106]=t("code",null,"Graylog2/go-gelf",-1))]),e[108]||(e[108]=o(".",-1))]),e[168]||(e[168]=t("p",null,"Look, I see it coming, he‚Äôs going to do some nasty fingerpointing and put the blame on someone else‚Äôs code. Despicable!",-1)),e[169]||(e[169]=t("hr",null,null,-1)),e[170]||(e[170]=t("h2",{id:"hot-potato",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#hot-potato"},[t("span",null,"Hot potato")])],-1)),t("p",null,[e[121]||(e[121]=o("Let‚Äôs investigate this package, in particular the ",-1)),t("a",oe,[e[109]||(e[109]=o("NewWriter function (",-1)),n(r,{icon:"iconfont icon-github"}),e[110]||(e[110]=t("code",null,"Graylog2/go-gelf",-1)),e[111]||(e[111]=o(")",-1))]),e[122]||(e[122]=o(", the ",-1)),t("a",te,[e[112]||(e[112]=o("Write method (",-1)),n(r,{icon:"iconfont icon-github"}),e[113]||(e[113]=t("code",null,"Graylog2/go-gelf",-1)),e[114]||(e[114]=o(")",-1))]),e[123]||(e[123]=o(", and the other methods called by the latter, ",-1)),t("a",ne,[e[115]||(e[115]=o("WriteMessage (",-1)),n(r,{icon:"iconfont icon-github"}),e[116]||(e[116]=t("code",null,"Graylog2/go-gelf",-1)),e[117]||(e[117]=o(")",-1))]),e[124]||(e[124]=o(" and ",-1)),t("a",re,[e[118]||(e[118]=o("writeChunked (",-1)),n(r,{icon:"iconfont icon-github"}),e[119]||(e[119]=t("code",null,"Graylog2/go-gelf",-1)),e[120]||(e[120]=o(")",-1))]),e[125]||(e[125]=o(". Even if you aren‚Äôt very familiar with Go, you will see that these functions do not implement any kind of reconnection logic. If anything bad happens, the error bubbles up to the caller, and that‚Äôs it.",-1))]),e[171]||(e[171]=a(`<p>If we conduct the same investigation with the code on the Docker side (with the links in the previous section), we reach the same conclusions. If an error occurs while sending a log message, the error is passed to the layer above. There is no reconnection attempt, neither in Docker‚Äôs code, nor in go-gelf‚Äôs.</p><p>This, by the way, explains why Docker only supports the UDP transport. If you want to support TCP, you have to support more error conditions than UDP. To phrase things differently: TCP support would be more complicated and more lines of code.</p><div class="hint-container note"><p class="hint-container-title">Haters gonna hate</p><p>One possible reaction is to get angry at the brave soul who implemented go-gelf, or the one who implemented the GELF driver in Docker. Another better reaction is to be thankful that they wrote that code, rather than no code at all!</p></div><hr><h2 id="workarounds" tabindex="-1"><a class="header-anchor" href="#workarounds"><span>Workarounds</span></a></h2><p>Let‚Äôs see how to solve our logging problem.</p><p>The easiest solution is to restart our containers whenever we need to ‚Äúreconnect‚Äù (technically, resolve and reconnect). It works, but it is very annoying.</p><p>A slightly better solution is to send logs to <code>127.0.0.1:12201</code>, and then run a packet redirector to ‚Äúbounce‚Äù or ‚Äúmirror‚Äù these packets to the actual logger; e.g.:</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">socat UDP-LISTEN:12201 UDP:gelf.container.church:12201</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>This needs to run on each container host. It is very lightweight, and whenever <code>gelf.container.church</code> is updated, instead of restarting your containers, you merely restart <code>socat</code>.</p><p>(You could also send your log packets to a virtual IP, and then use some fancy <code>iptables -t nat ... -j DNAT</code> rules to rewrite the destination address of the packets going to this virtual IP.)</p><p>Another option is to run Logstash on each node (instead of just <code>socat</code>). It might seem overkill at first, but it will give you a lot of extra flexibility with your logs: you can do some local parsing, filtering, and even ‚Äúforking,‚Äù i.e. deciding to send your logs to multiple places at the same time. This is particularly convenient if you are switching from one logging system to another, because it will let you feed both systems in parallel for a while (during a transition period).</p>`,12)),t("p",null,[e[128]||(e[128]=o("Running Logstash (or another logging tool) on each node is also very useful if you want to be sure that you don‚Äôt lose any log message, because it would be the perfect place to insert a queue (using ",-1)),t("a",se,[n(r,{icon:"iconfont icon-redis"}),e[126]||(e[126]=o("Redis",-1))]),e[129]||(e[129]=o(" for simple scenarios, or ",-1)),t("a",ie,[n(r,{icon:"iconfont icon-kafka"}),e[127]||(e[127]=o("Kafka",-1))]),e[130]||(e[130]=o(" if you have stricter requirements).",-1))]),e[172]||(e[172]=a('<p>Even if you end up sending your logs to a service using a different protocol, the GELF driver is probably the easiest one to setup to connect Docker to e.g. Logstash or Fluentd, and then have Logstash or Fluentd speak to the logging service with the other protocol.</p><p>UDP packets sent to <code>localhost</code> can‚Äôt be lost, except if the UDP socket runs out of buffer space. This could happen if your sender (Docker) is faster than your receiver (Logstash/Fluentd), which is why we mentioned a queue earlier: the queue will allow the receiver to drain the UDP buffer as fast as possible to avoid overflows. Combine that with a large enough UDP buffer, and you‚Äôll be safe.</p><hr><h2 id="future-directions" tabindex="-1"><a class="header-anchor" href="#future-directions"><span>Future directions</span></a></h2><p>Even if running a cluster-wide <code>socat</code> is relatively easy (especially with Swarm mode and <code>docker service create --mode global</code>), we would rather have a good behavior out of the box.</p>',5)),t("p",null,[e[143]||(e[143]=o("There are already some GitHub issues related to this: ",-1)),t("a",ae,[e[131]||(e[131]=o("#23679 (",-1)),n(r,{icon:"iconfont icon-github"}),e[132]||(e[132]=t("code",null,"docker/docker",-1)),e[133]||(e[133]=o(")",-1))]),e[144]||(e[144]=o(", ",-1)),t("a",le,[e[134]||(e[134]=o("#17904 (",-1)),n(r,{icon:"iconfont icon-github"}),e[135]||(e[135]=t("code",null,"docker/docker",-1)),e[136]||(e[136]=o(")",-1))]),e[145]||(e[145]=o(", and ",-1)),t("a",de,[e[137]||(e[137]=o("#16330 (",-1)),n(r,{icon:"iconfont icon-github"}),e[138]||(e[138]=t("code",null,"docker/docker",-1)),e[139]||(e[139]=o(")",-1))]),e[146]||(e[146]=o(". One of the maintainers ",-1)),t("a",ue,[e[140]||(e[140]=o("has joined the conversation (",-1)),n(r,{icon:"fa-brands fa-x-twitter"}),e[141]||(e[141]=t("code",null,"berndahlers",-1)),e[142]||(e[142]=o(")",-1))]),e[147]||(e[147]=o(" and there are some people at Docker Inc. who would love to see this improved.",-1))]),e[173]||(e[173]=t("p",null,"One possible fix is to re-resolve the GELF server name once in a while, and when a change is detected, update the socket destination address. Since DNS provides TTL information, it could even be used to know how long the IP address can be cached.",-1)),e[174]||(e[174]=t("p",null,"If you need better GELF support, I have good news: you can help! I‚Äôm not going to tell you ‚Äújust send us a pull request, ha ha ha!‚Äù because I know that only a very small number of people have both the time and expertise to do that ‚Äî but if you are one of them, then by all means, do it! There are other ways to help, though.",-1)),t("p",null,[e[154]||(e[154]=o("First, you can monitor the GitHub issues mentioned above (",-1)),t("a",pe,[e[148]||(e[148]=o("#23679 (",-1)),n(r,{icon:"iconfont icon-github"}),e[149]||(e[149]=t("code",null,"docker/docker",-1)),e[150]||(e[150]=o(")",-1))]),e[155]||(e[155]=o(" and ",-1)),t("a",ge,[e[151]||(e[151]=o("#17904 (",-1)),n(r,{icon:"iconfont icon-github"}),e[152]||(e[152]=t("code",null,"docker/docker",-1)),e[153]||(e[153]=o(")",-1))]),e[156]||(e[156]=o("). If the contributors and maintainers ask for feedback, indicate what would (or wouldn‚Äôt) work for you. If you see a proposition that makes sense, and you just want to say ‚Äú+1‚Äù you can do it with GitHub reactions (the ‚Äúthumbs up‚Äù emoji works perfectly for that). And if somebody proposes a pull request, testing it will be extremely helpful and instrmental to get it accepted.",-1))]),e[175]||(e[175]=t("p",null,"If you look at one of these GitHub issues, you will see that there was already a patch proposed a long time ago; but the person who asked for the feature in the first place never tested it, and as a result, it was never merged. Don‚Äôt get me wrong, I‚Äôm not putting the blame on that person! It‚Äôs a good start to have a GitHub issue as a kind of ‚Äúmeeting point‚Äù for people needing a feature, and people who can implement it.",-1)),e[176]||(e[176]=t("p",null,"It‚Äôs quite likely that in a few months, half of this post will be obsolete because the GELF driver will support TCP connections and/or correctly re-resolve addresses for UDP addresses!",-1)),u(" TODO: add ARTICLE CARD "),n(d,p(g({title:"Adventures in GELFDocker",desc:"Learn from Docker experts to simplify and advance your app development and management with Docker. Stay up to date on Docker events and new version",link:"https://chanhi2000.github.io/bookshelf/docker.com/adventures-in-gelf.html",logo:"https://docker.com/app/uploads/2024/02/cropped-docker-logo-favicon-192x192.png",background:"rgba(29,99,237,0.2)"})),null,16)])}const ce=c(w,[["render",he]]),be=JSON.parse('{"path":"/docker.com/adventures-in-gelf.html","title":"Adventures in GELF","lang":"en-US","frontmatter":{"lang":"en-US","title":"Adventures in GELF","description":"Article(s) > Adventures in GELF","icon":"fa-brands fa-docker","category":["DevOps","Docker","Article(s)"],"tag":["blog","docker.com","devops","docker"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Adventures in GELF\\",\\"image\\":[\\"https://docker.com/app/uploads/2024/02/docker-default-meta-image-1110x583.png\\"],\\"datePublished\\":\\"2017-02-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"J√©r√¥me Petazzoni\\",\\"url\\":\\"https://docker.com/author/jerome/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/docker.com/adventures-in-gelf.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Adventures in GELF"}],["meta",{"property":"og:description","content":"Article(s) > Adventures in GELF"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://docker.com/app/uploads/2024/02/docker-default-meta-image-1110x583.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://docker.com/app/uploads/2024/02/docker-default-meta-image-1110x583.png"}],["meta",{"name":"twitter:image:alt","content":"Adventures in GELF"}],["meta",{"property":"article:author","content":"J√©r√¥me Petazzoni"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:tag","content":"devops"}],["meta",{"property":"article:tag","content":"docker.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2017-02-08T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Adventures in GELF"},{"property":"og:description","content":"Adventures in GELF"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/docker.com/adventures-in-gelf.html"}]],"prev":"/devops/docker/articles/README.md","date":"2017-02-08T00:00:00.000Z","isOriginal":false,"author":[{"name":"J√©r√¥me Petazzoni","url":"https://docker.com/author/jerome/"}],"cover":"https://docker.com/app/uploads/2024/02/docker-default-meta-image-1110x583.png"},"git":{},"readingTime":{"minutes":14.55,"words":4365},"filePathRelative":"docker.com/adventures-in-gelf.md","copyright":{"author":"J√©r√¥me Petazzoni"}}');export{ce as comp,be as data};
