import{_ as u}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as f,d as t,f as r,b,a as v,t as y,n as m,g,w as a,e as o,r as i,o as w}from"./app-BItykJLQ.js";const I={},S={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},k={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},O={class:"table-of-contents"},M={href:"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API",target:"_blank",rel:"noopener noreferrer"},z={href:"https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver",target:"_blank",rel:"noopener noreferrer"},T={href:"https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver#rootmargin",target:"_blank",rel:"noopener noreferrer"},x={href:"https://chromestatus.com/feature/5091020593430528",target:"_blank",rel:"noopener noreferrer"},P={href:"https://w3c.github.io/IntersectionObserver/#dom-intersectionobserver-scrollmargin",target:"_blank",rel:"noopener noreferrer"},L={href:"https://bugs.webkit.org/show_bug.cgi?id=264864",target:"_blank",rel:"noopener noreferrer"},A={href:"https://wpt.fyi/interop-2024",target:"_blank",rel:"noopener noreferrer"};function W(l,e){const d=i("VPCard"),s=i("router-link"),h=i("SiteInfo"),n=i("VPIcon"),c=i("CodePen"),p=i("VidStack");return w(),f("div",null,[t("h1",S,[t("a",k,[t("span",null,y(l.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),r(d,m(g({title:"JavaScript > Article(s)",desc:"Article(s)",link:"/programming/js/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",O,[t("ul",null,[t("li",null,[r(s,{to:"#the-problem-with-intersection-observer-s-rootmargin"},{default:a(()=>[...e[0]||(e[0]=[o("The Problem with Intersection Observer‚Äôs rootMargin",-1)])]),_:1})]),t("li",null,[r(s,{to:"#scrollmargin-is-the-new-solution"},{default:a(()=>[...e[1]||(e[1]=[o("scrollMargin is the New Solution",-1)])]),_:1})]),t("li",null,[r(s,{to:"#a-typical-use-case"},{default:a(()=>[...e[2]||(e[2]=[o("A Typical Use Case",-1)])]),_:1})]),t("li",null,[r(s,{to:"#video-examples"},{default:a(()=>[...e[3]||(e[3]=[o("Video Examples",-1)])]),_:1})]),t("li",null,[r(s,{to:"#browser-support"},{default:a(()=>[...e[4]||(e[4]=[o("Browser Support",-1)])]),_:1})])])]),e[36]||(e[36]=t("hr",null,null,-1)),r(h,{name:"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin",desc:"This helps load in data just *before* a user gets to it, and it works with non-root containers and horizontal scrolling.",url:"https://frontendmasters.com/blog/simplify-lazy-loading-with-intersection-observers-scrollmargin/",logo:"https://frontendmasters.com/favicon.ico",preview:"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/4990"}),t("p",null,[e[7]||(e[7]=o("The ",-1)),t("a",M,[r(n,{icon:"fa-brands fa-firefox"}),e[5]||(e[5]=o("Intersection Observer API",-1))]),e[8]||(e[8]=o(" has since December 2023 in Chrome and Edge 120 been shipped with the new ",-1)),e[9]||(e[9]=t("code",null,"options",-1)),e[10]||(e[10]=o(" property ",-1)),e[11]||(e[11]=t("code",null,"scrollMargin",-1)),e[12]||(e[12]=o(". However, ",-1)),e[13]||(e[13]=t("strong",null,"its convenience seems to be understated.",-1)),e[14]||(e[14]=o(" Even the ",-1)),t("a",z,[r(n,{icon:"fa-brands fa-firefox"}),e[6]||(e[6]=o("MDN documentation on the Intersection Observer constructor",-1))]),e[15]||(e[15]=o(" has yet to be updated with information about this property. It is definitely an upgrade to the Intersection Observer API, so I want to tell you more about it, particularly because it has already helped with with projects at work.",-1))]),e[37]||(e[37]=t("hr",null,null,-1)),e[38]||(e[38]=t("h2",{id:"the-problem-with-intersection-observer-s-rootmargin",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#the-problem-with-intersection-observer-s-rootmargin"},[t("span",null,[o("The Problem with Intersection Observer‚Äôs "),t("code",null,"rootMargin")])])],-1)),t("p",null,[e[19]||(e[19]=o("The Intersection Observer API is a JavaScript API that makes it possible to know whether a DOM element is in the viewport or not. An intersection observers constructor takes an options object, in which a ",-1)),e[20]||(e[20]=t("code",null,"rootMargin",-1)),e[21]||(e[21]=o(" can be specified. Its value is ",-1)),t("em",null,[e[17]||(e[17]=o("‚Äúa string which specifies a set of offsets to add to the root‚Äôs bounding box when calculating intersections, effectively shrinking or growing the root [‚Ä¶] The syntax is approximately the same as that for the CSS margin property‚Äù (",-1)),t("a",T,[r(n,{icon:"fa-brands fa-firefox"}),e[16]||(e[16]=o("MDN",-1))]),e[18]||(e[18]=o(").",-1))])]),e[39]||(e[39]=b('<p>To give you an example: if you want some code to run <em>before</em> the element is actually in view, <code>rootMargin: &quot;25%&quot;</code> will make the Intersection Observer report an intersection when the observed element is 25% away from the viewport.</p><p>However, <strong>a problem arises</strong> if the Intersection Observer:</p><ol><li>uses the default root (the document‚Äôs viewport)</li><li>is specified with a <code>rootMargin</code></li><li>observes an element inside a scroll container</li></ol><p>In that case, the intersection in the scroll direction is reported <strong>as if no <code>rootMargin</code> has been specified.</strong> This makes it impossible to get an intersection <em>before</em> the element in a scroll container is actually visible, which is a problem when trying to lazy load thing <em>just <strong>before</strong></em> they are visible.</p><p>The workaround is to use the scroll container as the root instead of Intersection Observer‚Äôs default root. But it would be convenient if it was possible to keep using the default root!</p><hr><h2 id="scrollmargin-is-the-new-solution" tabindex="-1"><a class="header-anchor" href="#scrollmargin-is-the-new-solution"><span><code>scrollMargin</code> is the New Solution</span></a></h2><p>The new Intersection Observer options property <code>scrollMargin</code> aims to rectify this. Without it, when the root is the document viewport, the scroll containers are clipped away. This is the cause of the aforementioned problem. With the new Intersection Observer property, each scroll container is expanded by the <code>scrollMargin</code> when calculating the intersection.</p><hr><h2 id="a-typical-use-case" tabindex="-1"><a class="header-anchor" href="#a-typical-use-case"><span>A Typical Use Case</span></a></h2><p>The use case for the <code>scrollMargin</code> property is using it as an indicator to request data when it is <em>about</em> to be scrolled into view. That‚Äôs called lazy loading, the point of which is to <em>not</em> load data that is so far off screen it‚Äôs possible the user never scrolls to see it.</p><p>The following Pen lazy loads data <em>both</em> in the vertical and horizontal directions. The UI/UX is like a streaming service, which is exactly where my use case and thus learning of this feature comes from. Similar use cases are scrolling carousels for eCommerce, news, images, etc.</p>',12)),r(c,{user:"ingvild","slug-hash":"zxOPWMZ",title:"no_scroll_margin_streaming","default-tab":["css","result"],theme:l.dark},null,8,["theme"]),e[40]||(e[40]=t("hr",null,null,-1)),e[41]||(e[41]=t("h2",{id:"video-examples",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#video-examples"},[t("span",null,"Video Examples")])],-1)),e[42]||(e[42]=t("p",null,[o("This is what lazy loading looks like "),t("em",null,"without"),o(),t("code",null,"scrollMargin"),o(" in place. Notice how you can see the element before the data is ready, and there is a noticable loading delay.")],-1)),r(p,{src:"https://videos.files.wordpress.com/8Da5aNMP/no-scrollmargin_mp4_hd_1080p.mp4"}),e[43]||(e[43]=t("p",null,[o("Here‚Äôs a video example of when we have "),t("code",null,"scrollMargin"),o(" in place in a supporting browser. Notice that the data is loaded ahead of time and it‚Äôs ready to go when the user gets there.")],-1)),r(p,{src:"https://videos.files.wordpress.com/OaPINqKl/with-scrollmargin_mp4_hd.mp4"}),e[44]||(e[44]=t("p",null,[o("In the video above it looks like we‚Äôre just horizontally scrolling some elements that are already loaded, but rest assured, they are being loaded "),t("em",null,"just in time"),o(" and are still properly lazy loading.")],-1)),e[45]||(e[45]=t("hr",null,null,-1)),e[46]||(e[46]=t("h2",{id:"browser-support",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#browser-support"},[t("span",null,"Browser Support")])],-1)),t("p",null,[e[25]||(e[25]=o("At the time of writing (January 2025), only Chrome and Edge since version 120 support this new property. The status of the feature can be followed on the ",-1)),t("a",x,[r(n,{icon:"fa-brands fa-chrome"}),e[22]||(e[22]=o("Chrome Platform Status Feature: Intersection Observer Scroll Margin page",-1))]),e[26]||(e[26]=o(". It is already a part of the ",-1)),t("a",P,[r(n,{icon:"iconfont icon-w3c"}),e[23]||(e[23]=o("W3C‚Äôs Intersection Observer specification",-1))]),e[27]||(e[27]=o(". When it comes to Safari, it has been reported as ",-1)),t("a",L,[r(n,{icon:"fas fa-globe"}),e[24]||(e[24]=o("a missing feature on the Webkit Bugzilla platform",-1))]),e[28]||(e[28]=o(" since Nov 2023. Unfortunately, I will caution against using ",-1)),e[29]||(e[29]=t("code",null,"scrollMargin",-1)),e[30]||(e[30]=o(" as a progressive enhancement. The consequence is that in Safari, the data will not load before it is scrolled into view, and the user will see the data appearing. This sounds innocent enough, but there is a problem with VoiceOver in Safari. It‚Äôs a ‚Äúvicious circle‚Äù type of problem: in order for the screen reader to navigate to the element, it needed to have its data loaded, but in order to load its data, it needed to be scrolled into view.",-1))]),t("p",null,[e[32]||(e[32]=o("In spite of the lacking Safari support, I wanted to write about this property. The reason is that I think we as web developers should all push for ",-1)),t("a",A,[r(n,{icon:"fas fa-globe"}),e[31]||(e[31]=o("web browser interoperability",-1))]),e[33]||(e[33]=o(", and from my experience, I think the web platform would benefit from having ",-1)),e[34]||(e[34]=t("code",null,"scrollMargin",-1)),e[35]||(e[35]=o(" supported.",-1))]),e[47]||(e[47]=t("p",null,[t("em",null,"Thanks to Johannes Odland.")],-1)),v(" TODO: add ARTICLE CARD "),r(d,m(g({title:"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin",desc:"This helps load in data just *before* a user gets to it, and it works with non-root containers and horizontal scrolling.",link:"https://chanhi2000.github.io/bookshelf/frontendmasters.com/simplify-lazy-loading-with-intersection-observers-scrollmargin.html",logo:"https://frontendmasters.com/favicon.ico",background:"rgba(188,75,52,0.2)"})),null,16)])}const N=u(I,[["render",W]]),V=JSON.parse('{"path":"/frontendmasters.com/simplify-lazy-loading-with-intersection-observers-scrollmargin.html","title":"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin","lang":"en-US","frontmatter":{"lang":"en-US","title":"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin","description":"Article(s) > Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin","icon":"fa-brands fa-js","category":["JavaScript","Article(s)"],"tag":["blog","frontendmasters.com","js","javascript"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin\\",\\"image\\":[\\"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/4990\\"],\\"datePublished\\":\\"2025-01-20T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ingvild Forseth\\",\\"url\\":\\"https://frontendmasters.com/blog/author/ingvild-forseth/\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/frontendmasters.com/simplify-lazy-loading-with-intersection-observers-scrollmargin.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin"}],["meta",{"property":"og:description","content":"Article(s) > Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/4990"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/4990"}],["meta",{"name":"twitter:image:alt","content":"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin"}],["meta",{"property":"article:author","content":"Ingvild Forseth"}],["meta",{"property":"article:tag","content":"javascript"}],["meta",{"property":"article:tag","content":"js"}],["meta",{"property":"article:tag","content":"frontendmasters.com"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2025-01-20T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin"},{"property":"og:description","content":"Simplify Lazy Loading With Intersection Observer‚Äôs ScrollMargin"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/frontendmasters.com/simplify-lazy-loading-with-intersection-observers-scrollmargin.html"}]],"prev":"/programming/js/articles/README.md","date":"2025-01-20T00:00:00.000Z","isOriginal":false,"author":[{"name":"Ingvild Forseth","url":"https://frontendmasters.com/blog/author/ingvild-forseth/"}],"cover":"https://frontendmasters.com/blog/wp-json/social-image-generator/v1/image/4990"},"git":{},"readingTime":{"minutes":3.75,"words":1124},"filePathRelative":"frontendmasters.com/simplify-lazy-loading-with-intersection-observers-scrollmargin.md","copyright":{"author":"Ingvild Forseth"}}');export{N as comp,V as data};
