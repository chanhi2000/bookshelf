import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as f,d as t,f as o,b as a,a as v,t as b,n as u,g as d,w as i,e as n,r as l,o as w}from"./app-BItykJLQ.js";const y={},k={id:"frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´",tabindex:"-1"},x={class:"header-anchor",href:"#frontmatter-title-·ÑÄ·Ö™·Ü´·ÑÖ·Öß·Ü´"},S={class:"table-of-contents"},q={href:"https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagegroupid-property.html",target:"_blank",rel:"noopener noreferrer"},A={href:"https://learn.microsoft.com/en-us/azure/service-bus-messaging/message-sessions",target:"_blank",rel:"noopener noreferrer"},O={href:"https://developer.confluent.io/courses/apache-kafka/partitions/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://rabbitmq.com/docs/consumers?#single-active-consumer",target:"_blank",rel:"noopener noreferrer"};function P(m,e){const p=l("VPCard"),r=l("router-link"),h=l("SiteInfo"),s=l("RouteLink"),g=l("VPIcon");return w(),f("div",null,[t("h1",k,[t("a",x,[t("span",null,b(m.$frontmatter.title)+" Í¥ÄÎ†®",1)])]),o(p,u(d({title:"System Desgin > Article(s)",desc:"Article(s)",link:"/academics/system-design/articles/README.md",logo:"/images/ico-wind.svg",background:"rgba(10,10,10,0.2)"})),null,16),t("nav",S,[t("ul",null,[t("li",null,[o(r,{to:"#domain-events-feel-like-the-clean-solution"},{default:i(()=>[...e[0]||(e[0]=[n("Domain Events Feel Like the Clean Solution",-1)])]),_:1})]),t("li",null,[o(r,{to:"#the-outbox-makes-publishing-reliable-but-not-ordered"},{default:i(()=>[...e[1]||(e[1]=[n("The Outbox Makes Publishing Reliable (but not ordered)",-1)])]),_:1})]),t("li",null,[o(r,{to:"#competing-consumers-are-great-until-order-matters"},{default:i(()=>[...e[2]||(e[2]=[n("Competing consumers Are Great, Until Order Matters",-1)])]),_:1})]),t("li",null,[o(r,{to:"#what-we-really-want-is-per-aggregate-ordering"},{default:i(()=>[...e[3]||(e[3]=[n("What We Really Want is Per-Aggregate Ordering",-1)])]),_:1})]),t("li",null,[o(r,{to:"#a-single-consumer-solves-ordering-but-limits-scale"},{default:i(()=>[...e[4]||(e[4]=[n("A Single Consumer Solves Ordering But Limits Scale",-1)])]),_:1})]),t("li",null,[o(r,{to:"#publish-the-next-message-from-the-handler"},{default:i(()=>[...e[5]||(e[5]=[n("Publish the Next Message From the Handler",-1)])]),_:1})]),t("li",null,[o(r,{to:"#congratulations-you-built-a-choreographed-saga"},{default:i(()=>[...e[6]||(e[6]=[n("Congratulations, You Built a Choreographed Saga",-1)])]),_:1})]),t("li",null,[o(r,{to:"#if-you-want-control-introduce-a-state-machine-saga"},{default:i(()=>[...e[7]||(e[7]=[n("If You Want Control, Introduce a State Machine Saga",-1)])]),_:1})]),t("li",null,[o(r,{to:"#broker-support-helps-with-ordering-not-correctness"},{default:i(()=>[...e[8]||(e[8]=[n("Broker Support Helps with Ordering, not Correctness",-1)])]),_:1})]),t("li",null,[o(r,{to:"#takeaway"},{default:i(()=>[...e[9]||(e[9]=[n("Takeaway",-1)])]),_:1})])])]),e[41]||(e[41]=t("hr",null,null,-1)),o(h,{name:"Solving Message Ordering from First Principles",desc:"Per-aggregate ordering is what we really want. But queues with competing consumers make it surprisingly easy to break. This article shows how the ‚Äúfix‚Äù naturally evolves into a saga.",url:"https://milanjovanovic.tech/blog/solving-message-ordering-from-first-principles",logo:"https://milanjovanovic.tech/profile_favicon.png",preview:"https://milanjovanovic.tech/blog-covers/mnw_176.png"}),e[42]||(e[42]=a('<p>Most systems don&#39;t need <em>global</em> message ordering.</p><p>They need something simpler and more useful: <strong>events must be handled in order per aggregate</strong>.</p><p>Per <code>OrderId</code>, per <code>InvoiceId</code>, per <code>CustomerId</code>, or whatever your aggregate boundary is. You can make this as broad or as narrow as you need.</p><p>This starts as an eventing problem, but if you follow the requirements to their logical conclusion, you&#39;ll end up with a workflow. And that workflow has a name: <strong>a saga</strong>.</p><hr><h2 id="domain-events-feel-like-the-clean-solution" tabindex="-1"><a class="header-anchor" href="#domain-events-feel-like-the-clean-solution"><span>Domain Events Feel Like the Clean Solution</span></a></h2>',6)),t("p",null,[o(s,{to:"/milanjovanovic.tech/how-to-use-domain-events-to-build-loosely-coupled-systems.html"},{default:i(()=>[...e[10]||(e[10]=[t("strong",null,"Domain events",-1)])]),_:1}),e[11]||(e[11]=n(" are attractive because they come from first principles:",-1))]),e[43]||(e[43]=a('<ul><li>An aggregate changes state</li><li>It emits events describing what happened</li><li>Handlers react and do useful work</li></ul><p>You also get a nice mental model:</p><blockquote><p>State change ‚Üí Event ‚Üí Reaction</p></blockquote><p>A typical example:</p><ul><li><code>OrderPlaced</code></li><li><code>PaymentCaptured</code></li><li><code>OrderShipped</code></li></ul><p>But there&#39;s a catch.</p><p>Domain events are <strong>brittle</strong> when you try to use them for integration.</p><figure><img src="https://milanjovanovic.tech/blogs/mnw_176/domain_events_flow.png?imwidth=3840" alt="A sequence diagram showing an Aggregate committing a change, emitting Domain Events, which are then processed by multiple Event Handlers." tabindex="0" loading="lazy"><figcaption>A sequence diagram showing an Aggregate committing a change, emitting Domain Events, which are then processed by multiple Event Handlers.</figcaption></figure><p>If you publish directly from your transaction, you&#39;re coupling business correctness to an unreliable side effect:</p><ul><li>The transaction succeeds but publishing fails</li><li>Publishing succeeds but the transaction rolls back</li><li>Consumers process duplicates</li><li>Retries cause reordering</li></ul><p>So we keep the model, but harden the delivery.</p><hr><h2 id="the-outbox-makes-publishing-reliable-but-not-ordered" tabindex="-1"><a class="header-anchor" href="#the-outbox-makes-publishing-reliable-but-not-ordered"><span>The Outbox Makes Publishing Reliable (but not ordered)</span></a></h2>',13)),t("p",null,[e[13]||(e[13]=n("With an ",-1)),o(s,{to:"/milanjovanovic.tech/implementing-the-outbox-pattern.html"},{default:i(()=>[...e[12]||(e[12]=[t("strong",null,"Outbox",-1)])]),_:1}),e[14]||(e[14]=n(", we store outgoing events in the same transaction as the aggregate update.",-1))]),e[44]||(e[44]=a('<p>Then a background publisher reads the Outbox and pushes events to a queue.</p><p>This fixes the reliability problem:</p><ul><li>If the transaction commits, the event is persisted</li><li>If the publisher crashes, it can resume later</li><li>We can retry safely</li></ul><figure><img src="https://milanjovanovic.tech/blogs/mnw_176/outbox_flow.png?imwidth=3840" alt="A diagram showing an Aggregate committing a change along with an Outbox entry, which is then published to a Queue by a background process." tabindex="0" loading="lazy"><figcaption>A diagram showing an Aggregate committing a change along with an Outbox entry, which is then published to a Queue by a background process.</figcaption></figure><p>Now we&#39;ve made event publishing reliable.</p><p>But we haven&#39;t made event handling ordered.</p><hr><h2 id="competing-consumers-are-great-until-order-matters" tabindex="-1"><a class="header-anchor" href="#competing-consumers-are-great-until-order-matters"><span>Competing consumers Are Great, Until Order Matters</span></a></h2>',8)),t("p",null,[e[16]||(e[16]=n("The moment events hit a queue, we usually scale with the simplest lever: ",-1)),o(s,{to:"/milanjovanovic.tech/event-driven-architecture-in-dotnet-with-rabbitmq.html"},{default:i(()=>[...e[15]||(e[15]=[t("strong",null,"competing consumers",-1)])]),_:1}),e[17]||(e[17]=n(".",-1))]),e[45]||(e[45]=a('<p>Multiple instances consume from the same queue to increase throughput.</p><p>That works‚Ä¶ until ordering matters.</p><p>Two events for the same <code>OrderId</code> can be processed at the same time:</p><ul><li>Consumer A receives <code>PaymentCaptured</code></li><li>Consumer B receives <code>OrderPlaced</code></li><li>Side effects run out of order</li></ul><p>Even if the events were published in order, retries and redelivery can scramble processing order.</p><p>And now you have a subtle bug that only appears under load.</p><figure><img src="https://milanjovanovic.tech/blogs/mnw_176/competing_consumers.png?imwidth=3840" alt="A sequence diagram showing multiple consumers processing messages from a Queue concurrently, leading to out-of-order handling of events for the same aggregate ID." tabindex="0" loading="lazy"><figcaption>A sequence diagram showing multiple consumers processing messages from a Queue concurrently, leading to out-of-order handling of events for the same aggregate ID.</figcaption></figure><p>That&#39;s the key realization: queues scale work. They don&#39;t preserve your invariants.</p><hr><h2 id="what-we-really-want-is-per-aggregate-ordering" tabindex="-1"><a class="header-anchor" href="#what-we-really-want-is-per-aggregate-ordering"><span>What We Really Want is Per-Aggregate Ordering</span></a></h2><p>You don&#39;t need one ordered line for <em>everything</em>.</p><p>You need many independent ordered lines, one per aggregate.</p><p>That usually holds true because:</p><ul><li>Aggregates already define consistency boundaries</li><li>Events are naturally produced in order (v1, v2, v3‚Ä¶)</li><li>The &quot;correct&quot; order is the aggregate&#39;s own timeline</li></ul><p>If we could guarantee that <strong>only one handler processes events for a given aggregate at a time</strong>, most of the problem disappears.</p><p>The most direct solution is also the simplest: <strong>use a single consumer for the whole stream.</strong></p><p>That enforces ordering, assuming events are published in order.</p><figure><img src="https://milanjovanovic.tech/blogs/mnw_176/single_consumer.png?imwidth=3840" alt="A sequence diagram showing a single consumer processing messages from a Queue, leading to ordered handling of events for the same aggregate ID." tabindex="0" loading="lazy"><figcaption>A sequence diagram showing a single consumer processing messages from a Queue, leading to ordered handling of events for the same aggregate ID.</figcaption></figure><p>But it has an obvious drawback.</p><hr><h2 id="a-single-consumer-solves-ordering-but-limits-scale" tabindex="-1"><a class="header-anchor" href="#a-single-consumer-solves-ordering-but-limits-scale"><span>A Single Consumer Solves Ordering But Limits Scale</span></a></h2><p>One consumer means:</p><ul><li>Throughput ceiling (one worker)</li><li>Latency spikes under load</li><li>Scaling becomes vertical, not horizontal</li></ul><p>Even if your events are lightweight, you&#39;re artificially bottlenecking the system.</p><p>So we want:</p><ul><li><strong>Per-aggregate ordering</strong></li><li><strong>Horizontal scaling</strong></li><li><strong>Reliability (Outbox still stays)</strong></li></ul><p>This is where teams often &quot;invent&quot; the next step.</p><hr><h2 id="publish-the-next-message-from-the-handler" tabindex="-1"><a class="header-anchor" href="#publish-the-next-message-from-the-handler"><span>Publish the Next Message From the Handler</span></a></h2><p>If competing consumers break ordering, one natural idea is:</p><blockquote><p>Don&#39;t let the queue decide what&#39;s next, we decide.</p></blockquote><p>Instead of dumping all events into the queue and letting consumers race, we move to a chained approach:</p><ol><li>Handle one message for an aggregate</li><li>When done, publish the <strong>next</strong> message to be handled</li></ol><p>Now, the system processes a single message at a time per aggregate.</p><figure><img src="https://milanjovanovic.tech/blogs/mnw_176/choreographed_saga.png?imwidth=3840" alt="A diagram showing a sequence of events being processed one at a time per aggregate ID, with each event handler publishing the next event upon completion." tabindex="0" loading="lazy"><figcaption>A diagram showing a sequence of events being processed one at a time per aggregate ID, with each event handler publishing the next event upon completion.</figcaption></figure><p>This is the key moment:</p><p>You&#39;ve stopped building &quot;event handlers&quot;.</p><p>You&#39;ve started building a <strong>workflow</strong>.</p><p>And that workflow is‚Ä¶ a saga.</p><hr><h2 id="congratulations-you-built-a-choreographed-saga" tabindex="-1"><a class="header-anchor" href="#congratulations-you-built-a-choreographed-saga"><span>Congratulations, You Built a Choreographed Saga</span></a></h2>',41)),t("p",null,[e[19]||(e[19]=n("A ",-1)),o(s,{to:"/milanjovanovic.tech/orchestration-vs-choreography.html"},{default:i(()=>[...e[18]||(e[18]=[t("strong",null,"choreographed saga",-1)])]),_:1}),e[20]||(e[20]=n(" is a workflow where:",-1))]),e[46]||(e[46]=a('<ul><li>Each step reacts to an event</li><li>Performs work</li><li>Emits the next event to trigger the next step</li></ul><p>There isn&#39;t a single central coordinator.</p><p>Instead, we have a chain of events: &quot;when X happens, do Y, then publish Z&quot;.</p><p>This pattern naturally fits your new requirement:</p><ul><li>Per-aggregate ordering is preserved (the chain is sequential)</li><li>You can scale across aggregates (many chains in flight)</li><li>Each step is isolated and retryable</li></ul><p>It also forces a useful discipline:</p><ul><li>&quot;What&#39;s the next step?&quot; becomes explicit</li><li>Boundaries between steps become clearer</li><li>You can observe the workflow as a sequence</li></ul><p>But choreography has a limitation: <strong>control is distributed</strong>, so tracking progress and handling exceptions can get messy.</p><p>So we take the final step.</p><hr><h2 id="if-you-want-control-introduce-a-state-machine-saga" tabindex="-1"><a class="header-anchor" href="#if-you-want-control-introduce-a-state-machine-saga"><span>If You Want Control, Introduce a State Machine Saga</span></a></h2><p>When the workflow becomes important, you often want:</p><ul><li>A single place that knows the current state</li><li>Visibility into progress (&quot;where are we stuck?&quot;)</li><li>Explicit timeouts and retries</li><li>Compensating actions when something fails</li></ul>',13)),t("p",null,[e[22]||(e[22]=n("That's when you move from choreography to ",-1)),e[23]||(e[23]=t("strong",null,"orchestration",-1)),e[24]||(e[24]=n(" via a ",-1)),o(s,{to:"/milanjovanovic.tech/implementing-the-saga-pattern-with-masstransit.html"},{default:i(()=>[...e[21]||(e[21]=[t("strong",null,"state machine saga",-1)])]),_:1}),e[25]||(e[25]=n(":",-1))]),e[47]||(e[47]=a('<ul><li>The saga holds the workflow state</li><li>Events drive transitions</li><li>The saga decides what message to publish next</li><li>You gain control and observability</li></ul><figure><img src="https://milanjovanovic.tech/blogs/mnw_176/state_machine.png?imwidth=3840" alt="A state machine diagram showing states and transitions for a saga managing ordered message processing per aggregate ID." tabindex="0" loading="lazy"><figcaption>A state machine diagram showing states and transitions for a saga managing ordered message processing per aggregate ID.</figcaption></figure><p>This doesn&#39;t replace the Outbox, by the way.</p><p>You still want reliable publishing.</p><p>You&#39;ve just made the workflow explicit.</p><hr><h2 id="broker-support-helps-with-ordering-not-correctness" tabindex="-1"><a class="header-anchor" href="#broker-support-helps-with-ordering-not-correctness"><span>Broker Support Helps with Ordering, not Correctness</span></a></h2><p>It&#39;s worth calling out that you don&#39;t always have to build this yourself.</p><p>Many popular message brokers provide technical primitives for <strong>ordered processing per key</strong> (your aggregate ID):</p>',9)),t("ul",null,[t("li",null,[t("a",q,[o(g,{icon:"fa-brands fa-aws"}),e[26]||(e[26]=n("Amazon SQS FIFO message groups",-1))]),e[27]||(e[27]=n(" (per key)",-1))]),t("li",null,[t("a",A,[o(g,{icon:"iconfont icon-microsoftazure"}),e[28]||(e[28]=n("Azure Service Bus sessions",-1))]),e[29]||(e[29]=n(" (per key)",-1))]),t("li",null,[t("a",O,[o(g,{icon:"fas fa-globe"}),e[30]||(e[30]=n("Kafka Partitions",-1))]),e[31]||(e[31]=n(" in a log (key ‚Üí partition ‚Üí ordered stream)",-1))]),t("li",null,[t("a",I,[o(g,{icon:"iconfont icon-rabbitmq"}),e[32]||(e[32]=n('RabbitMQ "single active consumer"',-1))]),e[33]||(e[33]=n(" style semantics (per queue)",-1))])]),e[48]||(e[48]=t("p",null,[n("These features can eliminate the most common failure mode of competing consumers: "),t("strong",null,"concurrent handling of messages for the same aggregate"),n(".")],-1)),e[49]||(e[49]=t("p",null,"But even with perfect per-aggregate ordering, you still need patterns around it to keep the system correct:",-1)),t("ul",null,[e[38]||(e[38]=t("li",null,[t("strong",null,"Outbox"),n(" to publish reliably (ordering is useless if events are lost)")],-1)),t("li",null,[o(s,{to:"/milanjovanovic.tech/idempotent-consumer-handling-duplicate-messages.html"},{default:i(()=>[...e[34]||(e[34]=[t("strong",null,"Idempotent consumers",-1)])]),_:1}),e[35]||(e[35]=n(" / ",-1)),e[36]||(e[36]=t("strong",null,"Inbox",-1)),e[37]||(e[37]=n(" because retries and duplicates still happen",-1))]),e[39]||(e[39]=t("li",null,[t("strong",null,"Consistency boundaries"),n(" (what's safe to do inside the transaction vs outside)")],-1)),e[40]||(e[40]=t("li",null,[t("strong",null,"Timeouts"),n(" + "),t("strong",null,"compensation"),n(' when the "ordered sequence" is actually a business workflow that can partially fail')],-1))]),e[50]||(e[50]=a('<p>So broker-level ordering is a great foundation. It reduces accidental complexity. It just doesn&#39;t remove the need to model long-running work explicitly when the business demands it.</p><hr><h2 id="takeaway" tabindex="-1"><a class="header-anchor" href="#takeaway"><span>Takeaway</span></a></h2><p>If you follow the problem from first principles:</p><ul><li>Aggregates define the boundary where ordering matters</li><li>The Outbox makes event publishing reliable</li><li>Competing consumers break per-aggregate order</li><li>A single consumer restores order but caps throughput</li><li>Publishing &quot;the next message&quot; creates sequential progress per aggregate</li><li>That sequential progress is a saga (choreographed first, state machine when you need control)</li></ul><p>So you didn&#39;t reinvent something by accident.</p><p>You discovered that &quot;ordered handling per aggregate at scale&quot; is not a queue feature.</p><p>It&#39;s a workflow. And sagas are how we model workflows in distributed systems.</p><p>Once you see it that way, you stop fighting queues for ordering guarantees.</p><p>You design the workflow the business actually needs.</p><hr>',11)),v(" TODO: add ARTICLE CARD "),o(p,u(d({title:"Solving Message Ordering from First Principles",desc:"Per-aggregate ordering is what we really want. But queues with competing consumers make it surprisingly easy to break. This article shows how the ‚Äúfix‚Äù naturally evolves into a saga.",link:"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/solving-message-ordering-from-first-principles.html",logo:"https://milanjovanovic.tech/profile_favicon.png",background:"rgba(79,70,229,0.2)"})),null,16)])}const M=c(y,[["render",P]]),C=JSON.parse('{"path":"/milanjovanovic.tech/solving-message-ordering-from-first-principles.html","title":"Solving Message Ordering from First Principles","lang":"en-US","frontmatter":{"lang":"en-US","title":"Solving Message Ordering from First Principles","description":"Article(s) > Solving Message Ordering from First Principles","icon":"fas fa-pen-ruler","category":["Design","System","Article(s)"],"tag":["blog","milanjovanovic.tech","design","system"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Solving Message Ordering from First Principles\\",\\"image\\":[\\"https://milanjovanovic.tech/blogs/mnw_176/domain_events_flow.png?imwidth=3840\\",\\"https://milanjovanovic.tech/blogs/mnw_176/outbox_flow.png?imwidth=3840\\",\\"https://milanjovanovic.tech/blogs/mnw_176/competing_consumers.png?imwidth=3840\\",\\"https://milanjovanovic.tech/blogs/mnw_176/single_consumer.png?imwidth=3840\\",\\"https://milanjovanovic.tech/blogs/mnw_176/choreographed_saga.png?imwidth=3840\\",\\"https://milanjovanovic.tech/blogs/mnw_176/state_machine.png?imwidth=3840\\"],\\"datePublished\\":\\"2026-01-10T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Milan Jovanoviƒá\\"}]}"],["meta",{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/solving-message-ordering-from-first-principles.html"}],["meta",{"property":"og:site_name","content":"üìöBookshelf"}],["meta",{"property":"og:title","content":"Solving Message Ordering from First Principles"}],["meta",{"property":"og:description","content":"Article(s) > Solving Message Ordering from First Principles"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://milanjovanovic.tech/blog-covers/mnw_176.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://milanjovanovic.tech/blog-covers/mnw_176.png"}],["meta",{"name":"twitter:image:alt","content":"Solving Message Ordering from First Principles"}],["meta",{"property":"article:author","content":"Milan Jovanoviƒá"}],["meta",{"property":"article:tag","content":"system"}],["meta",{"property":"article:tag","content":"design"}],["meta",{"property":"article:tag","content":"milanjovanovic.tech"}],["meta",{"property":"article:tag","content":"blog"}],["meta",{"property":"article:published_time","content":"2026-01-10T00:00:00.000Z"}],[{"meta":null},{"property":"og:title","content":"Article(s) > Solving Message Ordering from First Principles"},{"property":"og:description","content":"Solving Message Ordering from First Principles"},{"property":"og:url","content":"https://chanhi2000.github.io/bookshelf/milanjovanovic.tech/solving-message-ordering-from-first-principles.html"}]],"prev":"/academics/system-design/articles/README.md","date":"2026-01-10T00:00:00.000Z","isOriginal":false,"author":"Milan Jovanoviƒá","cover":"https://milanjovanovic.tech/blog-covers/mnw_176.png"},"git":{},"readingTime":{"minutes":5.44,"words":1632},"filePathRelative":"milanjovanovic.tech/solving-message-ordering-from-first-principles.md","copyright":{"author":"Milan Jovanoviƒá"}}');export{M as comp,C as data};
