---
lang: ko-KR
title: "새로 산 맥북으로 “더 쉽게” 쿠버네티스 클러스터 구성하기"
description: "Article(s) > 새로 산 맥북으로 “더 쉽게” 쿠버네티스 클러스터 구성하기"
icon: iconfont icon-k8s
category:
  - DevOps
  - Kubernetes
  - macOS
  - Virtualbox
  - Vagrant
  - Article(s)
tag:
  - blog
  - yozm.wishket.com
  - devops
  - k8s
  - kubernetes
  - macos
  - virtualbox
  - vagrant
head:
  - - meta:
    - property: og:title
      content: "Article(s) > 새로 산 맥북으로 “더 쉽게” 쿠버네티스 클러스터 구성하기"
    - property: og:description
      content: "새로 산 맥북으로 “더 쉽게” 쿠버네티스 클러스터 구성하기"
    - property: og:url
      content: https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3284.html
prev: /devops/k8s/articles/README.md
date: 2025-08-11
isOriginal: false
author:
  - name: 조훈(Hoon Jo)
    url : https://yozm.wishket.com/magazine/@pagaia/
cover: https://yozm.wishket.com/media/news/3284/image20.png
---

# {{ $frontmatter.title }} 관련

```component VPCard
{
  "title": "Kubernetes > Article(s)",
  "desc": "Article(s)",
  "link": "/devops/k8s/articles/README.md",
  "logo": "/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

```component VPCard
{
  "title": "macOS > Article(s)",
  "desc": "Article(s)",
  "link": "/devops/macos/articles/README.md",
  "logo": "/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

```component VPCard
{
  "title": "Virtualbox > Article(s)",
  "desc": "Article(s)",
  "link": "/devops/virtualbox/articles/README.md",
  "logo": "/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

```component VPCard
{
  "title": "Vagrant > Article(s)",
  "desc": "Article(s)",
  "link": "/devops/vagrant/articles/README.md",
  "logo": "/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

[[toc]]

---

<SiteInfo
  name="새로 산 맥북으로 “더 쉽게” 쿠버네티스 클러스터 구성하기"
  desc="x86-64 환경만 지원하던 버추얼박스(VirtualBox)가 최근 arm64 기반 맥북을 제대로 지원하기 시작했습니다. 덕분에 현재는 VM웨어 퓨전 대신 버추얼박스로 쿠버네티스 클러스터를 구성할 수 있게 되었습니다. 이를 통해 기존의 불편함이 대부분 해소되었으며, 윈도와 맥OS 기반 환경 모두 동일한 코드로 배포와 실행을 할 수 있어졌습니다. 따라서 이번 글에서는 버추얼박스가 arm64를 지원하기까지의 과정을 살펴본 다음, 이를 활용한 쿠버네티스 클러스터 구성 방법을 소개하겠습니다."
  url="https://yozm.wishket.com/magazine/detail/3284/"
  logo="https://yozm.wishket.com/fav1con.ico"
  preview="https://yozm.wishket.com/media/news/3284/image20.png"/>

지난 글 [**새로 산 맥북으로 쿠버네티스 클러스터 구성하기**](/yozm.wishket.com/2658.md)에서는, 베이그런트(Vagrant)와 VM웨어 퓨전(VMware Fusion)을 활용해 클러스터를 구성한 바 있습니다. 다만 이 방식은 설치 전에 사전 준비가 필요하고, 실제 사용하기에도 여러 불편함이 있었습니다. 특히 VM웨어 퓨전은 라이선스 문제도 있고, 공식 파일을 내려받으려면 회원 가입을 해야 한다는 문제도 있었습니다.

![베이그런트와 VM웨어 퓨전을 활용한 쿠버네티스 클러스터 구성](https://wishket.com/media/news/3284/image27.png)

이런 상황에서 x86-64 환경만 지원하던 버추얼박스(VirtualBox)가 최근 arm64 기반 맥북을 제대로 지원하기 시작했습니다. (정확히 말하자면, 오랜 기간 arm64 지원을 준비해 온 버추얼박스가 이제서야 실현한 것입니다.) 덕분에 현재는 VM웨어 퓨전 대신 버추얼박스로 쿠버네티스 클러스터를 구성할 수 있게 되었습니다.

![베이그런트와 버추얼박스를 활용한 쿠버네티스 클러스터 구성](https://wishket.com/media/news/3284/image20.png)

이를 통해 기존의 불편함이 대부분 해소되었으며, 윈도와 맥OS 기반 환경 모두 동일한 코드로 배포와 실행을 할 수 있어졌습니다.

따라서 이번 글에서는 버추얼박스가 arm64를 지원하기까지의 과정을 살펴본 다음, 이를 활용한 쿠버네티스 클러스터 구성 방법을 소개하겠습니다. 구성 방법부터 확인하고 싶은 경우, 아래로 글을 내려 바로 볼 수도 있습니다.

---

## 버추얼박스의 arm64 지원 시도들

버추얼박스는 원래 x86-64 기반 가상화 기술로, **VT-x/AMD-V**와 같은 하드웨어 가상화 기술을 기반으로 두고 있습니다. 이 때문에 arm 또는 arm64로의 이전이 쉽지 않았습니다. 실제로 개발팀은 x86-64만을 지원할 것이라고 꾸준히 얘기해 왔습니다.

![2021년 x86, AMD64/Intel64 전용 하이퍼바이저라고 말한 답변<br/><출처: [<FontIcon icon="fas fa-globe"/>Stack Exchange](https://apple.stackexchange.com/questions/422565/does-virtualbox-run-on-apple-silicon)>](https://wishket.com/media/news/3284/image25.png)

그러나 이러한 다짐은, 새로운 애플 기기의 등장으로 달라집니다. 2020년 11월 출시된 애플 실리콘 맥 M1의 폭발적인 인기가 식지 않았고, 2022년 6월 공개된 후속작 M2도 시장 장악력을 늘렸기 때문입니다.

M1과 M2가 인기를 얻으며 커뮤니티를 중심으로 나온 꾸준한 요구에 따라, 버추얼박스 개발팀은 버추얼박스를 지원할 여러 시도를 이어갔습니다. 그런 와중, 2022년 개발자 프리뷰(Developer Prev1ew) 버전을 공개하며 이제 지원을 할 수 있다고 발표했습니다.

![2022년, [<FontIcon icon="fas fa-globe"/>된다는 말](https://osxdaily.com/2022/10/22/you-can-now-run-virtualbox-on-apple-silicon-m1-m2/)과 다르게, 동작하지 않은 버전<br/><출처: 버추얼박스>](https://wishket.com/media/news/3284/image14.png)

초기 프리뷰 버전은 버그와 해결되지 않은 문제가 넘쳐났지만, 시간이 지나도 해결될 기미는 보이지 않았습니다. 개발 속도 자체도 진척이 없었습니다. 결국 프리뷰 버전 다운로드 링크마저 사라지며, arm 기반 맥에서 버추얼박스를 사용하는 일은 사람들의 기억에서 잊히는 듯 했습니다.

![2023년, 개발자 프리뷰 버전을 다운로드 받는 곳이 사라진 모습. [<FontIcon icon="iconfont icon-virtualbox"/>다운로드 링크](https://download.virtualbox.org/virtualbox/7.0.0/VirtualBox-7.0.0_BETA4-153978-macOSArm64.dmg)<br/><출처: [<FontIcon icon="iconfont icon-virtualbox"/>버추얼박스](https://virtualbox.org/ticket/21771)>](https://wishket.com/media/news/3284/image21.png)

그렇게 사실 저도 거의 포기하고 VM웨어 퓨전을 사용하기로 했습니다. 때마침 라이선스 정책이 개인 사용자에게 유리하게 바뀌었기 때문입니다.

그러다 갑자기 버추얼박스는 2024년 9월, 버전 **v7.1**부터 arm을 공식 지원한다고 발표했습니다.

![<출처: 버추얼박스>](https://wishket.com/media/news/3284/image3.png)

이를 확인하기 위해 최신 버전인 v7.1.10을 실제로 검증해 본 결과, 버그도 거의 없었고, 성능과 사용 편의성 모두 좋은 수준이었습니다. 따라서 이제는 다소 제약이 많았던 VM웨어 퓨전 대신, 버추얼박스를 사용하는 것을 적극 추천합니다.

---

## 버추얼박스로 arm64 기반의 쿠버네티스 클러스터 구성하기

그럼 본격적으로 버추얼박스로 arm64 기반 쿠버네티스 클러스터를 구축하는 과정을 알아보겠습니다. 크게 세 단계로 진행됩니다.

1. arm64 기반의 쿠버네티스 클러스터 배포를 위한 소프트웨어 설치
2. 설치한 소프트웨어를 활용한 클러스터 구성
3. 구성한 터미널 프로그램으로 클러스터를 확인하고, 간단한 애플리케이션을 배포

이제 이 3단계에 따라 arm64 환경에서 쿠버네티스 클러스터를 실제로 구성하고, 동작 여부를 확인하겠습니다.

![배포할 쿠버네티스 클러스터 v1.33의 로고<br/><출처: 쿠버네티스>](https://wishket.com/media/news/3284/image23.png)

### 1. `arm64` 기반의 쿠버네티스 클러스터 배포를 위한 소프트웨어 설치

먼저, 손쉬운 설치를 위해 이미 구성이 완료된 깃헙 소스를 로컬 환경에 클론(`clone`)합니다.

```sh
git clone https://github.com/sysnet4admin/_Lecture_k8s_learning.kit.git
# 
# C10ning into '_Lecture k8s_Iearning.kit'
# remote: Enumerating objects: 5897, done.
# [생략]
```

<!-- ![클론한 소스 디렉터리 중 ch2/2.4로 이동하겠습니다. 이곳에는 `arm64` 배포용 소프트웨어, 터미널 프로그램, 그리고 관련 설정 파일들이 준비되어 있습니다.](https://wishket.com/media/news/3284/1.png) -->

우선 설치해야 할 소프트웨어는 다음 세 가지입니다.

- 버추얼박스(VirtualBox)
- 베이그런트(Vagrant)
- 타비(Tabby)

```sh
cd _Lecture_k8s_learning.kit/ch2/2.4
ls -1
# 
# controlplane_node.sh
# extra_k8s_pkgs.sh
# k8s_env_build.sh
# k8s_pkg_cfg • sh
# tabby-v1.0.2Ø7
# VagrantfiIe
# vagrant-v2.4.7
# v1rtua1box-v7.1.10
# worker_nodes.sh
```

<!-- ![버추얼박스(VirtualBox) 설치](https://wishket.com/media/news/3284/2.png) -->

버추얼박스는 `brew install` 명령어로도 설치할 수 있지만, 호환성 유지를 위해 미리 준비된 `.rb` 파일을 사용해 고정 버전(v7.1.10)의 버추얼박스를 설치합니다. VM웨어 퓨전과 달리, 추가 구성은 필요하지 않습니다.

```sh
brew install --cask ./virtualbox-v7.1.10/virtualbox.rb 
# 
# ==> Downloading
# https://download.virtualbox.org/virtualbox/7.1.10/VirtualBox-7.1.10-169112-macOSArm64.dmg
# Already downloaded:
# /Users/hj/Library/Caches/Homebrew/down10ads/cIØ847be12cf61160d18b66cf2be3cce1143d8a2b0b1千千c046a0a235892dc4c4-VirtualBox-7.1.10-169112-macOSArm64.dmg
# => lnstalling Cask virtualbox
# => Running installer for virtualbox with sudo; the password may be necessary.
Password: <암호 입력>
# 
# installer: Package name is Orac1e V1rtua1Box
# installer: choices changes file
# '/private/tmp/choices20250624-38604-4w8fu5.xm1' applied
# installer: lnstalling at base path /
# installer: The install was successful.
# 鬱 vmware-fusion was successfully installed!
```

<!-- ![베이그런트(Vagrant) 설치](https://wishket.com/media/news/3284/3.png) -->

베이그런트 역시 고정 버전 설치를 위해 `.rb` 파일을 사용해 **v2.4.7**을 설치합니다.

마찬가지로 VM웨어 퓨전을 사용할 때는 베이그런트 플러그인을 추가로 설치해야 했지만, 버추얼박스 환경에서는 플러그인이 필요하지 않으므로 바로 다음 단계로 넘어가겠습니다.

<!-- ![타비(Tabby) 설치와 접속 정보 추가](https://wishket.com/media/news/3284/4.png) -->

```sh
brew install --cask ./vagrant-v2.4.7/vagrant-v2.4.7/vagrant.rb
#
# ==> Downloading
# https://re1eases.hashicorp.com/vagrant/2.4.7/vagrant_2.4.7_darwin_arm64.dmg
# Already downloaded:
# /Users/hj/Library/Caches/Homebrew/down10ads/3d87ee0b909cfd886c1232aa833f37c3beebaIdabd0千a72292a千0d74c896123d-ⅴagrant-2.4.7_darwin_arm64.dmg
# => lnstalling Cask vagrant
# => Running installer for vagrant with sudo; the password may be necessary
Password: <암호 입력>
#
# installer: Package name is Vagrant
# installer: Upgrading at base path /
# installer: The upgrade was successful.
# ==> Linking Bash Comp1etion 'completion.sh' to
# '/opt/homebrew/etc/bash_completion.d/vagrant'
# ==> Linking Zsh Comp1etion '_vagrant' to
# '/opt/homebrew/share/zsh/site-functions/_vagrant'
# 鬱 vagrant was successfully installed!
```

마지막으로, 쿠버네티스 클러스터를 배포한 다음 접속을 돕는 터미널 프로그램 타비(Tabby)를 설치합니다. 역시 `.rb` 파일을 이용해 **v1.0.207**을 설치합니다.

```sh
brew install --cask ./tabby-v1.0.207/tabby.rb
#
# ==> Downloading
# https://github.com/Eugeny/tabby/re1eases/down10ad/v1.e.207/tabby-1.0.207-macos-arm64.zip
# Already downloaded:
# /Users/hj/Library/Caches/Homebrew/down10ads/6ac0899dd17d84fb668f23226094b674b千7千5615155b29ba53a109c4d519e782--tabby-1.0.207-macos-arm64.zip
# => lnstalling Cask tabby
# => Moving App 'Tabby.app' to '/App1ications/Tabby.app
# 鬱 tabby was successfully installed!
```

<!-- ![](https://wishket.com/media/news/3284/5.png) -->

설치 후에는 접속 정보를 미리 입력해 둔 파일(<FontIcon icon="iconfont icon-yaml"/>`config.yaml`)을 복사해 따로 입력하는 번거로움을 줄입니다.

<!-- ![](https://wishket.com/media/news/3284/6.png) -->

```sh
cp ./tabby-v1.0.2Ø7/config.yaml ~/Library/App1ication\ Support/tabby
```

#### 2. 설치한 소프트웨어를 활용한 클러스터 구성

이제 앞서 설치한 소프트웨어를 활용해 **쿠버네티스(Kubernetes) 클러스터**를 구성할 차례입니다. 과정을 간단히 그리면 다음과 같습니다.

![베이그런트, 버추얼박스 그리고 타비의 관계](https://wishket.com/media/news/3284/image20.png)

먼저 베이그런트에서 버추얼박스로 요청할 내용을 담은 <FontIcon icon="fas fa-folder-open"/>`B/B.001/U` 디렉터리로 이동합니다. 기존에는 2.4 디렉터리에서도 설치할 수 있었지만, 해당 버전은 쿠버네티스 **v1.30**을 설치하므로, 최신 **v1.33** 버전을 사용하기 위해서는 <FontIcon icon="fas fa-folder-open"/>`B/B.001/U`로 이동해야 합니다.

해당 디렉터리의 구성은 다음과 같습니다.

```sh
cd ../../B/B.001/U/
ls -1
#
# README.md
# Vagrantfile
# controlplane_node.sh
# extra_k8s_pkgs.sh
# k8s_env_build.sh
# k8s_pkg_cfg.sh
# worker_nodes.sh
```

<!-- ![](https://wishket.com/media/news/3284/7.png) -->

디렉터리로 이동하고, `vagrant up` 명령어를 실행해 클러스터 구성을 시작합니다. 참고로, 이때는 VM웨어 퓨전과 다르게 구성 화면이 계속 팝업되지 않습니다.

<!-- ![](https://wishket.com/media/news/3284/8.png) -->

```sh :collapsed-lines
vagrant up
#
# Bringing machine 'cp-k8s-1.33.2' up with 'virtualbox' provider
# Bringing machine 'w1-k8s-1.33.2' up with 'virtualbox' provider
# Bringing machine 'w2-k8s-1.33.2' up with 'virtualbox' provider
# Bringing machine 'w3-k8s-1.33.2' up with 'virtualbox' provider
# ==> cp-k8s-1.33.2: Importing base box 'sysnet4admin/Ubuntu-k8s'...
# ==> cp-k8s-1.33.2: Matching MAC address for NAT networking...
# ==> cp-k8s-1.33.2: Checking if box 'sysnet4admin/Ubuntu-k8s' version '0.8.6' is up to date...
# ==> cp-k8s-1.33.2: Setting the name of the VM: cp-k8s-1.33.2(github_SysNet4Admin)
# ==> cp-k8s-1.33.2: Clearing any previously set network interfaces...
# ==> cp-k8s-1.33.2: Preparing network interfaces based on configuration...
#     cp-k8s-1.33.2: Adapter 1: nat
#     cp-k8s-1.33.2: Adapter 2: hostonly
# ==> cp-k8s-1.33.2: Forwarding ports...
#     cp-k8s-1.33.2: 22 (guest) => 60010 (host) (adapter 1)
# ==> cp-k8s-1.33.2: Running 'pre-boot' VM customizations...
# ==> cp-k8s-1.33.2: Booting VM...
# ==> cp-k8s-1.33.2: Waiting for machine to boot. This may take a few minutes...
#     cp-k8s-1.33.2: SSH address: 127.0.0.1:60010
# ==> cp-k8s-1.33.2: SSH username: vagrant
#
# [중략]
#
# ==> w3-k8s-1.33.2: Running provisionerL: shell..
#     w3-k8s-1.33.2: Running /var/folders/wf/p21p461x4kj0zyyv2fwtcpl40000gn/T/vagrant-shell20250624-40848-89mgq2.sh
#     w3-k85-1.33.2: [preflight] Running pre-flight checks
#     w3-k85-1.33.2: [preflight] Reading configuration from the "kubeadm-config" ConfigMap in namespace "kube-system"...
#     w3-k85-1.33.2: [preflight] Use 'kubeadm init phase upload-config -config your-config-file' tO re-upload it.
#     w3-k85-1.33.2: [kubelet-start] Writing kubelet configuration tO file "/var/lib/kubelet/config.yaml"
#     w3-k85-1.33.2: [kubelet-start] Writing kubelet environment file with flags tO file "/var/lib/kubelet/kubeadm-flags.env"
#     w3-k85-1.33.2: [kubelet-start] Starting the kubelet
#     w3-k85-1.33.2: [kubelet-check] Waiting a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up tO 4m05
#     w3-k85-1.33.2: [kubelet-check] The kubelet is healthy after 1.000734493s
#     w3-k85-1.33.2: [kubelet-start] Waiting the kubelet tO perform the TLS Bootstrap
#     w3-k85-1.33.2: This node has joined the cluster:
#     w3-k85-1.33.2: * Certificate signing request was sent tO apiserver and a response was received 
#     w3-k85-1.33.2: * The Kube1et was informed Of the new secure connection details.
#     w3-k85-1.33.2: Run 'kubectl get nodes' on the control-plane to see this node join the cluster.
#     w3-k85-1.33.2: 
```

위의 코드처럼, `vagrant up` 모든 과정이 완료된 것을 확인하면, 간단히 구성이 끝납니다.

### 3. 구성한 터미널 프로그램으로 클러스터를 확인하고, 간단한 애플리케이션을 배포

배포를 마친 쿠버네티스 클러스터의 노드에 접속하기 위해, 터미널 프로그램 타비(Tabby)를 실행합니다.

타비를 실행하면, 다음과 같이 **프로필 선택 화면**이 나타납니다. 이 중 `cp-k8s`를 선택합니다.

![](https://wishket.com/media/news/3284/image6.png)

`cp-k8s`를 선택하면 **호스트 키 확인** 메시지가 나타납니다. 여기서는 ‘허용 후 키 저장’을 선택하고 진행합니다.

(만약 암호를 물어본다면, `vagrant`를 입력합니다.)

![](https://wishket.com/media/news/3284/image24.png)

`cp-k8s`에 접속한 다음, `k get nodes`, 그리고 `k get po -A` 명령어를 입력해 배포가 정상적으로 이뤄졌는지 확인합니다.

```sh 
k get nodes
#
# NAME    STATUS   ROLES          AGE      VERSION
# cp-k8s  Ready    control-plane  6m1s     v1.33.2
# w1-k8s  Ready                   4m42s    v1.33.2
# w2-k8s  Ready                   3m49s    v1.33.2
# w3-k8s  Ready                   2m55s    v1.33.2

k get PO -A
#
# NAMESPACE        NAME                                       READY     STATUS        RESTARTS         AGE
# default          nfs—c1ient—provisioner—6ff67fc8f4—tkbf2    1/1       Running       0                6m55s
# ingress—ngxnx    ingress—nginx—admission—create—vjwqq       0/1       Comp1eted     0                6m55s
# ingress—ngxnx    ingress—nginx—admission—patch—cdksq        0/1       Comp1eted     0                6m55s
# ingress—ngxnx    ingress—nginx—controller—6bd79f4d5—9b2bg   1/1       Running       0                6m55s
# kube—system      calico—kube—controllers—7c5bbf5ff4—rd6mf   1/1       Running       0                6m55s
# kube—system      calico—node—cz4wv                          1/1       Running       0                5m15s
# kube—system      calico—node—ppkbf                          1/1       Running       0                6m56s
# kube—system      calico—node—rfq6n                          1/1       Running       0                6m9s
# kube—system      calico—node—ttwck                          1/1       Running       0                4m22s
# kube—system      coredns—674b8bbfcf—5h852                   1/1       Running       0                6m55s
# kube—system      coredns—674b8bbfcf—nwpnt                   1/1       Running       0                6m55s
# kube—system      etcd—cp—k8s                                1/1       Running       1 (7m21s ago)    7m26s
# kube—system      kube—apiserver—cp—k8s                      1/1       Running       1 (7m20s ago)    7m26s
# kube—system      kube—contr011er—manager—cp—k8s             1/1       Running       1 (7m20s ago)    7m26s
# kube—system      kube—proxy—91kd8                           1/1       Running       0                5m15s
# kube—system      kube—proxy—cq857                           1/1       Running       0                4m22s
# kube—system      kube—proxy—kptpk                           1/1       Running       0                6m56s
# kube—system      kube—proxy—wwhbk                           1/1       Running       0                6m9s
# kube—system      kube—schedu1er—cp—k8s                      1/1       Running       1 (7m20s ago)    7m26s
# kube—system      metrics—server—566c54b84f—6kg84            1/1       Running       0                6m55s
# metallb—system   contr011er—bb5f47665—tbgvq                 1/1       Running       0                6m55s
# metallb—system   speaker—gbcsw                              1/1       Running       0                6m44s
# metallb—system   speaker—sjks8                              1/1       Running       0                5m48s
# metallb—system   speaker—sxwj5                              1/1       Running       0                4m28s
# metallb—system   speaker—xkj9n                              1/1       Running       0                4m4s
```

<!-- ![](https://wishket.com/media/news/3284/9.png) -->

또한, 로드밸런서 생성을 지원하는 **MetalLB**의 IP Pool 동작 여부도 확인합니다. `k get ipaddresspools.metallb.io -A` 명령어를 입력하고, 아래와 같은 응답이 나오는지 확인합니다.

다만, 이 내용은 접속과 함께 바로 나타나지는 않습니다. `cp-k8s` 배포가 끝나고 약 10분이 지난 다음 동작하도록 설계되어 있으니, 조금 더 기다려 볼 수 있습니다.

```sh
k get ipaddresspools.metallb.io -A
#
# NAMESPACE        NAME           AUTO ASSIGN    AVOID BUGGY IPS    ADDRESSES
# metallb-system   k8s-svc-pool   true           false              ["192.168.1.11-192.168.1.99"]
```

<!-- ![](https://wishket.com/media/news/3284/10.png) -->

이제 `arm64` 환경에서 클러스터가 정상 동작하는지 검증하기 위해, `sysnet4admin/chk-info` 컨테이너를 디플로이먼트(Deployment)로 배포합니다. 배포된 디플로이먼트는 로드밸런서 서비스로 노출시킵니다.

```sh
k create deploy chk-info --image=sysnet4admin/chk-info
#
# deployment.apps/chk-info created
k expose deploy chk-info --type=LoadBa1ancer --port 80
#
# service/chk-info exposed
```

<!-- ![](https://wishket.com/media/news/3284/11.png) -->

배포가 완료되면, 파드(Pod)와 서비스 상태를 확인합니다.

```sh
k get po,svc
# 
# NAME                                         READY   STATUS    RESTARTS   AGE
# pod/chk-info-5df5b8ff74-96jzn                1/1     Running   0          26s
# pod/nfs-c1ient-provisioner-6ff67fc8f4-tkbf2  1/1     Running   0          10m
#
# NAME                 TYPE           CLUSTER-IP     EXTERNAL-IP    PORT(S)        AGE
# service/chk-info     LoadBalancer   10.104.129.5   192.168.1.11   80:31189/TCP   9s
# service/kubernetes   ClusterIP      10.96.0.1                     443/TCP        13m
```

<!-- ![](https://wishket.com/media/news/3284/12.png) -->

마지막으로, 웹 브라우저를 열고, 부여된 로드밸런서 IP(예: 192.168.1.11)를 입력합니다. 아래와 같은 화면이 나오면 성공입니다.

![](https://wishket.com/media/news/3284/image18.png)

이제 여러분도 arm64 환경에서 동작하는 쿠버네티스 클러스터를 가지게 되었습니다. 축하드립니다.

---

## 추가로 시도해 볼만한 작업: 헤드램프 설치

이렇게 구축한 나만의 쿠버네티스 클러스터 환경에서, 쿠버네티스를 더 손쉽게 사용할 목적으로 만들어지는 [헤드램프(Headlamp) (<FontIcon icon="iconfont icon-github"/>`kubernetes-sigs/headlamp`)](https://github.com/kubernetes-sigs/headlamp)라는 프로젝트를 설치해 보겠습니다.

![헤드램프 메인테이너 [Joaquim Rocha (<FontIcon icon="fa-brands fa-linkedin"/>`joaquimrocha`)](https://linkedin.com/in/joaquimrocha/)와 [필자 (<FontIcon icon="fa-brands fa-linkedin"/>``hoonjo`)](https://linkedin.com/in/hoonjo/)](https://wishket.com/media/news/3284/image18_bAsg1Zw.png)

실습할 수 있는 클러스터를 이미 구성했으므로, 헤드램프를 설치해 현재 클러스터 상태를 확인해 보겠습니다. 헤드램프를 설치하려면, **B/B.011**로 이동해야 합니다. 이어 `brew install` 명령어로 헤드램프 버전 **0.31.1**을 설치합니다.

```sh
cd ../../B.011/
brew install --cask ./headlamp-v0.31.1/headlamp.rb
#
# ==> Auto-updating Homebrew.
# Adjust how often this is run with HOMEBREW_AUTO UPDATE_SECS or disable with HOMEBREW NO_AUTO UPDATE. Hide these hints with HOMEBREW NO ENV HINTS (see `man brew`).
# ==> Auto-updated Homebrew!
# Updated 1 tap (homebrew/cask).
#
# You have 54 outdated formulae and 2 outdated casks installed.
#
# ==> Downloading https://github.com/headlamp-k8s/headlamp/releases/download/v0.31.1/Headlamp-0.31.1-mac-arm64.dmg
# ==> Downloading from https://objects.githubusercontent.com/github-production-release-asset-2e65be/220546758/8f3e9374-96de-46d6-a7
#
# ==> lnstalling Cask headlamp
# ==> Moving App 'Headlamp.app' to '/App1ications/Headlamp.app'
# 鬱 headlamp was successfully installed! 
```

<!-- ![](https://wishket.com/media/news/3284/13.png) -->

헤드램프를 실행하기 전에는, 로컬 환경의 쿠버네티스 클러스터 정보를 가져와야 합니다. <FontIcon icon="iconfont icon-shell"/>`flatted_kubeconfig.sh` 스크립트에 권한을 부여하고 실행하겠습니다.

```sh
chmod +ⅹ flatted kubeconfig.sh
sudo ./flatted kubeconfig.sh
#
# SuccessfuIIy flatten kubeconfig
```

<!-- ![](https://wishket.com/media/news/3284/14.png) -->

헤드램프를 실행하고, 표시되는 화면에서 `kubernetes-admin@kubernetes`를 클릭합니다.

![](https://wishket.com/media/news/3284/image28.jpg)

만약 “앱이 손상되어 열 수 없다”는 메시지가 뜨는 경우, `sudo xattr -rd com.apple.quarantine /Applications/Headlamp.app` 명령어로 실행 권한 문제를 해결합니다.

현재 상태를 확인하려면, 아래 화면에서 왼쪽 Map 메뉴를 누릅니다.

![](https://wishket.com/media/news/3284/image4.png)

이동으로 나타나는 화면에서 DaemonSet을 누릅니다.

![](https://wishket.com/media/news/3284/image1.png)

마지막으로 GUI에서 현재 배포된 DaemonSet의 구성을 확인합니다.

![](https://wishket.com/media/news/3284/image19.png)

---

## 마치며

이번 글에서는 베이그런트(Vagrant)와 버추얼박스(VirtualBox)를 활용해 **arm64 기반의 쿠버네티스 클러스터**를 손쉽게 구축해 보았습니다. 이렇게 구성한 전용 클러스터 환경에서 필요한 애플리케이션을 배포하고, 발생하는 다양한 문제를 직접 해결하는 과정은 실무 역량을 키우는 데 큰 도움을 줍니다.

구성한 쿠버네티스 클러스터를 기반으로 목적에 맞는 다양한 실습을 진행해 볼 수 있습니다. 목적에 맞게 자유롭게 사용하며 쿠버네티스 실력 향상에 도움이 되기를 바랍니다.

<!-- toDO: add ARTICLE CARD -->
```component VPCard
{
  "title": "새로 산 맥북으로 “더 쉽게” 쿠버네티스 클러스터 구성하기",
  "desc": "x86-64 환경만 지원하던 버추얼박스(VirtualBox)가 최근 arm64 기반 맥북을 제대로 지원하기 시작했습니다. 덕분에 현재는 VM웨어 퓨전 대신 버추얼박스로 쿠버네티스 클러스터를 구성할 수 있게 되었습니다. 이를 통해 기존의 불편함이 대부분 해소되었으며, 윈도와 맥OS 기반 환경 모두 동일한 코드로 배포와 실행을 할 수 있어졌습니다. 따라서 이번 글에서는 버추얼박스가 arm64를 지원하기까지의 과정을 살펴본 다음, 이를 활용한 쿠버네티스 클러스터 구성 방법을 소개하겠습니다.",
  "link": "https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3284.html",
  "logo": "https://yozm.wishket.com/fav1con.ico",
  "background": "rgba(84,7,224,0.2)"
}
```
