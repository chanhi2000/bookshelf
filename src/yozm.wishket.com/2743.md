---
lang: ko-KR
title: 개발자를 위한 ‘소프트웨어 아키텍처’ 개념과 활용법
description: Article(s) > 개발자를 위한 ‘소프트웨어 아키텍처’ 개념과 활용법
icon: fas fa-pen-ruler
category: 
  - Design
  - System
  - Java
  - Article(s)
tag: 
  - blog
  - yozm.wishket.com
  - system
  - design
  - java
head:
  - - meta:
    - property: og:title
      content: Article(s) > 개발자를 위한 ‘소프트웨어 아키텍처’ 개념과 활용법
    - property: og:description
      content: 개발자를 위한 ‘소프트웨어 아키텍처’ 개념과 활용법
    - property: og:url
      content: https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2743.html
prev: /academics/system-design/articles/README.md
date: 2024-09-03
isOriginal: false
cover: https://yozm.wishket.com/media/news/2743/sw__2_.png
---

# {{ $frontmatter.title }} 관련

```component VPCard
{
  "title": "System Design > Article(s)",
  "desc": "Article(s)",
  "link": "/academics/system-design/articles/README.md",
  "logo": "https://chanhi2000.github.io/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

```component VPCard
{
  "title": "Java > Article(s)",
  "desc": "Article(s)",
  "link": "/programming/java/articles/README.md",
  "logo": "https://chanhi2000.github.io/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

[[toc]]

---

<SiteInfo
  name="개발자를 위한 ‘소프트웨어 아키텍처’ 개념과 활용법 | 요즘IT"
  desc="소프트웨어 아키텍처는 시스템의 구조와 성능 및 신뢰도 등에 영향을 미치는 중요한 요소입니다. 개발자가 소프트웨어 아키텍처를 이해하면 코드를 더욱 체계적으로 작성할 수 있고, 장기적으로는 시스템 유지 보수와 확장을 용이하게 할 수 있습니다. 또한 소프트웨어 아키텍처는 개발자 개인의 역량과 커리어에도 영향을 줄 수 있습니다. 특히 시니어 개발자나 소프트웨어 아키텍트로 커리어를 발전시키고 싶다면, 소프트웨어 아키텍처에 대한 학습을 꾸준히 해야 합니다. 이번 글에서는 소프트웨어 아키텍처의 기본 개념과 주요 패턴을 정리해 보고, 개발 프로젝트에서 소프트웨어 아키텍처가 어떻게 활용되는지 살펴보겠습니다."
  url="https://yozm.wishket.com/magazine/detail/2743/"
  logo="https://yozm.wishket.com/favicon.ico"
  preview="https://yozm.wishket.com/media/news/2743/sw__2_.png"/>

소프트웨어 아키텍처는 시스템의 구조와 성능 및 신뢰도 등에 영향을 미치는 중요한 요소입니다. 개발자가 소프트웨어 아키텍처를 이해하면 코드를 더욱 체계적으로 작성할 수 있고, 장기적으로는 시스템 유지 보수와 확장을 용이하게 할 수 있습니다.

또한 소프트웨어 아키텍처는 개발자 개인의 역량과 커리어에도 영향을 줄 수 있습니다. 특히 **시니어 개발자**나 **소프트웨어 아키텍트**로 커리어를 발전시키고 싶다면, 소프트웨어 아키텍처에 대한 학습을 꾸준히 해야 합니다. 이번 글에서는 소프트웨어 아키텍처의 기본 개념과 주요 패턴을 정리해 보고, 개발 프로젝트에서 소프트웨어 아키텍처가 어떻게 활용되는지 살펴보겠습니다.

---

## 소프트웨어 아키텍처란?

### 1) 소프트웨어 아키텍처 정의

소프트웨어 아키텍처는 시스템의 **기본 구조**이며, 시스템을 구성하는 요소와 각 요소 간의 관계를 정의하는 일종의 청사진입니다. 소프트웨어 아키텍처는 시스템의 주요 속성을 결정하고, 개발 과정의 중요한 설계 결정을 통제하는 역할을 합니다. 아울러 시스템의 전반적인 틀을 제시하고, 각 이해관계자 사이의 의사소통을 돕는 도구가 되기도 하죠.

![소프트웨어 아키텍처 예시](https://yozm.wishket.com/media/news/2743/sw__1_.png)

### 2) 아키텍처와 설계의 차이점

소프트웨어 아키텍처와 소프트웨어 설계는 언뜻 비슷해 보이지만 엄연히 다른 개념입니다. 소프트웨어 아키텍처는 시스템의 **전체적인 구조**를 정의하고, 각 요소 간의 관계와 설계 지침을 세우는 데 초점을 둡니다. 반면 소프트웨어 설계는 **개별 구성 요소의 세부 구현**에 집중한다는 것에 차이가 있습니다.

즉, 소프트웨어 아키텍처는 시스템의 주요 구성 요소와 이들 간의 상호작용을 정의하고, 설계는 이러한 구성 요소들이 실제로 어떻게 구현될지 결정하는 역할을 합니다.

---

## 소프트웨어 아키텍처 원칙

소프트웨어 아키텍처 원칙은 소프트웨어 설계 및 구현 과정에서 발생하는 **복잡성을 관리**하고, **유지 보수와 확장을 용이**하게 해주는 지침을 말합니다. 소프트웨어 아키텍처 원칙에는 다양한 종류가 있지만, 기본적으로 관심사 분리, 모듈화, 추상화, 캡슐화 등을 들 수 있습니다.

### 1) 관심사 분리와 모듈화

**관심사 분리(Separation of Concerns)**는 소프트웨어 시스템을 독립된 부분으로 나누어 각 부분이 특정 관심사에만 집중하도록 하는 설계 원칙을 말합니다. 예를 들어, UI 로직과 비즈니스 로직을 분리하거나, 환경 설정과 애플리케이션 코드를 분리하는 등 다양한 방식으로 적용될 수 있습니다. 이러한 관심사 분리를 효과적으로 구현하는 방법의 하나로 모듈화가 있습니다.

![관심사 분리와 모듈화 예시 <br/><출처: [<FontIcon icon="fa-brands fa-dev"/>dev.to](https://dev.to/suspir0n/soc-separation-of-concerns-5ak7)>](https://yozm.wishket.com/media/news/2743/sw__2_.png)

**모듈화(Modularity)**는 시스템을 여러 모듈로 분할하고, 각 모듈이 특정 기능을 담당하도록 하는 방식입니다. 전자상거래 시스템에서 제품 관리, 주문 처리, 결제 등을 각각의 모듈로 구분하는 것을 예로 들 수 있는데요. 각 모듈은 독립적으로 개발, 테스트, 배포될 수 있고, 시스템 복잡성을 최소화할 수 있습니다. 이러한 모듈화가 효과적이려면 모듈 간의 결합도는 낮추고, 각 모듈 내부의 응집도는 높여야 합니다. 이를 느슨한 결합(Loose Coupling)과 높은 응집도(High Cohesion) 원칙이라고 합니다.

![느슨한 결합과 높은 응집도 <br/><출처: [<FontIcon icon="fa-brands fa-medium"/>미디엄](https://medium.com/@onuryanar/separation-of-concerns-eca786e75f5a)>](https://yozm.wishket.com/media/news/2743/sw__3_.png)

**느슨한 결합**은 모듈 간의 의존성(dependency)을 낮춰 각 모듈을 독립적으로 변경할 수 있도록 하는 원칙입니다. 예를 들어, 주문 처리 모듈이 결제 모듈과 느슨하게 연결되어 있다면, 결제 방식이 바뀌어도 주문 처리 모듈은 영향을 받지 않습니다.

반면 **높은 응집도**는 모듈 내부 요소들이 밀접하게 결합되어, 해당 모듈의 기능이 일관성 있게 수행하도록 하는 원칙입니다. 결제 모듈 내 모든 클래스와 함수가 결제 처리 작업에만 집중하도록 하는 것을 예로 들 수 있습니다.

### 2) 추상화와 캡슐화

**추상화(Abstraction)**는 복잡한 시스템을 이해하기 쉽도록 세부 사항을 감추고 중요한 개념만 드러내는 원칙을 말합니다. 즉, 추상화는 구체적인 구현을 감추고, 표준화된 방법으로 시스템의 각 요소가 상호 작용할 수 있게 합니다.

예를 들어, 자동차를 운전할 때 운전자는 엔진의 작동 방식을 모두 알 필요 없이 운전대와 페달만 사용하면 됩니다. 이처럼 추상화를 활용하면 개발자는 복잡한 시스템의 모든 동작 방식을 알 필요가 없으며, 당장 구현해야 하는 기능에만 집중할 수 있습니다. 이러한 추상화를 구현하기 위해서는 보통 인터페이스나 추상 클래스를 이용합니다.

![추상화 구현 예시](https://yozm.wishket.com/media/news/2743/sw__4_.png)

**캡슐화(Encapsulation)**는 객체의 내부 상태를 숨기고, 외부에서 접근할 수 있는 인터페이스를 통해서만 상호 작용하도록 하는 원칙입니다. 예를 들어, 은행 계좌 클래스에서 잔액(balance) 변수는 private으로 선언하고, 입금(deposit)과 출금(withdraw) 메서드를 통해서만 변경할 수 있도록 합니다.

이를 통해 잔액 변수에 대한 직접적인 접근을 방지하고, 입금과 출금 시 필요한 검증 로직을 추가할 수 있습니다. 이처럼 개발자는 캡슐화 원칙을 적용하여 데이터 무결성을 보장하고, 시스템의 복잡성을 전반적으로 낮출 수 있습니다.

![캡슐화 구현 예시](https://yozm.wishket.com/media/news/2743/sw__5_.png)
<!-- TODO: Google Lens -->

---

## 주요 소프트웨어 아키텍처 패턴

### 1) 레이어드 아키텍처(Layered Architecture)

레이어드 아키텍처는 소프트웨어 시스템을 여러 계층으로 분리해, 각 계층이 특정 역할을 담당하게 하는 구조입니다. 각 계층은 자신보다 아래에 있는 계층에만 의존하며, 위쪽 계층과의 의존성은 없습니다. 즉, **단방향 의존성**을 갖는다는 것이 레이어드 아키텍처의 핵심입니다.

예를 들어, 일반적인 4-tier 레이어드 아키텍처의 구조는 프레젠테이션, 비즈니스, 퍼시스턴스, 데이터 계층으로 구성되며, 한 방향으로만 요청이 전달됩니다.

![레이어드 아키텍처 개요](https://yozm.wishket.com/media/news/2743/sw__6_.png)

프레젠테이션 계층(Presentation Layer)은 사용자 인터페이스(UI)를 담당하며 사용자로부터 입력을 받아들입니다. 비즈니스 계층(Business Layer)은 주문 처리와 같은 핵심 비즈니스 로직을 처리하며, 퍼시스턴스 계층(Persistence Layer)은 데이터베이스와의 연결을 담당합니다. 데이터 계층(Database Layer)은 보통 실제 데이터베이스를 말합니다. 이처럼 레이어드 아키텍처 패턴을 적용하면 각 계층의 역할과 책임을 명확히 하여, 시스템에 대한 이해와 유지보수를 쉽게 할 수 있습니다.

### 2) 모놀리식 아키텍처(Monolithic Architecture)

모놀리식(Monolithic)이란 영어로 **하나의 덩어리**를 의미합니다. 따라서 모놀리식 아키텍처는 한 코드베이스에 여러 기능을 통합하여, 하나의 코드 덩어리를 개발하는 아키텍처 패턴을 말합니다. 이 아키텍처의 장점은 구조가 단순하고, 소프트웨어 제품을 빠르게 출시해야 개발 초기에 이점이 있다는 것입니다. 단, 점차 코드 규모가 커지면 유지보수와 확장이 어려울 수 있다는 단점이 있습니다.

![모놀리식 아키텍처 개요](https://yozm.wishket.com/media/news/2743/sw__7_.png)

대체로 모놀리식 아키텍처에서는 애플리케이션 내 모든 모듈이 긴밀하게 결합되어 하나의 실행 파일로 배포됩니다. 즉, 여러 모듈이 강한 의존성으로 결합되어 있기 때문에 작은 변경에도 전체 시스템을 다시 빌드하고, 배포해야 하는 문제가 생길 수 있습니다. 그러나 앞서 말했듯이 모놀리식 아키텍처는 스타트업이나 규모가 작은 애플리케이션 개발에서 효율적인 방식으로 활용되기도 합니다. 참고로, 기존의 모놀리식 아키텍처의 단점을 보완한 모듈식 모놀리식 아키텍처도 있습니다.

### 3) 마이크로서비스 아키텍처(Microservices Architecture)

마이크로서비스 아키텍처는 애플리케이션을 **작은 독립적인 서비스**로 나누어, 각각 특정 비즈니스 기능을 수행하도록 설계한 아키텍처 패턴입니다. 각 서비스는 독립적으로 배포되고 자체적인 데이터 저장소를 가질 수 있으며, 다른 서비스와 통신할 때 HTTP나 gRPC와 같은 표준 프로토콜을 사용합니다.

![마이크로서비스 아키텍처 개요](https://yozm.wishket.com/media/news/2743/sw__8_.png)

예를 들어, 전자상거래 애플리케이션에서 인증, 결제, 주문, 재고 처리 등을 각각의 마이크로서비스로 나눌 수 있습니다. 이러한 구조는 시스템의 확장성과 유연성을 크게 향상시키며, 특정 서비스의 변경이 다른 서비스에 미치는 영향을 최소화합니다.

또한 각 서비스가 독립적으로 배포될 수 있기 때문에 대규모 시스템 개발에 적합하며, 서비스별로 다양한 기술 스택을 사용할 수 있어, 각 서비스에 적합한 최적의 기술을 선택할 수 있다는 장점이 있습니다. 다만 마이크로 서비스 간 통신 관리, 데이터 일관성 유지, 분산 시스템 디버깅 문제 등 새로운 복잡성을 일으킬 수 있다는 단점이 있습니다.

### 4) 마이크로커널 아키텍처(Microkernel Architecture)

마이크로커널 아키텍처는 시스템의 **핵심 기능**을 하나의 컴포넌트로 분리하고, 이후 추가되는 **확장 기능**을 플러그인이나 애드온으로 구현하는 패턴입니다. 이 패턴의 주요 목표는 시스템의 유연성과 확장성을 극대화하는 것입니다. 예를 들어, VS Code나 IntelliJ 같은 IDE는 핵심 기능이 내장된 상태에서, 새롭게 추가되는 기능은 플러그인 같은 외부 모듈로 확장할 수 있습니다.

![마이크로커널 아키텍처 개요](https://yozm.wishket.com/media/news/2743/sw__9_.png)

마이크로커널 아키텍처는 시스템의 핵심 부분을 안정적으로 유지하면서도 새로운 기능을 쉽게 추가할 수 있다는 장점이 있습니다. 이는 사용자 정의가 많이 필요한 애플리케이션이나, 소프트웨어 제품 라인에 특히 유용합니다. 그러나 시스템이 복잡해질수록 플러그인 간 의존성 관리와 버전 호환성 유지가 어렵다는 단점이 있습니다.

### 5) 이벤트 주도 아키텍처(Event-Driven Architecture)

이벤트 주도 아키텍처(EDA)란 시스템 구성 요소가 **이벤트를 통해 상호 작용**하도록 설계한 아키텍처 패턴을 말합니다. EDA에는 이벤트 생산자(Event Producer)와 이벤트 소비자(Event Consumer)가 있으며, 이벤트 대기열(Event Queue)을 관리하는 이벤트 중재자(Event Meditator)를 통해 비동기적으로 통신합니다. 이처럼 비동기 통신을 통해 시스템은 느슨하게 결합되며, 높은 확장성과 실시간 데이터 처리 능력을 갖출 수 있습니다.

![이벤트 주도 아키텍처 개요](https://yozm.wishket.com/media/news/2743/sw__10_.png)

전자상거래 시스템 주문 처리 과정을 예로 들면, 사용자가 주문을 생성하면 주문 서비스는 주문 생성 이벤트를 발생시키고, 이 이벤트는 이벤트 중재자를 통해 결제 서비스로 전달됩니다. 그리고 결제 서비스가 이를 처리하고 결제 완료 이벤트를 발생시키면, 다시 재고 관리 서비스로 이벤트가 전달되어 재고를 업데이트하는 식입니다. 이처럼 이벤트 주도 아키텍처는 각 모듈이 느슨하게 결합되어 있어 시스템 확장에 유리하지만, 이벤트 순서와 일관성 관리, 디버깅 문제 등의 과제가 있습니다.

---

## 개발에서의 소프트웨어 아키텍처 활용

### 1) 프로젝트 시작 시 아키텍처 결정 과정

프로젝트 시작 시 아키텍처 결정은 성공적인 소프트웨어 개발을 위한 중요한 과정입니다. 먼저 프로젝트 요구사항을 분석하여, **시스템이 해결해야 할 문제와 기능**을 명확히 정의합니다. 그런 다음, 앞서 정의된 내용을 기반으로 시스템의 주요 품질 속성(성능, 보안, 확장성, 유지 보수성 등)을 식별하고 우선순위를 정합니다. 이를 통해 시스템의 **핵심 목표와 제약 조건**을 설정할 수 있습니다.

![소프트웨어 아키텍처 결정 과정](https://yozm.wishket.com/media/news/2743/sw__11_.png)

이후 다양한 아키텍처 패턴을 검토하여 프로젝트에 가장 **적합한 아키텍처를 선택**합니다. 예를 들어, 빠른 시스템 구축이 중요하다면 모놀리식 아키텍처를 선택할 수 있고, 시스템의 확장성이 중요하다면 마이크로서비스나 이벤트 주도 아키텍처를 선택할 수 있습니다.

이렇게 선택된 아키텍처 방식에 따라 시스템의 **모듈과 컴포넌트를 정의**하고, 이들 간의 관계와 의존성을 설계합니다. 아울러 초기 프로토타입을 통해 아키텍처의 적합성을 검증하고, 필요한 경우 **피드백을 반영**하여 아키텍처를 조정해 나갑니다.

### 2) 소프트웨어 아키텍처 문서화 방법

소프트웨어 아키텍처 문서는 개발팀 간의 이해를 높이고, 프로젝트의 일관성과 품질을 보장하기 위한 중요한 자료입니다. 소프트웨어 아키텍처 문서에는 아키텍처 다이어그램, 데이터 흐름 다이어그램, 컴포넌트 다이어그램 등이 있으며, 주로 시스템의 주요 구성 요소와 이들 간의 관계를 **시각화**하고 데이터 흐름을 명확히 하는 데 사용됩니다.

![소프트웨어 아키텍처 다이어그램 예시 <br/><출처: [<FontIcon icon="fas fa-globe"/>edrawsoft](https://edrawsoft.com/software-architecture.html)>](https://yozm.wishket.com/media/news/2743/sw__12_.png)

또한**아키텍처 결정 기록**(Architecture Decision Records, ADR)을 작성하면, 아키텍처에 대한 중요한 설계 결정과 그 이유를 체계적으로 문서화할 수 있습니다. ADR에는 시스템의 품질 속성, 설계 원칙, 사용된 패턴 등이 포함되며, 프로젝트 진행 중 발생하는 아키텍처 변경에 대한 이력을 남겨 팀원 간 시스템에 대한 일관된 이해를 유지할 수 있습니다.

![ADR 템플릿 자료 <br/><출처: [github (<FontIcon icon="iconfont icon-github"/>`joelparkerhenderson/architecture-decision-record`)](https://github.com/joelparkerhenderson/architecture-decision-record?tab=readme-ov-file)>](https://yozm.wishket.com/media/news/2743/sw__13_.png)

### 3) 커뮤니케이션과 리팩토링에 활용

개발 프로젝트에서 소프트웨어 아키텍처는 **중요한 커뮤니케이션 도구**가 됩니다. 앞서 살펴본 아키텍처 문서를 통해 시스템이 구체적으로 어떻게 개발되고, 유지 보수되어야 하는지 방향을 설정할 수 있습니다. 또한 개발 속도, 시스템 안정성, 보안 수준 등 서로 상충할 수 있는 가치에 대한 의사 결정에 활용할 수 있죠. 아울러 새로운 팀원이 프로젝트에 참여할 때 유용한 참고 자료가 되어, 빠른 적응을 도울 수 있습니다.

또한 소프트웨어 아키텍처는 실제 구현이 시스템 목표와 일치하는지 정기적으로 검토하고, 리팩토링을 통해 코드 구조를 점진적으로 개선하기 위한 기준으로도 활용할 수 있습니다. 이러한 리팩토링 작업에는 주로 코드의 중복 제거, 성능 최적화, 추상화 수준 향상, 의존성 관리, 보안 강화 등이 포함됩니다.

---

## 마치며

지금까지 소프트웨어 아키텍처와 관련하여 개발자가 알아야 하는 기초적인 내용과 활용에 대해서 살펴봤습니다. 개발자가 소프트웨어 아키텍처를 이해하면, 복잡한 시스템 구조를 효과적으로 이해하고 개발 프로젝트를 진행할 수 있습니다. 따라서 **주요 소프트웨어 아키텍처 패턴과** **설계 원칙을 학습**하고, 실제 다양한 프로젝트에서 경험해 보는 것이 중요합니다. 이러한 노력과 경험이 쌓이면 한 단계 더 높은 수준의 개발자로 성장할 수 있을 것이라 생각합니다.

