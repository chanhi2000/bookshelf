---
lang: ko-KR
title: 개발자를 위한 ‘프롬프트 엔지니어링’ 시작하기
description: Article(s) > 개발자를 위한 ‘프롬프트 엔지니어링’ 시작하기
icon: fas fa-language
category: 
  - AI
  - LLM
  - Article(s)
tag: 
  - blog
  - yozm.wishket.com
  - ai
  - artificial-intelligence
  - llm
  - large-language-model
  - prompt-engineering
head:
  - - meta:
    - property: og:title
      content: Article(s) > 개발자를 위한 ‘프롬프트 엔지니어링’ 시작하기
    - property: og:description
      content: 개발자를 위한 ‘프롬프트 엔지니어링’ 시작하기
    - property: og:url
      content: https://chanhi2000.github.io/bookshelf/yozm.wishket.com/2701.html
prev: /ai/llm/articles/README.md
date: 2024-08-03
isOriginal: false
cover: https://yozm.wishket.com/media/news/2701/Professional_Cat_Prompt_Engineering.png
---

# {{ $frontmatter.title }} 관련

```component VPCard
{
  "title": "LLM > Article(s)",
  "desc": "Article(s)",
  "link": "/ai/llm/articles/README.md",
  "logo": "https://chanhi2000.github.io/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

[[toc]]

---

<SiteInfo
  name="개발자를 위한 ‘프롬프트 엔지니어링’ 시작하기 | 요즘IT"
  desc="일반적으로 프롬프트는 ‘지시한다’, ‘말을 전한다’라는 뜻을 가지고 있습니다. LLM(Large Language Models)에서 프롬프트는 AI 모델에게 내리는 지시 사항 혹은 첫 대화의 물꼬를 뜻하는데요. 프롬프트를 설계하는 기술을 ‘프롬프트 엔지니어링(Prompt Engineering)’이라고 합니다. 프롬프트 엔지니어링은 AI 모델에게 특정 상황과 요구사항을 잘 지시하여, 기대하는 결과물을 만들게 하는 새로운 방식의 코딩입니다. 마치 우리가 프로그래밍 언어로 컴퓨터가 할 일을 로직으로 풀어내듯, 프롬프트에 자연어로 할 일을 지시하는 겁니다."
  url="https://yozm.wishket.com/magazine/detail/2701/"
  logo="https://yozm.wishket.com/favicon.ico"
  preview="https://yozm.wishket.com/media/news/2701/Professional_Cat_Prompt_Engineering.png"/>

챗GPT가 처음 공개되었을 때 많은 사람들이 깜짝 놀랐습니다. 항상 적절한 검색어를 먼저 떠올리고 수많은 결과에서 내가 원하는 것을 찾아 다시 브라우징하던 기존 방식과 달리, 마치 채팅하듯 자연어로 질문하면 답을 제공해 주었습니다. 금방이라도 모든 검색을 다 대체할 수 있을 것 같았죠. 하지만 틀린 답을 그럴싸하게 말하거나, 엉뚱한 답을 내놓기도 합니다. 도대체 왜 그러는 걸까요?

여기엔 편향된 학습 데이터, 과적합 같은 여러 이유가 있지만, 물어보는 사람이 질문의 컨텍스트를 완벽하게 전달하지 못해서 발생하는 경우도 많습니다. 그렇다면 이러한 딴소리 현상을 방지하려면 어떻게 해야 할까요? 그 실마리는 바로 프롬프트(Prompt)에 있습니다.

일반적으로 프롬프트는 ‘지시한다’, ‘말을 전한다’라는 뜻을 가지고 있습니다. LLM(Large Language Models)에서 프롬프트는 AI 모델에게 내리는 지시 사항 혹은 첫 대화의 물꼬를 뜻하는데요. 프롬프트를 설계하는 기술을 ‘프롬프트 엔지니어링(Prompt Engineering)’이라고 합니다. 프롬프트 엔지니어링은 AI 모델에게 특정 상황과 요구사항을 잘 지시하여, 기대하는 결과물을 만들게 하는 새로운 방식의 코딩입니다. 마치 우리가 프로그래밍 언어로 컴퓨터가 할 일을 로직으로 풀어내듯, 프롬프트에 자연어로 할 일을 지시하는 겁니다. 이번 글에서는 개발자를 위한 프롬프트 엔지니어링에 대해 살펴보고자 합니다.

---

## 1. 프롬프트 엔지니어링의 중요성

프롬프트 엔지니어링이 점점 더 중요해지는 이유는 뭘까요? 첫째, 품질 일관성을 유지할 수 있기 때문입니다. 일상에서 누군가에게 일을 부탁할 때, 애매하게 지시하면 기대한 결과물을 받기 어렵듯, AI 모델에게 상세하고 정확하게 지시해야 결과물을 기대한 품질로 받을 수 있습니다.

다음은 보안/윤리적 이슈입니다. LLM은 그야말로 방대한 지식을 학습했고, 질문에 따라서 그 대답이 변하곤 합니다. AI의 윤리적 문제에 대한 논란은 늘 끊이질 않죠. 이러한 문제는 AI의 학습 단계에서 방어할 수 있지만 유해하거나 오해의 소지가 있는, 혹은 편향적인 콘텐츠를 생성하지 않도록 프롬프트로 제어할 수도 있습니다. 마지막으로는 토큰(Token)의 경제성입니다. 토큰은 LLM이 인식하는 문자 데이터 단위를 말하는데요, 토큰 수에 따라 LLM이 얼마나 더 많은 컨텍스트를 이해하고 결과물을 만들어낼 수 있는지가 좌지우지됩니다. 이 프롬프팅을 잘 세팅해 두면 적은 인풋으로도 더 유용한 결과물을 생성해 낼 수 있습니다.

프롬프트 엔지니어링은 AI 모델의 잠재력을 극대화하고 원활한 사용자 경험을 보장하는 데 있어 중추적인 역할을 합니다. LLM이 더 많은 서비스에 사용되면 사용될수록 중요성은 더 커지고 더 많이 주목받을 것이라 예상됩니다. 그렇다면 어떻게 해야 더 나은 프롬프트 엔지니어링의 결과물을 얻을 수 있을까요?

---

## 2. 프롬프트 엔지니어링 4S 원칙

좋은 프롬프트 엔지니어링이란 어떤 것일까요? 좋은 프롬프트를 짜기 위한 4가지 원칙을 알아보겠습니다.

1. **Single**: 하나의 질문 혹은 작업에 집중하라.
2. **Specific**: 명확하고 상세하게 지시하라.
3. **Short**: 간결하게 핵심을 전달하라.
4. **Surround**: 주변 컨텍스트를 제공해서 질문의 상황을 잘 전달하라.

비단 프롬프트 엔지니어링에서 뿐만 아니라 문제를 단순화하고 집중해, 경쾌하고 짧게 해결해 나가는 방법은 모든 문제 해결을 관통하는 원칙이라 느껴집니다. 이제부터 4S 원칙대로 프롬프트를 작성하는 예시를 살펴보겠습니다.

### 2.1 답변 방식을 확실하게 정해주기

먼저 답변 방식을 확실하게 정하는 방법입니다. 4S 원칙에 맞게 질문을 해보겠습니다. JSON 생성 작업 하나(Single)만, JSON 형식을 명확(Specific)하게 알려주고, 불필요한 말 없이 짧게(Short), JSON이라는 표현으로 프로그래밍 관련 답변을 원한다는 컨텍스트(Surround)를 추가한 질문입니다.

![](https://yozm.wishket.com/media/news/2701/1.png)

이 질문에서는 JSON 형식으로 key는 언어, value는 번역된 문장으로 지시를 내리고 있습니다. 그냥 “번역해 주세요”라고 했으면 줄글이 나왔겠지만, JSON 형식 혹은 XML 형식처럼 구체적인 형식을 정확하게 전달하면 원하는 결과를 얻을 확률이 높아집니다. 4S를 항상 유념해서 질문하면 좋습니다.

### 2.2 구역을 확실히 잡아주기

다음은 구역을 확실하게 잡아주는 방법입니다. 여기 음식 주문을 받는 상황을 만들어 보았습니다.

![](https://yozm.wishket.com/media/news/2701/2.png)

만약 “메뉴 주문을 받아주세요”라고만 지시했다면 양식을 주문하든, 일식을 주문하든 모두 받아버리고 말 텐데요. 미리 메뉴를 지정해 구역을 잡아주면 엉뚱한 대답이 나오는 것을 방지할 수 있습니다. 환각이라고 불리는 생성형 AI의 ‘할루시네이션’은 위와 같이 정보의 범위를 만들어 방지할 수 있습니다.

### 2.3 다시 다시 그리고 다시 해보기

‘다시, 다시, 그리고 다시 해보기’는 중요합니다. 사람끼리의 대화에서 컨텍스트를 한 번에 다 전달한다는 것도 어렵고, 질문을 단번에 이해시키는 것도 어렵습니다.

![](https://yozm.wishket.com/media/news/2701/3.png)

AI 모델 역시 마찬가지입니다. 결과물이 나오긴 했지만 내 맘에 안 들 수도 있습니다. 어쩌면 프롬프트 엔지니어링에서는 인내심이 가장 중요할지도 모릅니다. 계속 AI 모델과 티키타카하며 결과물을 세심하게 잡아나가는 것, 그것이 프롬프트 엔지니어링인 것 같습니다.

이처럼 프롬프트 엔지니어링의 중요성이 높아지면서 연구가 이뤄지고, 논문 역시 많이 나오고 있습니다. 다음으론 고급 프롬프트 엔지니어링 기법을 살펴보고, 체계적인 프롬프트 방법을 배워보겠습니다.

---

## 3. 반드시 알아둬야 할 프롬프팅 테크닉

프롬프트 엔지니어링의 중요성이 날로 높아짐에 따라 관심도 늘고 있습니다. 프롬프트 엔지니어링과 관련해 수많은 연구들이 진행되고, 이를 더 정교하게 다듬는 학습 기법도 계속 발표되고 있습니다. 기존에는 ML 모델을 만들려면 모델을 학습시킬 데이터를 준비하고, 파라미터를 조정하고, 파인튜닝과 트레이닝이라는 학습 과정을 거쳐야 했습니다.

반면 LLM에서는 별도 데이터를 많이 제공하지 않고도, 약간의 정보를 프롬프트에 전달하는 것만으로 모델을 학습시킬 수 있습니다. 즉, 손쉽게 학습시켜 원하는 결과물을 뽑아낼 수 있게 된 겁니다. 이때 반드시 알아둬야 할 프롬프팅 기법을 알아보겠습니다.

### 3.1 zero-shot prompting

zero-shot prompting은 우리말로 제로샷 프롬프팅으로 부릅니다. 별다른 정보나 컨텍스트 전달 없이 지시를 내리는 방법입니다. LLM의 위력을 느낄 수 있는 방법이라 할 수 있습니다. 예를 들어, 간단한 번역, 지식 설명은 별다른 데이터를 입력하지 않아도 됩니다.

![](https://yozm.wishket.com/media/news/2701/4.png)

### 3.2 one-shot prompting

다음은 one-shot prompting입니다. 우리말로는 원샷 프롬프팅이라고 합니다. 기대하는 결과물에 대한 예시 하나를 제시해 컨텍스트를 넘겨주는 방법입니다. 예를 들어, 기대하는 결과물의 예시가 JSON 형식이라면 JSON 형식의 예시를 제공하는 겁니다.

![](https://yozm.wishket.com/media/news/2701/5.png)

### 3.3 few-shot prompting

few-shot prompting은 퓨샷 프롬프팅이라고 읽습니다. 예시를 두 개 이상 전달해, 답변을 더 세밀하게 조정하고 답변의 일관성을 올려주는 기법입니다. 더 많은 컨텍스트를 전달했으니 당연한 결과겠죠? 예를 들어, 5월의 마지막 날을 묻는 방법으로 1월부터 4월까지 마지막 날을 제공해 줄 수 있습니다.

![](https://yozm.wishket.com/media/news/2701/6.png)

위 예시와 같이 수학 추론이 필요한 문제의 경우, 여러 예시가 있음에도 틀린 답을 만드는 모습을 볼 수 있습니다. 이러한 작업은 이어서 설명할 CoT(Chain of Thought가 더 적절합니다.

### 3.4 Chain of Thought(CoT)

COT는 Chain of thought의 준말로 우리말로 생각의 사슬이라고 번역할 수 있습니다. 앞서 살펴보았던 것처럼, 추론에 있어서도 추론 방법의 예시를 전달하게 되면 더 좋은 응답을 받아 볼 수 있습니다.

다음은 일반적인 프롬프팅 방법으로 수학 질문 2개 넘기고 그 첫 번째 문제의 답만 주고, 두 번째 수학 문제에 대한 답을 달라고 요청해 보았습니다. 아쉽게도 답이 틀렸습니다.

![](https://yozm.wishket.com/media/news/2701/7.png)

이번에는 CoT 프롬프팅 방법으로 첫 번째 수학 질문을 어떠한 추론 방법을 통해 답을 얻었는지를 상세히 전달했습니다.

![](https://yozm.wishket.com/media/news/2701/8.png)

테니스공 다섯 개를 가지고 시작, 두 번째 단계에서는 테니스공 3개가 들어 있는 캔 2개를 먼저 계산해 6개가 있다고 확인하고, 그다음 5 + 6을 계산해 11이라는 답이 나왔다. 이렇게 단계별로 문제를 푼 모습을 보여주자, 모델의 아웃풋 역시 추론의 과정이 더 깊어져 정답을 말하는 모습을 볼 수 있습니다.

### 3.5 zero-shot CoT

다음으로 한 단계씩 생각해 보라고 지시하는 기법을 zero-shot CoT라고 합니다. 사람도 한 번에 모든 문제를 풀려고 하면 중간에 꼬이기도 하는데요. AI도 마찬가지입니다. 하나씩 실타래를 풀어가듯 문제를 풀다 보면 정답에 가까워질 수 있습니다.

간단한 수학 추론 문제를 내보겠습니다. 지금 내 나이가 10살이고 5년 후 동생과의 나이 차이를 조건으로 주어, 지금 동생의 나이를 찾는 수학 문제입니다. 그러자 동생 나이를 13살로 현재 내 나이보다 많은 답을 주었습니다.

![](https://yozm.wishket.com/media/news/2701/9.png)

여기서 그냥 문제를 푸는 것이 아닌 한 단계씩 한 단계씩 추론의 과정을 밟도록, “나는 지금 10살이고 5년이 지나면 내 동생은 내 나이의 4/5가 될 거야. 내 동생의 현재 나이는? 한 단계씩 생각해 봐”라고 지시하겠습니다. 이번에는 단계별 추론하는 모습을 볼 수 있습니다.

![](https://yozm.wishket.com/media/news/2701/10.png)

### 3.6 Tree of Thought(ToT)

Tree of Thought는 사고의 트리라고도 불립니다. 문제 중심에서 시작해 연관된 여러 아이디어를 나뭇가지처럼 확장해 나가는 방법입니다. 이를 통해 문제를 다방면으로 바라보고, 체계적으로 분석해 다양한 가능성 탐색할 수 있습니다.

우리도 문제를 풀다가 ‘어, 이 방법이 아니네?’ 하면서 다른 방법을 찾기도 하고, 또 다른 사람의 의견을 받아들여 방향을 바꾸기도 합니다. 또 여러 의견을 받은 다음에 다수 의견을 채택하는 방법 등 여러 가능성을 열고 답을 찾아 나가곤 합니다. AI 모델에게도 가상의 전문가들을 세팅하고, 각 관점에서 문제를 풀어 그 안에서 답을 채택하도록 하면 다음과 같이 여러 접근으로 추론해 나가게 됩니다.

![](https://yozm.wishket.com/media/news/2701/11.png)

모든 전문가가 동일한 결론에 도달했습니다. 동생의 현재 나이는 7살입니다. 각 전문가는 다른 방법을 사용했지만, 그들의 결론은 일치합니다. 따라서 이 문제에 대한 답은 동생이 현재 7살이라는 것입니다.

### 3.7 ReAct

ReAct는 Reason과 Act, 즉 원인을 분석하고 행동하는 방법입니다. 실행 계획을 유도하고 추적해서 작업별로 실행할 액션을 선택하고 실행하는 방법입니다.

![](https://yozm.wishket.com/media/news/2701/12.png)

처음에는 Apple Remote가 뭔지 알아야겠다며 검색해 얻은 결과 안에서 다시 추론, 다시 검색하는 과정을 반복하고 있습니다. 마치 우리가 구글링에서 궁금증을 해결할 때처럼 작동하는 겁니다. 앞서 보았던 CoT와 비슷해 보이지만, Thought와 Action 즉, 생각을 먼저 계획하고 액션 과정을 추가해 더 나은 결과를 이끌어냅니다.

지금까지 프롬프트 엔지니어링이란 무엇인지, 프롬프트 엔지니어링의 중요성과 그 방법을 살펴보았는데요. 깃허브 코파일럿, 클로드, 챗GPT 등 선택지가 많아진 만큼, LLM을 코딩에 적절히 활용해 보시길 바랍니다.

![](https://yozm.wishket.com/media/news/2701/seojiyeon.jpg)

::: info

이 글은 골든래빗 출판사에서 출간된 책 <[<FontIcon icon="fas fa-globe"/>요즘 AI 페어 프로그래밍](https://goldenrabbit.co.kr/product/ai_pair/)>에서 발췌·편집한 글입니다. 원문은 [<FontIcon icon="fas fa-globe"/>여기](https://goldenrabbit.co.kr/2024/05/07/ai-%ec%bd%94%eb%94%a9-%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%a5%bc-%ec%9c%84%ed%95%9c-%ed%94%84%eb%a1%ac%ed%94%84%ed%8a%b8-%ec%97%94%ec%a7%80%eb%8b%88%ec%96%b4%eb%a7%81-%ec%8b%9c%ec%9e%91%ed%95%98%ea%b8%b0/)에서 볼 수 있습니다.

:::

