---
lang: ko-KR
title: "예약어가 되기까지: CPython 딥다이브"
description: "Article(s) > 예약어가 되기까지: CPython 딥다이브"
icon: fa-brands fa-python
category:
  - Python
  - Article(s)
tag:
  - blog
  - yozm.wishket.com
  - py
  - python
head:
  - - meta:
    - property: og:title
      content: "Article(s) > 예약어가 되기까지: CPython 딥다이브"
    - property: og:description
      content: "예약어가 되기까지: CPython 딥다이브"
    - property: og:url
      content: https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3560.html
prev: /programming/py/articles/README.md
date: 2026-01-21
isOriginal: false
author:
  - name: 파이썬 한국 사용자 모임
    url : https://yozm.wishket.com/magazine/@pythonkorea/
cover: https://yozm.wishket.com/media/news/3560/1.png
---

# {{ $frontmatter.title }} 관련

```component VPCard
{
  "title": "Python > Article(s)",
  "desc": "Article(s)",
  "link": "/programming/py/articles/README.md",
  "logo": "/images/ico-wind.svg",
  "background": "rgba(10,10,10,0.2)"
}
```

[[toc]]

---

<SiteInfo
  name="예약어가 되기까지: CPython 딥다이브"
  desc="이 글은 PyCon Korea 2025에서 진행된 <defer: print(title)> 세션을 정리한 내용입니다. Go의 defer라는 예약어를 Python에 구현하는 것을 주제로, 그 구현 과정을 따라가며 CPython의 내부 구조를 살펴봅니다. "
  url="https://yozm.wishket.com/magazine/detail/3560/"
  logo="https://yozm.wishket.com/favicon.ico"
  preview="https://yozm.wishket.com/media/news/3560/1.png"/>

이 글은 PyCon Korea 2025에서 진행된 `<defer: print(title)>` 세션을 정리한 내용입니다. Go의 defer라는 예약어를 Python에 구현하는 것을 주제로, 그 구현 과정을 따라가며 CPython의 내부 구조를 살펴봅니다. 발표 자료는 [<VPIcon icon="fas fa-globe"/>PyCon Korea 2025 공식 홈페이지](https://2025.pycon.kr/sessions)에서 확인할 수 있으며, 파이콘 한국 유튜브 채널을 통해 [<VPIcon icon="fa-brands fa-youtube"/>영상](https://youtu.be/elQvXbsKi3o)으로도 만나보실 수 있습니다. (모든 이미지의 출처는 발표자에게 있습니다.)

> **defer: print(title)**
> 
> 변도진, 오영기 개발자

PyCon2025에서 Go의 defer라는 예약어를 Python에 구현해 보는 주제로 발표했습니다. 이번 글에선 Cpython의 구조에 대해 더 자세히 살펴보고자 합니다.

이번에 구현해 볼 예약어는 `hello`입니다.

![](https://wishket.com/media/news/3560/1_3EBRoeg.png)

뒤 평가문을 기준으로 Hello, World! 를 출력하는 간단한 예약어 입니다. Python 3.13을 기준으로 합니다. [여기 (<VPIcon icon="iconfont icon-github" />`python/cpython`)](https://github.com/python/cpython/tree/3.13)를 참고하세요.

---

## Cpython

Cpython은 C로 구현한 Python의 공식 Interpreter입니다.

다른 Interpreter들

- PyPy(Python)
- Jython(Java)
- RustPython(Rust)

### 구조 살펴보기

![](https://wishket.com/media/news/3560/2_ryIFIpl.png)

Cpython의 실행은 크게 두 부분으로 나눌 수 있습니다.

1. Compile
2. Runtime

Compile은 Python 코드를 Interpreter(PVM)이 실행 가능한 언어로 변환하는 과정이며, 이는 세부적으로 Parsing과 Compile로 나뉩니다. Runtime은 Interpreter가 코드를 실행하는 과정입니다.

이 글에서는 Compile 과정을 중심으로 알아보겠습니다.

---

## Runtime

그 전에 Runtime 과정을 살펴보겠습니다.

### 구조 살펴보기

![](https://wishket.com/media/news/3560/3_FjBvupV.png)

Runtime의 구조는 위 그림처럼 축약할 수 있습니다.

### 주요 요소

Runtime의 주요 요소는 다음과 같습니다.

- `pyruntimestate`: `Include/internal/pycore_runtime.h`<br/>Runtime 본체
- `PyInterpreterState(_is)`: `Include/cpython/pycore_interp.h`<br/>코드 실행기
- `PyThreadState(_ts)`: `Include/internal/pystate.h`<br/>실행할 코드 작업
- `PyCodeObject`: `Include/cpython/code.h`<br/>compile된 코드 객체
- `PyFrameObject(_frame)`: `Include/internal/pycore_frame.h`<br/>PyCodeObject의 실행 인스턴스
- `_PyInterpreterFrame`: `Include/internal/pycore_frame.h`<br/>frame의 실행용 가벼운 인스턴스

여기서 Compile 과정에 대해 알아야 할 Code, Code와 연관된 Frame만 살펴보겠습니다.

### Code(PyCodeObject)

code는 실행 가능한 python 객체입니다. compile된 코드를 정보를 담고 있으며, 이는 독립적으로 실행 가능한 코드 단위로 생성됩니다.

```py
def f():
    pass
print(f.__code__)
```

<!-- ![](https://wishket.com/media/news/3560/4_5VRRgez.png) -->

::: tip 예시

```py
V = 10
def f(a):
    res = a + 10 + V
    return res

print(f.__code__.co_consts)   # 상수 목록
print(f.__code__.co_names)    # name 접근 변수 목록
print(f.__code__.co_varnames) # lo“l변수 접근 목록

print("--------bytecode 출력--------")
tog = True
for b in f.__code__.co_code:
    end = "\n" if (tog:=not tog) else " | "
    print(f"{bin(b)[2:].zfilt(8)} [{str(b).rjust(3)}]", end=end)
#
# (None, 10)
# ('V',)
# ('a', 'res')
# --------bytecode 출력--------
# 10010101 [149] | 00000000 [ 0]
# 01010101 [ 85] | 00000000 [ 0]
# 01010011 [ 83] | 00000001 [ 1]
# 00101101 [ 45] | 00000000 [ 0]
# 00000000 [  0] | 00000000 [ 0]
# 01011011 [ 91] | 00000000 [ 0]
# 00000000 [  0] | 00000000 [ 0]
# 00000000 [  0] | 00000000 [ 0]
# 00000000 [  0] | 00000000 [ 0]
# 00000000 [  0] | 00000000 [ 0]
# 00101101 [ 45] | 00000000 [ 0]
# 00000000 [  0] | 00000000 [ 0]
# 01101110 [110] | 00000001 [ 1]
# 01010101 [ 85] | 00000001 [ 1]
# 00100100 [ 36] | 00000000 [ 0]
```
<!-- ![](https://wishket.com/media/news/3560/5_61vWQ0w.png) -->

:::

### `Frame(PyFrameObject, _PyInterpreterFrame)`

`PyFrameObject`는 Python level에서 접근 가능한 객체입니다 `_PyInterpreterFrame`은 PVM에서 사용되는 경량 구조체입니다. 기본적으로 `_PyInterpreterFrame`을 사용하며, 필요할 때 `PyFrameObject`를 생성하여 사용합니다.

다음은 python에서의 frame 접근 예제입니다.

```py
import inspect

def foo():
    bar()

def bar():
    for frame_info in inspect.stack():
        print(f"{frame info.function} {frame info.lineno}")

foo()
#
# bar 7
# foo 4
# <module> 10
```
<!-- ![](https://wishket.com/media/news/3560/6_s1hjUVP.png) -->

이는 다음과 같이 풀이할 수 있습니다.

![](https://wishket.com/media/news/3560/7_vW1NK5H.png)

Cpython의 frame도 살펴봅시다.

![](https://wishket.com/media/news/3560/8_bEeprzg.png)

frame에는 localsplus라는 요소가 있습니다. 이는 실행 시 로컬 scope + stack입니다.

frame은 `eval_loop(_PyEval_EvalFrameDefault)`에 의해 실행됩니다.

- `_PyEval_EvalFrameDefault`: `Python.ceval.c`

---

## Python 문법 살펴보기

### Tokens

파이썬(python)에서 토큰(token)은 의미를 가진 최소 단위입니다. 파이썬의 토큰은 grammar/tokens에 저장되어 있고, token은 줄넘김을 의미하는 NEWLINE, 들여쓰기를 의미하는 INDENT, 각종 이름들(변수명, 함수명, 예약어 등)을 의미하는 NAME, 각종 연산자와 특수기호 등이 있습니다. (더 많은 토큰의 종류에 대해서는 [<VPIcon icon="fa-brands fa-python"/>문서](https://docs.python.org/3.14/library/token.html?utm_source=chatgpt.com)를 참고하세요.)

### 예약어

예약어란 컴퓨터 프로그래밍 언어에서 이미 문법적인 용도로 사용되고 있기 때문에, 식별자로 사용할 수 없는 단어를 말합니다. 예를 들면, if, while, for 등이 있습니다.

### python.gram

파이썬의 기본적인 문법은 Grammar/python.gram 파일에 저장되어 있습니다. python.gram에는 파이썬의 예약어들과 기본적인 문장 구조들의 규칙이 정의되어 있습니다. python.gram은 파서 표현식 문법(parsing expression grammar, 약칭 PEG)를 사용합니다. PEG에 대한 자세한 내용은 이 [글 (<VPIcon icon="fa-brands fa-medium" />`@gvanrossum_83706`)](https://medium.com/@gvanrossum_83706/peg-parsing-series-de5d41b2ed60)을 참고하세요.

이것은 python.gram에 적혀있는 파이썬의 while문에 관한 문법이고, 문법을 파이썬 스타일과 매칭시켜 보았을 때 다음과 같이 표현할 수 있습니다.

![](https://wishket.com/media/news/3560/9_KMIwOMl.png)

`while`문에는 다음과 같은 PEG의 표기법들이 사용되었습니다.

- 규칙 옆의 `[]` 안에는 리턴 타입을 표시합니다.
- invalid로 시작하는 규칙 이름은 구문 오류에 사용됩니다.
- `|`은 대안을 표현합니다.
- `[]`은 선택적인 부분을 표현합니다.
- `{}`로 값을 반환하는 부분을 표현합니다.
- `&&`는 다음 토큰을 파싱하였을 때 존재하지 않으면 즉시 `Error`를 발생시킵니다.

::: note

PEG의 더 많은 표기법은 [<VPIcon icon="fa-brands fa-python"/>링크](https://peps.python.org/pep-0617/#overview)를 참고하세요.

:::

`named_expression` 규칙에는 대입 표현식과 일반 표현식이 들어가 있습니다. 표현식(expression)은 하나 이상의 값으로 표현될 수 있는 코드를 말합니다.

![](https://wishket.com/media/news/3560/10_Jcsvz2j.png)

block에는 다음과 같이

1. 줄 바꿈 들여쓰기 후 문장들(statements) 또는
2. 단순문(`simple_stmts`)이 들어갈 수 있습니다.  

![](https://wishket.com/media/news/3560/11_Th3ar76.png)

![](https://wishket.com/media/news/3560/12_Q0mvTOs.png)

statement는 실행할 수 있는 최소 코드 단위이고, `simple_stmts`는 1줄로 나타낼 수 있는 모든 표현들을 뜻합니다.

### 새로운 예약어 정의

표현식이 참이면 Hello, world!를 출력하는 hello라는 예약어를 만든다고 하면, 이런 식으로 문법을 구성할 수 있습니다.

![](https://wishket.com/media/news/3560/13_DsLTQAd.png)

---

## parsing

### AST(abstract syntax tree)

AST란 소스 코드가 가지고 있는 구조를 트리 형태로 나타낸 것으로 구문 분석, 즉 뒤에 나올 토크나이저와 파서가 추구하는 최종 결과물입니다.

```py
def example(a: int):
    while a:
        a -= 1
        print(a)
```

<!-- ![](https://wishket.com/media/news/3560/14_YyuxhT2.png) -->

이것은 위에 있는 함수의 ast를 instaviz 라이브러리를 이용하여 시각화 한 자료입니다.

<!-- ![](https://wishket.com/media/news/3560/15_JGJp2A4.png) -->
<!-- TODO: meremaid화-->

AST를 만들기 위해서는 ASDL(abstract syntax description language) 파일에 ast node의 속성을 정의해 주어야 합니다. 아래에 있는 이미지는 python.asdl 파일에 정의되어 있는 while문입니다.

```c
While(expr test, stmt* body, stmt* orelse)
```
<!-- ![](https://wishket.com/media/news/3560/16_sI2M6ik.png) -->

```py
while <test>:
    <body>
<orelse>
```

<!-- ![](https://wishket.com/media/news/3560/17_szRSRXh.png) -->

### tokenizer

토크나이저(tokenizer)는 문장들을 토큰으로 변환시키는 역할을 합니다.

<!-- ![](https://wishket.com/media/news/3560/18_pjW1S7r.png) -->

```py
a = 'hi, token!"
print(a)
```

아래 출력 결과는 위의 소스 코드가 토큰으로 변환된 결과물을 tokenize 모듈을 통해서 출력한 것입니다.  

![](https://wishket.com/media/news/3560/19_DkLvi01.png)

### parser

파서(parser)는 토큰을 AST로 변환시키는 역할을 합니다.

---

## AST 노드 새로 정의 및 검증 추가

위에서 만들었던 예약어의 AST 노드를 정의한다고 하면,

```c
Hello(expr test)
```
<!-- ![](https://wishket.com/media/news/3560/20_Hi0SNYn.png) -->

다음과 같이 ASDL 파일에 정의하여 AST 노드를 만들 수 있습니다.

```c title="python/ast.c"
validate_stmt(struct validator *state, stmt_ty stmt) {
    // ...
    switch (stmt—>kind) {
        // ...
        // 추가한 코드
    case Hello_kind:
        ret = validate_expr(state, stmt->v.Hello.test, Load);
        break;
    }
    // ...
}
```

<!-- ![](https://wishket.com/media/news/3560/21.png) -->

그 후에 ast node에 올바른 정보가 들어있는지 검증하는 코드를 추가합니다.

---

## symtable

심볼 테이블(symtable)은 파이썬의 전역과 지역 식별자들을 저장하는 데이터 구조입니다. symtable은 ast 노드를 탐색하고 저장한 뒤, 컴파일러에 데이터를 제공하여 컴파일러가 알맞게 스코프를 결정하여 참조할 수 있게 해 줍니다.

### symtable에 Hello 저장

ast node를 새로 만들었기 때문에 symtable이 읽을 수 있도록 Hello 처리 코드를 추가합니다.

```c title="python/symtable.c"
symtable_visit_stmt(struct symtable *St, stmt_ty s) {
    // ...
    switch (s->kind) {
        // 추가한 코드
    case Hello_kind:
        VISIT(st, expr, s—>v.Hello.test);
        break;
    }
    // ...
}
```
<!-- ![](https://wishket.com/media/news/3560/22.png) -->

---

## Compile

컴파일은 ast를 bytecode로 변환하는 과정을 의미합니다. 이 과정을 맞는 것이 Compiler입니다.

### Compiler

Compiler는 컴파일 과정을 맡는 유닛입니다.

- `compiler`: `Python/compiler.c`<br/>전체 컴파일을 관장하는 유닛입니다.
- `compiler_unit`: `Python/compiler.c`<br/>스코프 단위의 Block을 컴파일하는 유닛입니다.

구조는 다음과 같습니다.

![](https://wishket.com/media/news/3560/23.png)

다음과 같이 동작합니다.

1. Compiler가 컴파일할 Block을 찾으면 `CompilerUnit`을 생성해 할당합니다.
2. `CompilerUnit`이 Block을 컴파일하여 Bytecode로 변환합니다.
3. 변환이 끝나면 Compiler는 `CompilerUnit`의 Bytecode를 assemble하여 `CodeObject`로 반환합니다.

### 구문의 컴파일

`while`의 컴파일 과정을 통해 구문이 어떻게 컴파일되는지 살펴봅시다.

```c :collapsed-lines
static int compiler_while(struct compiler *c, stmt_ty s)
{
    // 라벨 선언
    NEW_JUMP_TARGET_LABEL (c, loop);
    NEW_JUMP_TARGET_LABEL (c, body);
    NEW_JUMP_TARGET_LABEL (c, end);
    NEW_JUMP_TARGET_LABEL (c, anchor);

    // while 시작
    USE_LABEL(c, loop);

    // fblock 진입
    RETURN_IF_ERROR(compiler_push_fbIock(c, LOC(s), WHILE_LOOP, loop, end, NULL));
    RETURN_IF_ERROR(compiler_jump_if(c, LOC(s), s—>v.While.test, anchor, 0));

    // 반복문 시작점
    USE_LABEL(C, body) ;
    VISIT_SEQ(C, stmt, s->v.While.body) ;
    RETURN_IF_ERROR(compiIer—jump—if(c, LOC(s), s—>v.While.test, body,

    // fblock 탈출
    compiler_pop_fblock(c, WHILE_LOOP, loop) ;

    // else문 시작점
    USE_LABEL(C, anchor) ;
    if (s->v.While.orElse) {
        VISIT_SEQ(C, stmt, s->v.While.orElse) ;
    }
    
    // while 끝
    USE_LABEL(C, end) ;
    return SUCCESS;
}
```
<!-- ![](https://wishket.com/media/news/3560/24.png) -->

- Label: `Jump` 가능 지점 표시자
- Jump: 실행 위치 이동(goto)
- fblock: 제어 흐름이 중첩된 블록 구조를 추적하기 위한 스택 구조 (`continue`, `break` 같은 예약어를 위함)
- visit: AST의 Node를 방문하여 컴파일함

이를 보기 쉽게 Python 스타일로 표현하면 다음과 같습니다.

```py
# Label : loop

# ---------enter fblock---------
While <test> :
    # if test is False:
        # jump anchor

    # Label : body
    # compile(body)
    <body> :
        if continue:
            # jump loop
        if break:
            # jump end

    # if test is True:
        # jump b0dy

# ---------exit fblock---------

# Label : anchor

# if orelse:
    # compile(orelse)
    else:
        <orelse>

# Label : end
```
<!-- ![](https://wishket.com/media/news/3560/25.png) -->

---

## Bytecode

bytecode는 PVM(Interpreter)가 실행하는 명령어입니다. 이는 다음과 같은 구조를 가집니다.

![](https://wishket.com/media/news/3560/26.png)

- `oparg`: bytecode의 매개변수.
- `opcode`: bytecode의 명령어 번호
- `oparg`: bytecode의 매개변수.
- `opcode`: bytecode의 명령어 번호

### Bytecode 예제

`dis` 모듈을 사용하여 확인할 수 있습니다.

![](https://wishket.com/media/news/3560/27.png)

정리하면 다음과 같습니다.

![](https://wishket.com/media/news/3560/28.png)

그럼 흐름을 천천히 따라가 보겠습니다.

::: tabs

@tab:active 1. `RESUME`

frame에 진입하고 설정합니다.

@tab 2. `LOAD_FAST_LOAD_FAST (a, b)`

stack에 `a`, `b`를 push합니다.

![](https://wishket.com/media/news/3560/29.png)

@tab 3. `BINARY_OP (+)`

stack에 a, b를 pop 합니다. a + b의 결과(AB)를 stack의 push합니다.

![](https://wishket.com/media/news/3560/30.png)

@tab 4. `STORE_FAST (res)`

stack에 AB를 pop합니다. res에 저장합니다.

![](https://wishket.com/media/news/3560/31.png)

@tab 5. `LOAD_FAST (res)`

stack에 res를 push합니다.

![](https://wishket.com/media/news/3560/32.png)

@tab 6. `RETURN_VALUE`

stack에 res를 pop합니다. res를 반환합니다.

![](https://wishket.com/media/news/3560/32_1.png)

:::

### Bytecode 정의

이번엔 `BINARY_OP`를 예시로 볼게요.  

```c
macro(BINARY_OP) = _SPECIALIZE_BINARY_OP + _BINARY_OP;
// BINARV_OP = _SPECIALIZE_BINARY_OP(counter 사용) -> _BINARV_OP
// 최적화 시도 -> 정석
```
<!-- ![](https://wishket.com/media/news/3560/33.png) -->

이는 `BINARY_OP`를 정의한 것입니다. `_SPECIALIZE_BINARY_OP`는 최적화 경로의 엔트리이며, `_BINARY_OP`는 정석적인 경로입니다. 이는 uop(micro-instruction)의 조합으로 하나의 instruction를 구성한 것입니다.

- instruction : bytecode를 이루는 하나의 명령
- micro-instruction : instruction을 이루는 세부 명령

그럼 `_BINARY_OP`와 `_SPECIALIZE_BINARY_OP`를 살펴볼게요.

![](https://wishket.com/media/news/3560/34.png)

- `_BINARY_OP`: instruction 이름
- lhs, rhs: stack에서 pop해오는 input
- res: stack에 push하는 output
- op: uop 선언 문법
- inst: instruction 선언 문법

를 기준으로 input과 output을 구별합니다. `BINARY_OP`는 oparg에 맞는 연산을 호출하여 결과를 계산합니다. (오버헤드 큼 -> 계산 객체의 method call)

```c
specializing op(_SPECIALIZE_BINARY_OP, (counter/1, lhs, rhs -- lhs, rhs)) {
    #if ENABLE SPECIALIZATION
    // counter 확인
    if (ADAPTIVE_COUNTER_TRIGGERS(counter)) {
        next_instr = this_instr;
        // sepcialization -> BINARY_OP_ADD_INT 실행
        Py_Specialize_BinaryOp(Ihs, rhs, next_instr, oparg, LOCALS_ARRAY);
        DISPATCH_SAME_OPARG();
    }
    STAT_INC(BINARY_OP, deferred) ;
    ADVANCE_ADAPTIVE_COUNTER(this_instr[1].counter) ;
    #endif /* ENABLE_SPECIALIZATION */
    assert(NB_ADD <= oparg) ;
    assert(oparg <= NB INPLACE_XOR) ;
}
```
<!-- ![](https://wishket.com/media/news/3560/35.png) -->

- specializing: specializtion instruction 시작 지점
- `<name>`/`<num>` : inline cache 사용. `<num>`만큼의 cache 사용

![](https://wishket.com/media/news/3560/36.png)

inline cache의 counter를 가져와, 실행 횟수(cache hit)를 확인 후 조건을 충족하면 specializtion instruction으로 전환합니다.

```c
// BINARY_OP의 specialization instruction 목록
famiIy(BINARY_OP, INLINE_CACHE_ENTRIES_BINARY_OP) = {
    BINARY_OP_MULTIPLY_INT,
    BINARY_OP_ADD_INT,
    BINARY_OP_SUBTRACT_INT,
    BINARY_OP_MULTIPLY_FLOAT,
    BINARY_OP_ADD_FLOAT,
    BINARY_OP_SUBTRACT_FLOAT,
    BINARY_OP_ADD_UNICODE,
    // BINARV_OP_INPLACE_ADD_UNICODE, // See comments at that opcode.
}
```
<!-- ![](https://wishket.com/media/news/3560/37.png) -->

- `family`: `BINARY_OP`의 코드를 가지는 그룹 정의

```c
macro(BINARY_OP_ADD_INT) = 
    _GUARD_BOTH_INT + unused/1 + _BINARY_OP_ADD_INT;
// (_GUARD_BOTH_INT -> _BINARY_OP_ADD_INT) -> _BINARY_OP
// unused/1은 _SPECIALIZE_BINARY_OP가 사용하던 counter
```
<!-- ![](https://wishket.com/media/news/3560/38.png) -->

int + int일 때의 specialization instruction

```py
BINARY OP:
    _SPECIALIZE_BINARY_OP:
        GUARD_BOTH_INT
        BINARY_OP_ADD_INT
    _BINARY OP
```
<!-- ![](https://wishket.com/media/news/3560/39.png) -->

(전체 flow)

```c
// left, right가 int인지 확인
op(_GUARD_BOTH_INT, (left, right -- left, right)) {
    EXIT_IF(!PyLong_CheckExact(left));
    EXIT_IF(!PyLong_CheckExact(right));
}
```
<!-- ![](https://wishket.com/media/news/3560/40.png) -->

input이 int인지 확인합니다.

- `EXIT_IF`: 인자가 참일 시 해당 분기 종료
- `DEOPT_IF`: 인자가 참일 시 specialization instruction을 기본 instruction으로 되돌림

```c
// int + int 최적화
pure op(_BINARY_OP_ADD_INT, (left, right -- res)) {
    STAT_INC(BINARY_OP, hit);
    // 오버헤드 없이 int 덧셈
    res = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);
    _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free) ;
    _Py_DECREF_SPECIALIZED(Ieft, (destructor)PyObject_Free) ;
    ERROR_IF(res == NULL, error) ;
```
<!-- ![](https://wishket.com/media/news/3560/41.png) -->

이런 식으로 최적화가 이루어집니다.

- inline cache 부연 설명: bytecode에 각 instruction에 할당되어 있음, instruction과 cache를 합쳐 slot이라 합니다.

`LOAD_FAST_LOAD_FAST` 같은 super-instruction도 있습니다.

- super-instruction : instruction 여러 개 합친 기능(최적화)<br/>`LOAD_FAST_LOAD_FAST` -> LOAD_FAST 2개

::: tip 예시

![](https://wishket.com/media/news/3560/41-1.png)

dis의 adaptive와 show_caches를 켜서 specialization instruction이 작동하는 것과 cache의 counter가 변하는 것을 확인할 수 있습니다.

:::

---

## Hello 구현하기

### Bytecode

이번엔 hello의 bytecode, `SAY_HELLO`를 만들어 보겠습니다. `SAY_HELLO`는 평가 시 `Hello, World!\n`을 출력하는 bytecode입니다.

```c title="Python/bytecodes.c"

// dummy_func
// ...
// BEGIN BYTECODES //
    inst(SAY_HELLO, (--)) {
        printf("HeIIo, World!\n");
```
<!-- ![](https://wishket.com/media/news/3560/42.png) -->

이후 `make regen-all`을 하면 bytecode가 생성됩니다.

### compiler

hello의 compiler를 만들어 보겠습니다.

```c title="Python/compile.c"

static int compiler_hello(struct compiler *c, stmt_ty s)
{
    // hello 검증
    assert(s->kind == Hello_kind);

    // end Label 선언
    NEW_JUMP_TARGET_LABEL(c, end);

    // test가 참일 경우 end로 jump
    RETURN_IF_ERROR(compiler_jump_if(c, LOC(s), s—>v.Hello.test, end, 0));
    // SAY_HELLO bytecode 추가
    ADDOP(C, LOC(s), SAY_HELLO) ;
    
    // end Label 사용
    USE_LABEL(C, end) ;
    return SUCCESS;
}

// ...

// compiler_visit_stmt
// ...
//     case Nonlocal_kind:
//         break;
    case Hello_kind:
        return compiler hello(c, s) ;
```
<!-- ![](https://wishket.com/media/news/3560/43.png) -->

hello의 compiler를 구현했습니다. `make -j3`를 입력하여 빌드 후 실행하면, 다음과 같이 동작합니다.

![](https://wishket.com/media/news/3560/44.png)

![](https://wishket.com/media/news/3560/45.png)

이로써 예약어 Hello를 구현해 봤습니다.

---

## 마치며

Python은 지금까지 살펴본 것처럼 동작합니다. 저희는 예약어를 직접 만들어 보며 그 과정 속에서 Python의 내부 동작을 함께 살펴볼 수 있었습니다. 사실 실제로 예약어를 만들 일은 거의 없으며, Python의 내부 동작을 깊이 고려해야 할 상황도 많지 않습니다. 그럼에도 불구하고, Python의 내부 동작을 이해해 보는 것은 Python 사용자로서 충분히 의미 있는 일이라고 생각합니다. 이 글이 여러분께 도움이 되기를 바랍니다.

<!-- TODO: add ARTICLE CARD -->
```component VPCard
{
  "title": "예약어가 되기까지: CPython 딥다이브",
  "desc": "이 글은 PyCon Korea 2025에서 진행된 <defer: print(title)> 세션을 정리한 내용입니다. Go의 defer라는 예약어를 Python에 구현하는 것을 주제로, 그 구현 과정을 따라가며 CPython의 내부 구조를 살펴봅니다. ",
  "link": "https://chanhi2000.github.io/bookshelf/yozm.wishket.com/3560.html",
  "logo": "https://yozm.wishket.com/favicon.ico",
  "background": "rgba(84,7,224,0.2)"
}
```
